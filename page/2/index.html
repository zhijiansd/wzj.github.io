<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="ZhiJian">
<meta property="og:url" content="zhijiansd.github.io/page/2/index.html">
<meta property="og:site_name" content="ZhiJian">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZhiJian">






  <link rel="canonical" href="zhijiansd.github.io/page/2/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>ZhiJian</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZhiJian</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="zhijiansd.github.io/blog/pg11/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhiJian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhiJian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/pg11/" class="post-title-link" itemprop="zhijiansd.github.io/page/2/index.html">PostgreSQL之数据库架构与条件表达式和运算符</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-20 13:00:52 / 修改时间：13:01:55" itemprop="dateCreated datePublished" datetime="2020-05-20T13:00:52+08:00">2020-05-20</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/postresql/" itemprop="url" rel="index"><span itemprop="name">postresql</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/pg11/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/pg11/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">16k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">27 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="管理数据库架构"><a href="#管理数据库架构" class="headerlink" title="管理数据库架构"></a>管理数据库架构</h2><h3 id="PostgreSQL-SCHEMA"><a href="#PostgreSQL-SCHEMA" class="headerlink" title="PostgreSQL SCHEMA"></a>PostgreSQL SCHEMA</h3><blockquote>
<blockquote>
<p>在PostgreSQL中，schema是一个命名空间，其中包含命名的数据库对象，例如表，视图，索引，数据类型，函数和运算符。</p>
</blockquote>
</blockquote>
<blockquote>
<p>要访问模式的对象，请使用schema名称作为前缀来限定其名称：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schema_name.object_name</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者，可以设置包含schema的搜索路径。</p>
</blockquote>
<blockquote>
<p>一个数据库可以包含一个或多个schema，而每个schema仅属于一个数据库。两个schema可以具有共享相同名称的不同对象。</p>
</blockquote>
<blockquote>
<p>例如，您可能有具有工作人员表的销售架构和也有工作人员表的公共架构。 当您参考人员表时，您必须对其进行如下限定：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public.staff</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sales.staff</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用模式的几种方案：</p>
<ul>
<li>Schemas允许您将数据库对象(例如表)组织为逻辑组，以使其更易于管理。</li>
</ul>
<ul>
<li>Schemas使多个用户可以使用一个数据库而不会互相干扰。</li>
</ul>
</blockquote>
<blockquote>
<p>PostgreSQL为每个新数据库创建一个名为public的schema。无论您创建什么对象而没有指定模式名称，PostgreSQL都会自动将其放入此public schema。因此，以下语句是等效的：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name(...);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>和</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE public.table_name(...);</span><br></pre></td></tr></table></figure>
<h4 id="schema搜索路径"><a href="#schema搜索路径" class="headerlink" title="schema搜索路径"></a>schema搜索路径</h4><blockquote>
<p>我们经常引用没有schema名称的表，例如staff表，而不是完全限定的名称，例如sales.staff表。当我们仅使用表名来引用表时，PostgreSQL通过使用称为schema search path的东西来搜索该表，该路径是要查找的chemas列表。</p>
</blockquote>
<blockquote>
<p>PostgreSQL将访问schema search path中的第一个匹配表。如果不匹配，则即使该名称存在于数据库的另一个schema中，也会返回错误。</p>
</blockquote>
<blockquote>
<p>搜索路径中的第一个schema称为当前架构。请注意，在创建新对象而不显式指定schema名称时，PostgreSQL也会将当前schema用于新对象。current_schema()函数返回当前模式：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT current_schema();</span></span><br><span class="line"> current_schema</span><br><span class="line">----------------</span><br><span class="line"> public</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看当前schema路径</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SHOW search_path;</span></span><br><span class="line">   search_path</span><br><span class="line">-----------------</span><br><span class="line"> <span class="string">"<span class="variable">$user</span>"</span>, public</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">SHOW</span><br></pre></td></tr></table></figure>
<ul>
<li>“$user”指定PostgreSQL将用于搜索对象的第一个schema，该schema与当前用户同名。例如，如果您使用postgres用户登录并访问staff表。PostgreSQL将在postgres模式中搜索staff表。如果找不到类似的对象，它将继续在public schema中寻找对象。</li>
</ul>
<ul>
<li>第二个元素指的是我们之前看到的public schema。要创建新schema，请使用CREATE SCHEMA语句：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE SCHEMA sales;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要将新schema添加到搜索路径，请使用以下命令：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET search_path TO sales, public;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在，如果在不指定schema名称的情况下创建了一个名为staff的新表，PostgreSQL将把这个staff表放入sales schema：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE staff(</span><br><span class="line">    staff_id SERIAL PRIMARY KEY,</span><br><span class="line">    name VARCHAR(45) NOT NULL,</span><br><span class="line">    email VARCHAR(100) NOT NULL UNIQUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>访问sales架构中的staff表，可以使用以下语句之一：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM staff;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要么</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM sales.staff;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>public schema是搜索路径中的第二个元素，因此要访问 public schema中的staff表，必须按如下所示限定表名：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM public.staff;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果使用以下命令，则需要使用完全限定的名称来显式引用public架构中的对象：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET search_path TO public;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该public架构不是特殊的架构，因此，您也可以删除它。</p>
</blockquote>
<h4 id="schemas和特权"><a href="#schemas和特权" class="headerlink" title="schemas和特权"></a>schemas和特权</h4><blockquote>
<p>用户只能访问其拥有的架构中的对象。这意味着他们无法访问架构中不属于它们的任何对象。为了使用户能够访问他们不拥有的架构中的对象，必须将USAGE特权授予该架构上的用户，如以下语句所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT USAGE ON SCHEMA schema_name TO user_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要允许用户在他们不拥有的架构中创建对象，您需要向他们授予CREATE该架构的特权:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT CREATE ON SCHEMA schema_name TO user_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，默认情况下，每个用户在public schema上都具有CREATE和USAGE。</p>
</blockquote>
<h4 id="schema操作"><a href="#schema操作" class="headerlink" title="schema操作"></a>schema操作</h4><ul>
<li>要创建新的schema，请使用以下CREATE SCHEMA语句。</li>
</ul>
<ul>
<li>要重命名schema或更改其所有者，请使用以下ALTER SCHEMA语句。</li>
</ul>
<ul>
<li>要删除schema，请使用以下DROP SCHEMA语句。</li>
</ul>
<h3 id="CREATE-SCHEMA语句"><a href="#CREATE-SCHEMA语句" class="headerlink" title="CREATE SCHEMA语句"></a>CREATE SCHEMA语句</h3><blockquote>
<p>CREATE SCHEMA语句允许您在当前数据库中创建新的架构。</p>
</blockquote>
<h4 id="CREATE-SCHEMA语句的语法"><a href="#CREATE-SCHEMA语句的语法" class="headerlink" title="CREATE SCHEMA语句的语法"></a>CREATE SCHEMA语句的语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE SCHEMA [IF NOT EXISTS] schema_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，在CREATE SCHEMA关键字之后指定架构的名称。模式名称在当前数据库中必须是唯一的。</li>
</ul>
<ul>
<li>其次，可选地IF NOT EXISTS，仅在不存在新模式时用于有条件地创建新模式。尝试创建不使用IF NOT EXISTS选项的现有新模式将导致错误。</li>
</ul>
<blockquote>
<p>请注意，要执行CREATE SCHEMA语句，您必须在当前数据库中具有CREATE特权。</p>
</blockquote>
<blockquote>
<p>为用户创建架构：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE SCHEMA [IF NOT EXISTS] AUTHORIZATION user_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这种情况下，架构将与user_name具有相同的名称。</p>
</blockquote>
<blockquote>
<p>PostgreSQL还允许您使用单个语句创建模式和对象列表，例如表和视图，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE SCHEMA schema_name</span><br><span class="line">    CREATE TABLE table_name1 (...)</span><br><span class="line">    CREATE TABLE table_name2 (...)</span><br><span class="line">    CREATE VIEW view_name1</span><br><span class="line">        SELECT select_list FROM table_name1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，每个子命令都不以分号（;）结尾。</p>
</blockquote>
<h4 id="CREATE-SCHEMA用于创建新的架构示例"><a href="#CREATE-SCHEMA用于创建新的架构示例" class="headerlink" title="CREATE SCHEMA用于创建新的架构示例"></a>CREATE SCHEMA用于创建新的架构示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE SCHEMA IF NOT EXISTS fly;</span></span><br><span class="line">CREATE SCHEMA</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从当前数据库返回所有架构</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">  *</span><br><span class="line">FROM</span><br><span class="line">    pg_catalog.pg_namespace</span><br><span class="line">ORDER BY</span><br><span class="line">    nspname;</span><br><span class="line">  oid  |      nspname       | nspowner |               nspacl</span><br><span class="line">-------+--------------------+----------+-------------------------------------</span><br><span class="line"> 18861 | fly                |    16384 |</span><br><span class="line"> 13887 | information_schema |       10 | &#123;postgres=UC/postgres,=U/postgres&#125;</span><br><span class="line">    11 | pg_catalog         |       10 | &#123;postgres=UC/postgres,=U/postgres&#125;</span><br><span class="line"> 12314 | pg_temp_1          |       10 |</span><br><span class="line"> 17777 | pg_temp_3          |       10 |</span><br><span class="line"> 17772 | pg_temp_4          |       10 |</span><br><span class="line">    99 | pg_toast           |       10 |</span><br><span class="line"> 12315 | pg_toast_temp_1    |       10 |</span><br><span class="line"> 17778 | pg_toast_temp_3    |       10 |</span><br><span class="line"> 17773 | pg_toast_temp_4    |       10 |</span><br><span class="line">  2200 | public             |       10 | &#123;postgres=UC/postgres,=UC/postgres&#125;</span><br><span class="line">(11 rows)</span><br></pre></td></tr></table></figure>
<h4 id="使用CREATE-SCHEMA为用户示例创建模式"><a href="#使用CREATE-SCHEMA为用户示例创建模式" class="headerlink" title="使用CREATE SCHEMA为用户示例创建模式"></a>使用CREATE SCHEMA为用户示例创建模式</h4><blockquote>
<p>首先，创建一个名为zhi的新用户:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE USER zhi WITH ENCRYPTED PASSWORD 'postgres321!';</span></span><br><span class="line">CREATE ROLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其次，为zhi创建一个模式:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE SCHEMA AUTHORIZATION zhi;</span></span><br><span class="line">CREATE SCHEMA</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三，创建将由zhi拥有的新架构：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE SCHEMA IF NOT EXISTS fly AUTHORIZATION zhi;</span></span><br><span class="line">CREATE SCHEMA</span><br></pre></td></tr></table></figure>
<h5 id="使用CREATE-SCHEMA创建模式及其对象示例"><a href="#使用CREATE-SCHEMA创建模式及其对象示例" class="headerlink" title="使用CREATE SCHEMA创建模式及其对象示例"></a>使用CREATE SCHEMA创建模式及其对象示例</h5><blockquote>
<p>使用CREATE SCHEMA语句创建一个名为scm的新架构。它还创建一个名为abc的表和一个属于scm模式的名为abc_scm_list的视图：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE SCHEMA scm</span></span><br><span class="line">    CREATE TABLE abc(</span><br><span class="line">        id SERIAL NOT NULL,</span><br><span class="line">        customer_id INT NOT NULL,</span><br><span class="line">        date DATE NOT NULL</span><br><span class="line">    )</span><br><span class="line">    CREATE VIEW abc_scm_list AS</span><br><span class="line">        SELECT ID, date</span><br><span class="line">        FROM abc</span><br><span class="line">        WHERE date &lt;= CURRENT_DATE;</span><br><span class="line">CREATE SCHEMA</span><br></pre></td></tr></table></figure>
<h3 id="ALTER-SCHEMA语句"><a href="#ALTER-SCHEMA语句" class="headerlink" title="ALTER SCHEMA语句"></a>ALTER SCHEMA语句</h3><h4 id="ALTER-SCHEMA语句语法"><a href="#ALTER-SCHEMA语句语法" class="headerlink" title="ALTER SCHEMA语句语法"></a>ALTER SCHEMA语句语法</h4><blockquote>
<p>ALTER SCHEMA语句允许您更改模式的定义。例如，您可以按以下方式重命名架构：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER SCHEMA schema_name</span><br><span class="line">RENAME TO new_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，在ALTER SCHEMA关键字之后指定要重命名的架构的名称。</li>
</ul>
<ul>
<li>其次，在RENAME TO关键字之后指定模式的新名称。</li>
</ul>
<blockquote>
<p>请注意，要执行此语句，您必须是架构的所有者，并且必须具有数据库的CREATE特权。</p>
</blockquote>
<blockquote>
<p>除了重命名模式，ALTER SCHEMA还允许您将模式的所有者更改为新的模式，如以下语句所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER SCHEMA schema_name</span><br><span class="line">OWNER TO &#123; new_owner | CURRENT_USER | SESSION_USER&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，在ALTER SCHEMA子句中指定要将所有者更改为的架构的名称。</li>
</ul>
<ul>
<li>其次，在OWNER TO子句中指定新所有者。</li>
</ul>
<h4 id="使用ALTER-SCHEMA语句重命名架构"><a href="#使用ALTER-SCHEMA语句重命名架构" class="headerlink" title="使用ALTER SCHEMA语句重命名架构"></a>使用ALTER SCHEMA语句重命名架构</h4><blockquote>
<p>使用ALTER SCHEMA语句将架构fly重命名为flyme</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER SCHEMA fly</span></span><br><span class="line">RENAME TO flyme;</span><br><span class="line">ALTER SCHEMA</span><br></pre></td></tr></table></figure>
<h4 id="使用ALTER-SCHEMA语句更改架构所有者"><a href="#使用ALTER-SCHEMA语句更改架构所有者" class="headerlink" title="使用ALTER SCHEMA语句更改架构所有者"></a>使用ALTER SCHEMA语句更改架构所有者</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER SCHEMA flyme</span></span><br><span class="line">OWNER TO postgres;</span><br><span class="line">ALTER SCHEMA</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">  *</span><br><span class="line">FROM</span><br><span class="line">    pg_catalog.pg_namespace</span><br><span class="line">WHERE</span><br><span class="line">    nspacl is NULL AND</span><br><span class="line">    nspname NOT LIKE <span class="string">'pg_%'</span></span><br><span class="line">ORDER BY</span><br><span class="line">    nspname;</span><br><span class="line">  oid  | nspname | nspowner | nspacl</span><br><span class="line">-------+---------+----------+--------</span><br><span class="line"> 18861 | flyme   |       10 |</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从输出中可以清楚地看到，flyme模式现在由ID为10的所有者（即postgres）拥有。</p>
</blockquote>
<h3 id="DROP-SCHEMA语句"><a href="#DROP-SCHEMA语句" class="headerlink" title="DROP SCHEMA语句"></a>DROP SCHEMA语句</h3><blockquote>
<p>DROP SCHEMA从数据库中删除模式及其所有对象。</p>
</blockquote>
<h4 id="DROP-SCHEMA语句的语法"><a href="#DROP-SCHEMA语句的语法" class="headerlink" title="DROP SCHEMA语句的语法"></a>DROP SCHEMA语句的语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP SCHEMA [IF EXISTS] schema_name [ CASCADE | RESTRICT ];</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，在DROP SCHEMA关键字之后指定要从中删除的架构的名称。</li>
</ul>
<ul>
<li>其次，使用IF EXISTS选项仅在模式存在时才有条件地删除它。</li>
</ul>
<ul>
<li>第三，使用CASCADE删除架构及其所有对象，然后依次删除所有依赖于那些对象的对象。如果只想在模式为空时删除模式，则可以使用RESTRICT选项。默认情况下，PostgreSQL使用RESTRICT。</li>
</ul>
<blockquote>
<p>要执行DROP SCHEMA语句，您必须是要删除的架构的所有者或超级用户。</p>
</blockquote>
<blockquote>
<p>PostgreSQL允许您使用单个DROP SCHEMA语句同时删除多个模式：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP SCHEMA [IF EXISTS] schema_name1 [,schema_name2,...]</span><br><span class="line">[CASCADE | RESTRICT];</span><br></pre></td></tr></table></figure>
<h4 id="使用DROP-SCHEMA语句删除空模式"><a href="#使用DROP-SCHEMA语句删除空模式" class="headerlink" title="使用DROP SCHEMA语句删除空模式"></a>使用DROP SCHEMA语句删除空模式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DROP SCHEMA IF EXISTS flyme;</span></span><br><span class="line">DROP SCHEMA</span><br></pre></td></tr></table></figure>
<h4 id="使用DROP-SCHEMA语句删除多个模式"><a href="#使用DROP-SCHEMA语句删除多个模式" class="headerlink" title="使用DROP SCHEMA语句删除多个模式"></a>使用DROP SCHEMA语句删除多个模式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># DROP SCHEMA IF EXISTS fly,zhi;</span></span><br><span class="line">DROP SCHEMA</span><br></pre></td></tr></table></figure>
<h4 id="使用DROP-SCHEMA语句删除非空模式"><a href="#使用DROP-SCHEMA语句删除非空模式" class="headerlink" title="使用DROP SCHEMA语句删除非空模式"></a>使用DROP SCHEMA语句删除非空模式</h4><blockquote>
<p>直接删除将提示错误</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># DROP SCHEMA IF EXISTS scm;</span></span><br><span class="line">错误:  无法删除 模式 scm 因为有其它对象倚赖它</span><br><span class="line">DETAIL:  表 scm.abc 倚赖于 模式 scm</span><br><span class="line">视图 scm.abc_scm_list 倚赖于 模式 scm</span><br><span class="line">HINT:  使用 DROP .. CASCADE 把倚赖对象一并删除.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因此，如果架构不为空，并且想要删除架构及其对象，则必须使用CASCADE选项：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># DROP SCHEMA scm CASCADE;</span></span><br><span class="line">注意:  串联删除2个其它对象</span><br><span class="line">DETAIL:  递归删除 表 scm.abc</span><br><span class="line">递归删除 视图 scm.abc_scm_list</span><br><span class="line">DROP SCHEMA</span><br></pre></td></tr></table></figure>
<h2 id="条件表达式和运算符"><a href="#条件表达式和运算符" class="headerlink" title="条件表达式和运算符"></a>条件表达式和运算符</h2><h3 id="CASE表达式"><a href="#CASE表达式" class="headerlink" title="CASE表达式"></a>CASE表达式</h3><blockquote>
<p>PostgreSQL CASE表达式与其他编程语言中的IF/ELSE语句相同。PostgreSQL提供了两种形式的CASE表达式。</p>
</blockquote>
<blockquote>
<p>CASE语句的一般形式:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE</span><br><span class="line">      WHEN condition_1  THEN result_1</span><br><span class="line">      WHEN condition_2  THEN result_2</span><br><span class="line">      [WHEN ...]</span><br><span class="line">      [ELSE result_n]</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这种一般形式下，每个条件都是一个返回布尔值（真或假）的表达式。</p>
</blockquote>
<blockquote>
<p>如果条件评估为真，则CASE表达式返回与条件相对应的结果，并且所有其他CASE分支根本不处理。</p>
</blockquote>
<blockquote>
<p>如果所有条件都为假，则CASE表达式将在ELSE部分返回结果。如果省略ELSE子句，则CASE表达式将返回null。</p>
</blockquote>
<blockquote>
<p>请注意，所有结果表达式必须具有可转换为单个数据类型的数据类型，例如字符串，数字和时间。</p>
</blockquote>
<h4 id="简单的CASE表达式"><a href="#简单的CASE表达式" class="headerlink" title="简单的CASE表达式"></a>简单的CASE表达式</h4><blockquote>
<p>PostgreSQL提供了另一种CASE表达式形式，称为简单形式，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CASE expression</span><br><span class="line">WHEN value_1 THEN</span><br><span class="line">   result_1</span><br><span class="line">WHEN value_2 THEN</span><br><span class="line">   result_2</span><br><span class="line">[WHEN ...]</span><br><span class="line">ELSE</span><br><span class="line">   result_n</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CASE首先对表达式求值，然后将结果与WHEN子句中的每个值（value_1，value_2，…）进行比较，直到找到匹配项。一旦表达式的结果等于WHEN子句中的值，则CASE在THEN子句中返回相应的结果。</p>
</blockquote>
<blockquote>
<p>如果CASE未找到任何匹配项，则它将在ELSE部分中返回result_n，如果ELSE部分不可用则返回NULL值。这类似于其他编程语言（例如C/C++和Java）中的switch语句。</p>
</blockquote>
<blockquote>
<p>假设您要使用以下逻辑为电影分配价格段：</p>
<ul>
<li>如果出租率为0.99，则为大众</li>
</ul>
<ul>
<li>如果租金率为1.99则经济</li>
</ul>
<ul>
<li>如果租金率为4.99，则为豪华<br>您想知道属于大众，经济和豪华价格段的电影数量。 </li>
</ul>
</blockquote>
<blockquote>
<p>在这种情况下，可以使用CASE表达式来构造查询，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   SUM (</span><br><span class="line">      CASE</span><br><span class="line">      WHEN rental_rate = 0.99 THEN</span><br><span class="line">         1</span><br><span class="line">      ELSE</span><br><span class="line">         0</span><br><span class="line">      END</span><br><span class="line">   ) AS <span class="string">"Mass"</span>,</span><br><span class="line">   SUM (</span><br><span class="line">      CASE</span><br><span class="line">      WHEN rental_rate = 2.99 THEN</span><br><span class="line">         1</span><br><span class="line">      ELSE</span><br><span class="line">         0</span><br><span class="line">      END</span><br><span class="line">   ) AS <span class="string">"Economic"</span>,</span><br><span class="line">   SUM (</span><br><span class="line">      CASE</span><br><span class="line">      WHEN rental_rate = 4.99 THEN</span><br><span class="line">         1</span><br><span class="line">      ELSE</span><br><span class="line">         0</span><br><span class="line">      END</span><br><span class="line">   ) AS <span class="string">"Luxury"</span></span><br><span class="line">FROM</span><br><span class="line">   film;</span><br><span class="line"> Mass | Economic | Luxury</span><br><span class="line">------+----------+--------</span><br><span class="line">  341 |      323 |    336</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<ul>
<li>在此查询中，如果租金属于该价格范围，使用CASE表达式返回1或0。然后，应用SUM函数计算每个价格段的电影总数。</li>
</ul>
<h3 id="COALESCE函数"><a href="#COALESCE函数" class="headerlink" title="COALESCE函数"></a>COALESCE函数</h3><h4 id="COALESCE函数语法"><a href="#COALESCE函数语法" class="headerlink" title="COALESCE函数语法"></a>COALESCE函数语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COALESCE (argument_1, argument_2, …);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>COALESCE函数接受无限数量的参数。它返回不为空的第一个参数。如果所有参数均为null，则COALESCE函数将返回null。</p>
</blockquote>
<blockquote>
<p>COALESCE函数从左到右评估参数，直到找到第一个非空参数为止。第一个非null参数中的所有其余参数均不进行评估。</p>
</blockquote>
<blockquote>
<p>COALESCE函数提供与SQL标准提供的NVL或IFNULL函数相同的功能。MySQL具有IFNULL函数，而Oracle提供NVL函数。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   COALESCE (1, 2);</span><br><span class="line"> coalesce</span><br><span class="line">----------</span><br><span class="line">        1</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   COALESCE (NULL, 2 , 1);</span><br><span class="line"> coalesce</span><br><span class="line">----------</span><br><span class="line">        2</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在查询数据时，我们经常使用COLAESCE函数将默认值替换为空值。例如，我们要显示博客文章的摘录，如果未提供摘录，则可以使用文章内容的前150个字符。为此，我们可以使用COALESCE函数，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">   COALESCE (excerpt, LEFT(CONTENT, 150))</span><br><span class="line">FROM</span><br><span class="line">   posts;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line"><span class="comment">#### COALESCE示例</span></span><br><span class="line">&gt; 创建一个名为items的表</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE items (</span></span><br><span class="line">   ID serial PRIMARY KEY,</span><br><span class="line">   product VARCHAR (100) NOT NULL,</span><br><span class="line">   price NUMERIC NOT NULL,</span><br><span class="line">   discount NUMERIC</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<p>id:标识项目表中项目的主键。<br>product:产品名称。<br>price:产品的价格。<br>discount:产品的折扣。</p>
<blockquote>
<p>其次，使用INSERT语句将一些记录插入到item表中，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO items (product, price, discount)</span></span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'A'</span>, 1000 ,10),</span><br><span class="line">   (<span class="string">'B'</span>, 1500 ,20),</span><br><span class="line">   (<span class="string">'C'</span>, 800 ,5),</span><br><span class="line">   (<span class="string">'D'</span>, 500, NULL);</span><br><span class="line">INSERT 0 4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三，使用以下公式查询产品的净价:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net_price = price - discount;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   product,</span><br><span class="line">   (price - discount) AS net_price</span><br><span class="line">FROM</span><br><span class="line">   items;</span><br><span class="line"> product | net_price</span><br><span class="line">---------+-----------</span><br><span class="line"> A       |       990</span><br><span class="line"> B       |      1480</span><br><span class="line"> C       |       795</span><br><span class="line"> D       |</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果查看第四行，您会注意到产品D的净价格为零，这似乎是不正确的。问题是产品D的折扣为null，因此当我们使用null值计算净价时，PostgreSQL返回null。</p>
</blockquote>
<blockquote>
<p>为了获得正确的价格，我们需要假设折扣为零，则为零。然后我们可以使用COALESCE函数，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   product,</span><br><span class="line">   (price - COALESCE(discount,0)) AS net_price</span><br><span class="line">FROM</span><br><span class="line">   items;</span><br><span class="line"> product | net_price</span><br><span class="line">---------+-----------</span><br><span class="line"> A       |       990</span><br><span class="line"> B       |      1480</span><br><span class="line"> C       |       795</span><br><span class="line"> D       |       500</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在产品D的净价为500，因为在计算净价时我们使用零而不是空值。</p>
</blockquote>
<blockquote>
<p>在这种情况下，除了使用COALESCE函数外，还可以使用CASE表达式来处理空值:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   product,</span><br><span class="line">   (</span><br><span class="line">      price - CASE</span><br><span class="line">      WHEN discount IS NULL THEN</span><br><span class="line">         0</span><br><span class="line">      ELSE</span><br><span class="line">         discount</span><br><span class="line">      END</span><br><span class="line">   ) AS net_price</span><br><span class="line">FROM</span><br><span class="line">   items;</span><br><span class="line"> product | net_price</span><br><span class="line">---------+-----------</span><br><span class="line"> A       |       990</span><br><span class="line"> B       |      1480</span><br><span class="line"> C       |       795</span><br><span class="line"> D       |       500</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在上面的查询中，如果折扣为null，则使用零(0)，否则在计算净价格的表达式中使用折扣值。</p>
</blockquote>
<blockquote>
<p>在性能方面，COALESCE函数和CASE表达式相同。与COASE表达式相比，COALESCE函数使查询更短且更易于阅读。</p>
</blockquote>
<h3 id="NULLIF函数"><a href="#NULLIF函数" class="headerlink" title="NULLIF函数"></a>NULLIF函数</h3><blockquote>
<p>NULLIF函数是PostgreSQL提供的最常见的条件表达式之一。</p>
</blockquote>
<h4 id="NULLIF函数语法"><a href="#NULLIF函数语法" class="headerlink" title="NULLIF函数语法"></a>NULLIF函数语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NULLIF(argument_1,argument_2);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果argument_1等于argument_2，则NULLIF函数返回空值，否则返回argument_1。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">   NULLIF (1, 1); -- <span class="built_in">return</span> NULL</span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">   NULLIF (1, 0); -- <span class="built_in">return</span> 1</span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">   NULLIF (<span class="string">'A'</span>, <span class="string">'B'</span>); -- <span class="built_in">return</span> A</span><br></pre></td></tr></table></figure>
<h4 id="NULLIF函数示例"><a href="#NULLIF函数示例" class="headerlink" title="NULLIF函数示例"></a>NULLIF函数示例</h4><blockquote>
<p>创建一个名为posts的表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE posts (</span></span><br><span class="line">   id serial primary key,</span><br><span class="line">   title VARCHAR (255) NOT NULL,</span><br><span class="line">   excerpt VARCHAR (150),</span><br><span class="line">   body TEXT,</span><br><span class="line">   created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">   updated_at TIMESTAMP</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>插入数据</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO posts (title, excerpt, body)</span></span><br><span class="line">VALUES</span><br><span class="line">      (<span class="string">'test post 1'</span>,<span class="string">'test post excerpt 1'</span>,<span class="string">'test post body 1'</span>),</span><br><span class="line">      (<span class="string">'test post 2'</span>,<span class="string">''</span>,<span class="string">'test post body 2'</span>),</span><br><span class="line">      (<span class="string">'test post 3'</span>, null ,<span class="string">'test post body 3'</span>);</span><br><span class="line">INSERT 0 3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的目标是显示帖子概述页面，该页面显示每个帖子的标题和摘录。如果未提供摘录，我们将使用帖子正文的前40个字符。我们可以简单地使用以下查询来获取posts表中的所有行：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   ID,</span><br><span class="line">   title,</span><br><span class="line">   excerpt</span><br><span class="line">FROM</span><br><span class="line">   posts;</span><br><span class="line"> id |    title    |       excerpt</span><br><span class="line">----+-------------+---------------------</span><br><span class="line">  1 | <span class="built_in">test</span> post 1 | <span class="built_in">test</span> post excerpt 1</span><br><span class="line">  2 | <span class="built_in">test</span> post 2 |</span><br><span class="line">  3 | <span class="built_in">test</span> post 3 |</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在摘录栏中看到空值。要替换此空值，我们可以使用COALESCE函数，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   id,</span><br><span class="line">   title,</span><br><span class="line">   COALESCE (excerpt, LEFT(body, 40))</span><br><span class="line">FROM</span><br><span class="line">   posts;</span><br><span class="line"> id |    title    |      coalesce</span><br><span class="line">----+-------------+---------------------</span><br><span class="line">  1 | <span class="built_in">test</span> post 1 | <span class="built_in">test</span> post excerpt 1</span><br><span class="line">  2 | <span class="built_in">test</span> post 2 |</span><br><span class="line">  3 | <span class="built_in">test</span> post 3 | <span class="built_in">test</span> post body 3</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不幸的是，摘录栏中的null值和“（空）”之间混合使用。这就是为什么我们需要使用NULLIF函数的原因：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   id,</span><br><span class="line">   title,</span><br><span class="line">   COALESCE (</span><br><span class="line">      NULLIF (excerpt, <span class="string">''</span>),</span><br><span class="line">      LEFT (body, 40)</span><br><span class="line">   )</span><br><span class="line">FROM</span><br><span class="line">   posts;</span><br><span class="line"> id |    title    |      coalesce</span><br><span class="line">----+-------------+---------------------</span><br><span class="line">  1 | <span class="built_in">test</span> post 1 | <span class="built_in">test</span> post excerpt 1</span><br><span class="line">  2 | <span class="built_in">test</span> post 2 | <span class="built_in">test</span> post body 2</span><br><span class="line">  3 | <span class="built_in">test</span> post 3 | <span class="built_in">test</span> post body 3</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，如果摘录为空，则NULLIF函数将返回空值，否则它将返回摘录。NULLIF函数的结果由COALESCE函数使用。</li>
</ul>
<ul>
<li>其次，COALESCE函数检查NULLIF函数提供的第一个参数是否为null，然后返回正文的前40个字符；否则，如果摘录不为null，则返回摘录。</li>
</ul>
<h4 id="使用NULLIF防止被除零错误"><a href="#使用NULLIF防止被除零错误" class="headerlink" title="使用NULLIF防止被除零错误"></a>使用NULLIF防止被除零错误</h4><blockquote>
<p>使用NULLIF函数的另一个很好的例子是防止被除零错误。</p>
</blockquote>
<blockquote>
<p>创建一个名为members的新表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE members (</span></span><br><span class="line">   ID serial PRIMARY KEY,</span><br><span class="line">   name VARCHAR (50) NOT NULL,</span><br><span class="line">   gender SMALLINT NOT NULL -- 1: male, 2 female</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>插入数据</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO members (</span></span><br><span class="line">   name,</span><br><span class="line">   gender</span><br><span class="line">)</span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'John'</span>, 1),</span><br><span class="line">   (<span class="string">'David'</span>,  1),</span><br><span class="line">   (<span class="string">'Bush'</span>, 2);</span><br><span class="line">INSERT 0 3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要计算男性成员与女性成员之间的比例，请使用以下查询：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   (SUM (</span><br><span class="line">      CASE</span><br><span class="line">      WHEN gender = 1 THEN</span><br><span class="line">         1</span><br><span class="line">      ELSE</span><br><span class="line">         0</span><br><span class="line">      END</span><br><span class="line">   ) / SUM (</span><br><span class="line">      CASE</span><br><span class="line">      WHEN gender = 2 THEN</span><br><span class="line">         1</span><br><span class="line">      ELSE</span><br><span class="line">         0</span><br><span class="line">      END</span><br><span class="line">   ) ) * 100 AS <span class="string">"Male/Female ratio"</span></span><br><span class="line">FROM</span><br><span class="line">   members;</span><br><span class="line"> Male/Female ratio</span><br><span class="line">-------------------</span><br><span class="line">               200</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要计算男性成员总数，我们使用SUM函数和CASE表达式。如果性别为1，则CASE表达式返回1，否则返回0；否则，返回0。 SUM函数用于计算男性成员总数。同样的逻辑也适用于计算女性成员的总数。</p>
</blockquote>
<blockquote>
<p>然后，将男性成员总数除以女性成员总数即可得出该比率。在这种情况下，它将返回200％，这是正确的。</p>
</blockquote>
<blockquote>
<p>删除女性成员</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DELETE</span></span><br><span class="line">FROM</span><br><span class="line">   members</span><br><span class="line">WHERE</span><br><span class="line">   gender = 2;</span><br><span class="line">DELETE 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>再次执行查询以计算男女比例，我们得到以下错误消息：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误:  除以零</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原因是女性人数为零。为了防止被除零的错误，我们使用NULLIF函数，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   (</span><br><span class="line">      SUM (</span><br><span class="line">         CASE</span><br><span class="line">         WHEN gender = 1 THEN</span><br><span class="line">            1</span><br><span class="line">         ELSE</span><br><span class="line">            0</span><br><span class="line">         END</span><br><span class="line">      ) / NULLIF (</span><br><span class="line">         SUM (</span><br><span class="line">            CASE</span><br><span class="line">            WHEN gender = 2 THEN</span><br><span class="line">               1</span><br><span class="line">            ELSE</span><br><span class="line">               0</span><br><span class="line">            END</span><br><span class="line">         ),</span><br><span class="line">         0</span><br><span class="line">      )</span><br><span class="line">   ) * 100 AS <span class="string">"Male/Female ratio"</span></span><br><span class="line">FROM</span><br><span class="line">   members;</span><br><span class="line"> Male/Female ratio</span><br><span class="line">-------------------</span><br><span class="line"></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>NULLIF函数检查母成员数是否为零，它返回null。男性成员总数除以null值将返回一个null值，这是正确的。</p>
</blockquote>
<h3 id="CAST运算符"><a href="#CAST运算符" class="headerlink" title="CAST运算符"></a>CAST运算符</h3><blockquote>
<p>在很多情况下，您都希望将一种数据类型的值转换为另一种数据类型。PostgreSQL为您提供了CAST允许您执行此操作的运算符。</p>
</blockquote>
<h4 id="CAST类型的语法"><a href="#CAST类型的语法" class="headerlink" title="CAST类型的语法"></a>CAST类型的语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CAST ( expression AS target_type );</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，指定一个可以是常量的表达式，一个表列，一个求值的表达式。</li>
</ul>
<ul>
<li>然后，指定要将表达式结果转换为的目标数据类型。</li>
</ul>
<h4 id="PostgreSQL类型转换-运算符"><a href="#PostgreSQL类型转换-运算符" class="headerlink" title="PostgreSQL类型转换::运算符"></a>PostgreSQL类型转换::运算符</h4><blockquote>
<p>除了CAST语法之外，您还可以使用以下语法将一种类型的值转换为另一种类型：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression::<span class="built_in">type</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">  <span class="string">'100'</span>::INTEGER,</span><br><span class="line">  <span class="string">'01-OCT-2018'</span>::DATE;</span><br><span class="line"> int4 |    date</span><br><span class="line">------+------------</span><br><span class="line">  100 | 2018-10-01</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，带有强制转换运算符(::)的强制转换语法是特定于PostgreSQL的，并且不符合SQL标准。</p>
</blockquote>
<h4 id="将字符串转换为整数"><a href="#将字符串转换为整数" class="headerlink" title="将字符串转换为整数"></a>将字符串转换为整数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   CAST (<span class="string">'100'</span> AS INTEGER);</span><br><span class="line"> int4</span><br><span class="line">------</span><br><span class="line">  100</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果表达式不能转换为目标类型，PostgreSQL将引发错误。请参见以下示例:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   CAST (<span class="string">'10C'</span> AS INTEGER);</span><br><span class="line">错误:  无效的类型 <span class="built_in">integer</span> 输入语法: <span class="string">"10C"</span></span><br><span class="line">LINE 2:    CAST (<span class="string">'10C'</span> AS INTEGER)</span><br></pre></td></tr></table></figure>
<h4 id="将字符串转换为日期"><a href="#将字符串转换为日期" class="headerlink" title="将字符串转换为日期"></a>将字符串转换为日期</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   CAST (<span class="string">'2018-01-01'</span> AS DATE),</span><br><span class="line">   CAST (<span class="string">'01-OCT-2018'</span> AS DATE);</span><br><span class="line">    date    |    date</span><br><span class="line">------------+------------</span><br><span class="line"> 2018-01-01 | 2018-10-01</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，将2015-01-01文字字符串转换为January 1st 2015。其次，转换01-OCT-2015为October 1st 2015。</li>
</ul>
<h4 id="将字符串强制转换为双精度值"><a href="#将字符串强制转换为双精度值" class="headerlink" title="将字符串强制转换为双精度值"></a>将字符串强制转换为双精度值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   CAST (<span class="string">'10.2'</span> AS DOUBLE);</span><br><span class="line">错误:  类型 <span class="string">"double"</span> 不存在</span><br><span class="line">LINE 2:    CAST (<span class="string">'10.2'</span> AS DOUBLE)</span><br><span class="line">                           ^</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用DOUBLE PRECISION而不是DOUBLE</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   CAST (<span class="string">'10.2'</span> AS DOUBLE PRECISION);</span><br><span class="line"> float8</span><br><span class="line">--------</span><br><span class="line">   10.2</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="将字符串强制转换为布尔型"><a href="#将字符串强制转换为布尔型" class="headerlink" title="将字符串强制转换为布尔型"></a>将字符串强制转换为布尔型</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   CAST(<span class="string">'true'</span> AS BOOLEAN),</span><br><span class="line">   CAST(<span class="string">'false'</span> as BOOLEAN),</span><br><span class="line">   CAST(<span class="string">'T'</span> as BOOLEAN),</span><br><span class="line">   CAST(<span class="string">'F'</span> as BOOLEAN);</span><br><span class="line"> bool | bool | bool | bool</span><br><span class="line">------+------+------+------</span><br><span class="line"> t    | f    | t    | f</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="将字符串转换为时间戳"><a href="#将字符串转换为时间戳" class="headerlink" title="将字符串转换为时间戳"></a>将字符串转换为时间戳</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT '2019-06-15 14:30:20'::timestamp;</span></span><br><span class="line">      timestamp</span><br><span class="line">---------------------</span><br><span class="line"> 2019-06-15 14:30:20</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="将字符串转换为间隔"><a href="#将字符串转换为间隔" class="headerlink" title="将字符串转换为间隔"></a>将字符串转换为间隔</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT '15 minute'::interval,</span></span><br><span class="line"><span class="string">'2 hour'</span>::interval,</span><br><span class="line"><span class="string">'1 day'</span>::interval,</span><br><span class="line"><span class="string">'2 week'</span>::interval,</span><br><span class="line"><span class="string">'3 month'</span>::interval;</span><br><span class="line"> interval | interval | interval | interval | interval</span><br><span class="line">----------+----------+----------+----------+----------</span><br><span class="line"> 00:15:00 | 02:00:00 | 1 day    | 14 days  | 3 mons</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="CAST与表格数据一起使用"><a href="#CAST与表格数据一起使用" class="headerlink" title="CAST与表格数据一起使用"></a>CAST与表格数据一起使用</h4><blockquote>
<p>创建一个包含两列的ratings表：id和rating。rating列的数据类型为VARCHAR(1)：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE ratings (</span></span><br><span class="line">   ID serial PRIMARY KEY,</span><br><span class="line">   rating VARCHAR (1) NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>插入数据</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO ratings (rating)</span></span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'A'</span>),</span><br><span class="line">   (<span class="string">'B'</span>),</span><br><span class="line">   (<span class="string">'C'</span>);</span><br><span class="line">INSERT 0 3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于要求有所变化，因此我们使用相同的ratings表将评分存储为数字，例如1、2、3，而不是A，B和C：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO ratings (rating)</span></span><br><span class="line">VALUES</span><br><span class="line">   (1),</span><br><span class="line">   (2),</span><br><span class="line">   (3);</span><br><span class="line">INSERT 0 3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因此，该ratings表存储的混合值包括数字和字符串。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   ratings;</span><br><span class="line"> id | rating</span><br><span class="line">----+--------</span><br><span class="line">  1 | A</span><br><span class="line">  2 | B</span><br><span class="line">  3 | C</span><br><span class="line">  4 | 1</span><br><span class="line">  5 | 2</span><br><span class="line">  6 | 3</span><br><span class="line">(6 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在，我们必须将等级列中的所有值转换为整数，所有其他A，B，C等级将显示为零。为此，可以使用CASE表达式，其类型为CAST，如以下查询所示：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">   id,</span><br><span class="line">   CASE</span><br><span class="line">      WHEN rating~E&apos;^\\d+$&apos; THEN</span><br><span class="line">         CAST (rating AS INTEGER)</span><br><span class="line">      ELSE</span><br><span class="line">         0</span><br><span class="line">      END as rating</span><br><span class="line">FROM</span><br><span class="line">   ratings;</span><br><span class="line"> id | rating</span><br><span class="line">----+--------</span><br><span class="line">  1 |      0</span><br><span class="line">  2 |      0</span><br><span class="line">  3 |      0</span><br><span class="line">  4 |      1</span><br><span class="line">  5 |      2</span><br><span class="line">  6 |      3</span><br><span class="line">(6 rows)</span><br><span class="line">sh</span><br><span class="line">test=# SELECT</span><br><span class="line">   id,</span><br><span class="line">   CASE</span><br><span class="line">      WHEN rating~E&apos;^\\d+$&apos; THEN</span><br><span class="line">         CAST (rating AS INTEGER)</span><br><span class="line">      ELSE</span><br><span class="line">         0</span><br><span class="line">      END as rating</span><br><span class="line">FROM</span><br><span class="line">   ratings;</span><br><span class="line"> id | rating</span><br><span class="line">----+--------</span><br><span class="line">  1 |      0</span><br><span class="line">  2 |      0</span><br><span class="line">  3 |      0</span><br><span class="line">  4 |      1</span><br><span class="line">  5 |      2</span><br><span class="line">  6 |      3</span><br><span class="line">(6 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CASE检查等级，如果它与整数模式匹配，则将等级转换为整数，否则返回0。</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    
    
    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="zhijiansd.github.io/blog/pg10/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhiJian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhiJian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/pg10/" class="post-title-link" itemprop="zhijiansd.github.io/page/2/index.html">PostgreSQL之数据库约束和数据库类型</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-20 12:58:45 / 修改时间：13:00:22" itemprop="dateCreated datePublished" datetime="2020-05-20T12:58:45+08:00">2020-05-20</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/postresql/" itemprop="url" rel="index"><span itemprop="name">postresql</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/pg10/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/pg10/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">52k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1:27</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数据库约束"><a href="#数据库约束" class="headerlink" title="数据库约束"></a>数据库约束</h2><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><blockquote>
<p>主键是一列或一组列，用于在表中唯一地标识一行。可以通过主键约束定义主键。从技术上讲，主键约束是非空约束和UNIQUE约束的组合。</p>
</blockquote>
<blockquote>
<p>一个表只能有一个主键。</p>
</blockquote>
<blockquote>
<p>将主键添加到每个表是一个好习惯。当您向表中添加主键时，PostgreSQL在用于定义主键的列或一组列上创建唯一的B-tree索引。</p>
</blockquote>
<h4 id="创建表时定义主键"><a href="#创建表时定义主键" class="headerlink" title="创建表时定义主键"></a>创建表时定义主键</h4><blockquote>
<p>通常，使用CREATE TABLE语句定义表的结构时，我们会将主键添加到表中。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE TABLE (</span><br><span class="line">   column_1 data_type PRIMARY KEY,</span><br><span class="line">   column_2 data_type,</span><br><span class="line">   …</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下语句创建一个名为po_headers的采购订单（PO）标题表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE po_headers (</span></span><br><span class="line">   po_no INTEGER PRIMARY KEY,</span><br><span class="line">   vendor_no INTEGER,</span><br><span class="line">   description TEXT,</span><br><span class="line">   shipping_address TEXT</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<ul>
<li>po_no是po_headers表的主键，它唯一地标识po_headers表中的采购订单。</li>
</ul>
<blockquote>
<p>如果主键包含两列或更多列，则可以按以下方式定义主键约束：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE TABLE (</span><br><span class="line">   column_1 data_type,</span><br><span class="line">   column_2 data_type,</span><br><span class="line">   …</span><br><span class="line">        PRIMARY KEY (column_1, column_2)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如，以下语句创建采购订单目表，该表的主键是采购订单号(po_no)和行项目号(item_no)的组合:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE po_items (</span></span><br><span class="line">   po_no INTEGER,</span><br><span class="line">   item_no INTEGER,</span><br><span class="line">   product_no INTEGER,</span><br><span class="line">   qty INTEGER,</span><br><span class="line">   net_price NUMERIC,</span><br><span class="line">   PRIMARY KEY (po_no, item_no)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果未明确指定主键约束的名称，则PostgreSQL将为主键约束分配一个默认名称。默认情况下，PostgreSQL使用table-name_pkey作为主键约束的默认名称。在此示例中，PostgreSQL使用po_items表的名称po_items_pkey创建了主键约束。</p>
</blockquote>
<blockquote>
<p>如果要指定主键约束的名称，请使用CONSTRAINT子句，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONSTRAINT constraint_name PRIMARY KEY(column_1, column_2,...);</span><br></pre></td></tr></table></figure>
<h4 id="更改现有表结构时定义主键"><a href="#更改现有表结构时定义主键" class="headerlink" title="更改现有表结构时定义主键"></a>更改现有表结构时定义主键</h4><blockquote>
<p>很少为现有表定义主键。如果必须这样做，则可以使用ALTER TABLE语句添加主键约束。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD PRIMARY KEY (column_1, column_2);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建一个名为product的表，而未定义任何主键。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE products (</span></span><br><span class="line">   product_no INTEGER,</span><br><span class="line">   description TEXT,</span><br><span class="line">   product_cost NUMERIC</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>假设要向products表添加主键约束，可以执行以下语句:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE products</span></span><br><span class="line">ADD PRIMARY KEY (product_no);</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<h4 id="向现有表添加自动递增的主键"><a href="#向现有表添加自动递增的主键" class="headerlink" title="向现有表添加自动递增的主键"></a>向现有表添加自动递增的主键</h4><blockquote>
<p>假设我们有一个没有任何主键的表vendors。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE vendors (name VARCHAR(255));</span></span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后，使用INSERT语句向vendors表中添加几行:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO vendors (NAME)</span></span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'Microsoft'</span>),</span><br><span class="line">   (<span class="string">'IBM'</span>),</span><br><span class="line">   (<span class="string">'Apple'</span>),</span><br><span class="line">   (<span class="string">'Samsung'</span>);</span><br><span class="line">INSERT 0 4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查询数据</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   vendors;</span><br><span class="line">   name</span><br><span class="line">-----------</span><br><span class="line"> Microsoft</span><br><span class="line"> IBM</span><br><span class="line"> Apple</span><br><span class="line"> Samsung</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在，如果我们想在vendors表中添加一个名为id的主键，并且id字段会自动递增一个，我们可以使用以下语句:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE vendors ADD COLUMN ID SERIAL PRIMARY KEY;</span></span><br><span class="line">ALTER TABLE</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   id,name</span><br><span class="line">FROM</span><br><span class="line">   vendors;</span><br><span class="line"> id |   name</span><br><span class="line">----+-----------</span><br><span class="line">  1 | Microsoft</span><br><span class="line">  2 | IBM</span><br><span class="line">  3 | Apple</span><br><span class="line">  4 | Samsung</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<h4 id="删除主键"><a href="#删除主键" class="headerlink" title="删除主键"></a>删除主键</h4><blockquote>
<p>要删除现有的主键约束，可以使用具有以下语法的ALTER TABLE语句:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name DROP CONSTRAINT primary_key_constraint;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如，要删除products表的主键约束，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE products</span></span><br><span class="line">DROP CONSTRAINT products_pkey;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><blockquote>
<p>外键是表中的一个字段或一组字段，用于唯一标识另一个表中的行。换句话说，在引用另一个表的主键的表中定义了外键。</p>
</blockquote>
<blockquote>
<p>包含外键的表称为引用表或子表。外键引用的表称为引用表或父表。</p>
</blockquote>
<blockquote>
<p>一个表可以具有多个外键，这取决于它与其他表的关系。</p>
</blockquote>
<blockquote>
<p>在PostgreSQL中，您可以通过外键约束定义外键。外键约束指示子表中的一列或一组列中的值与父表的一列或一组列中的值匹配。我们说外键约束保持了子表和父表之间的参照完整性。</p>
</blockquote>
<h4 id="定义简单的外键约束"><a href="#定义简单的外键约束" class="headerlink" title="定义简单的外键约束"></a>定义简单的外键约束</h4><blockquote>
<p>假设我们有一个名为so_headers的表用于存储销售订单标题信息，例如销售订单ID，客户ID和运送地址：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE so_headers (</span></span><br><span class="line">   id SERIAL PRIMARY KEY,</span><br><span class="line">   customer_id INTEGER,</span><br><span class="line">   ship_to VARCHAR (255)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>销售订单的行存储在另一个表销售订单行（so_items）中：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE so_items (</span></span><br><span class="line">  item_id INTEGER NOT NULL,   </span><br><span class="line">  so_id INTEGER,</span><br><span class="line">  product_id INTEGER,</span><br><span class="line">  qty INTEGER,</span><br><span class="line">  net_price NUMERIC,</span><br><span class="line">  PRIMARY KEY (item_id,so_id)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>假设销售订单行表（so_items）包含存在的销售订单数据。为此，我们在so_items表中定义一个外键约束，该约束引用CREATE TABLE语句so_headers中的表，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; DROP TABLE so_items;</span><br><span class="line">DROP TABLE</span><br><span class="line"><span class="built_in">test</span>=&gt; CREATE TABLE so_items (</span><br><span class="line">  item_id INTEGER NOT NULL,   </span><br><span class="line">  so_id INTEGER REFERENCES so_headers(id),</span><br><span class="line">  product_id INTEGER,</span><br><span class="line">  qty INTEGER,</span><br><span class="line">  net_price NUMERIC,</span><br><span class="line">  PRIMARY KEY (item_id,so_id)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，我们使用REFERENCES子句为so_items表定义外键约束。这意味着so_items表中的so_id列引用了so_headers表的id列。</p>
</blockquote>
<blockquote>
<p>定义外键约束的另一种方法是使用表约束，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE so_items (</span><br><span class="line">   item_id INTEGER NOT NULL,</span><br><span class="line">   so_id INTEGER,</span><br><span class="line">   product_id INTEGER,</span><br><span class="line">   qty INTEGER,</span><br><span class="line">   net_price NUMERIC,</span><br><span class="line">   PRIMARY KEY (item_id, so_id),</span><br><span class="line">   FOREIGN KEY (so_id) REFERENCES so_headers (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>因为我们没有为外键约束明确指定名称，所以PostgreSQL使用以下模式分配了名称：table_column_fkey。在我们的示例中，PostgreSQL创建一个外键约束为so_items_so_id_fkey。</li>
</ul>
<ul>
<li>销售订单的每个订单项必须属于一个特定的销售订单。 每个销售订单可以有一个或多个订单项。 这就是所谓的一对多关系。 如果不参考so_items表中的有效so_id，则无法在so_items中插入行。</li>
</ul>
<ul>
<li>如果删除so_headers中的行，那么so_items表中的行会怎样？PostgreSQL为我们提供了以下主要选项：DELETE RESTRICT，DELETE CASCADE和NO ACTION。</li>
</ul>
<blockquote>
<p>PostgreSQL不会删除so_headers表中的行，直到so_items中的所有引用行都被删除。为了实现这一点，当我们定义外键约束时，我们使用ON DELETE RESTRICT表达式:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># drop table so_items;</span></span><br><span class="line">DROP TABLE</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE so_items (</span></span><br><span class="line">  item_id INTEGER NOT NULL,   </span><br><span class="line">  so_id int4 REFERENCES so_headers(id) ON DELETE RESTRICT,</span><br><span class="line">  product_id INTEGER,</span><br><span class="line">  qty INTEGER,</span><br><span class="line">  net_price numeric,</span><br><span class="line">  PRIMARY KEY (item_id,so_id)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PostgreSQL将删除so_items表中所有引用到so_headers表中要删除的行的行。为了指示PostgreSQL执行此操作，我们使用ON DELETE CASCADE如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># drop table so_items;</span></span><br><span class="line">DROP TABLE</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE so_items (</span></span><br><span class="line">  item_id int4 NOT NULL,   </span><br><span class="line">  so_id int4 REFERENCES so_headers(id) ON DELETE CASCADE,</span><br><span class="line">  product_id int4,</span><br><span class="line">  qty int4,</span><br><span class="line">  net_price numeric,</span><br><span class="line">  PRIMARY KEY (item_id,so_id)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果我们未指定RESTRICT或DELETE操作，则PostgreSQL默认将使用NO ACTION。如果使用NO ACTION，则在检查约束时如果引用行仍然存在，则PostgreSQL将引发错误。</p>
</blockquote>
<blockquote>
<p>请注意，删除操作也适用于更新。这意味着您可以具有“ ON UPDATE RESTRICT”，“ ON UPDATE CASCADE”和“ ON UPDATE NO ACTION”。</p>
</blockquote>
<h4 id="将一组列定义为外键"><a href="#将一组列定义为外键" class="headerlink" title="将一组列定义为外键"></a>将一组列定义为外键</h4><blockquote>
<p>如果外键是一组列，则使用以下语法定义外键约束：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE child_table(</span><br><span class="line">  c1 INTEGER PRIMARY KEY,</span><br><span class="line">  c2 INTEGER,</span><br><span class="line">  c3 INTEGER,</span><br><span class="line">  FOREIGN KEY (c2, c3) REFERENCES parent_table (p1, p2)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="将外键约束添加到现有表"><a href="#将外键约束添加到现有表" class="headerlink" title="将外键约束添加到现有表"></a>将外键约束添加到现有表</h4><blockquote>
<p>要将外键约束添加到现有表，请使用ALTER TABLE语句，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE child_table</span><br><span class="line">ADD CONSTRAINT constraint_name FOREIGN KEY (c1) REFERENCES parent_table (p1);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后一点，当您要将带有ON DELETE CASCADE的外键约束添加到现有表时，需要执行以下步骤：</p>
<ul>
<li>删除现有的外键约束。</li>
</ul>
<ul>
<li>使用ON DELETE CASCADE操作添加新的外键约束。</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE child_table</span><br><span class="line">ADD CONSTRAINT constraint_fk</span><br><span class="line">FOREIGN KEY (c1)</span><br><span class="line">REFERENCES parent_table(p1)</span><br><span class="line">ON DELETE CASCADE;</span><br></pre></td></tr></table></figure>
<h3 id="CHECK约束"><a href="#CHECK约束" class="headerlink" title="CHECK约束"></a>CHECK约束</h3><blockquote>
<p>CHECK约束是一种约束，它允许您指定列中的值是否必须满足特定要求。CHECK约束使用布尔表达式在插入或更新到列之前评估值。如果这些值通过检查，则PostgreSQL将在列中插入或更新这些值。</p>
</blockquote>
<h4 id="为新表定义CHECK约束"><a href="#为新表定义CHECK约束" class="headerlink" title="为新表定义CHECK约束"></a>为新表定义CHECK约束</h4><blockquote>
<p>通常，在使用CREATE TABLE语句创建表时会使用CHECK约束。如下定义一个名为test8的表:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE test8 (</span></span><br><span class="line">   id serial PRIMARY KEY,</span><br><span class="line">   first_name VARCHAR (50),</span><br><span class="line">   last_name VARCHAR (50),</span><br><span class="line">   birth_date DATE CHECK (birth_date &gt; <span class="string">'1900-01-01'</span>),</span><br><span class="line">   joined_date DATE CHECK (joined_date &gt; birth_date),</span><br><span class="line">   salary numeric CHECK(salary &gt; 0)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该表具有三个CHECK约束：</p>
<ul>
<li>首先，员工的出生日期（birth_date）必须大于1900-01-01。如果您尝试在1900年1月1日之前插入出生日期，则会收到错误消息。</li>
</ul>
<ul>
<li>其次，加入日期（joined_date）必须大于出生日期（birth_date）。此检查将防止根据其语义更新无效日期。</li>
</ul>
<ul>
<li>第三，工资必须大于零，这很明显。</li>
</ul>
</blockquote>
<blockquote>
<p>尝试向表中插入新行，该语句试图在薪水列中插入负薪水。但是，PostgreSQL返回以下错误消息:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test8 (</span></span><br><span class="line">   first_name,</span><br><span class="line">   last_name,</span><br><span class="line">   birth_date,</span><br><span class="line">   joined_date,</span><br><span class="line">   salary</span><br><span class="line">)</span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'John'</span>,</span><br><span class="line">      <span class="string">'Doe'</span>,</span><br><span class="line">      <span class="string">'1991-01-01'</span>,</span><br><span class="line">      <span class="string">'2012-12-12'</span>,</span><br><span class="line">      - 100000</span><br><span class="line">   );</span><br><span class="line">错误:  关系 <span class="string">"test8"</span> 的新列违反了检查约束 <span class="string">"test8_salary_check"</span></span><br><span class="line">DETAIL:  失败, 行包含(1, John, Doe, 1991-01-01, 2012-12-12, -100000).</span><br></pre></td></tr></table></figure>
<ul>
<li>插入失败，因为在salary列上的CHECK约束仅接受正值。</li>
</ul>
<blockquote>
<p>默认情况下，PostgreSQL使用以下模式为CHECK约束命名：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;table&#125;_&#123;column&#125;_check</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如，salary列上的约束具有以下约束名称：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test8_salary_check</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是，如果要为CHECK约束分配特定名称，则可以在CONSTRAINT表达式后指定它，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column_name data_type CONSTRAINT constraint_name CHECK(...)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请参见以下示例：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">salary numeric CONSTRAINT positive_salary CHECK(salary &gt; 0)</span><br></pre></td></tr></table></figure>
<h4 id="为现有表定义CHECK约束"><a href="#为现有表定义CHECK约束" class="headerlink" title="为现有表定义CHECK约束"></a>为现有表定义CHECK约束</h4><blockquote>
<p>要将CHECK约束添加到现有表，请使用以下ALTER TABLE语句。假设数据库中已有一个名为 prices_list的表。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE prices_list (</span></span><br><span class="line">   id serial PRIMARY KEY,</span><br><span class="line">   product_id INT NOT NULL,</span><br><span class="line">   price NUMERIC NOT NULL,</span><br><span class="line">   discount NUMERIC NOT NULL,</span><br><span class="line">   valid_from DATE NOT NULL,</span><br><span class="line">   valid_to DATE NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在，使用ALTER TABLE语句将CHECK约束添加到prices_list表中。价格和折扣必须大于零，且折扣小于价格。注意，我们使用包含AND运算符的布尔表达式:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE prices_list ADD CONSTRAINT price_discount_check CHECK (</span></span><br><span class="line">   price &gt; 0</span><br><span class="line">   AND discount &gt;= 0</span><br><span class="line">   AND price &gt; discount</span><br><span class="line">);</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有效日期(valid_to)必须大于或等于有效日期(valid_from)。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE prices_list</span></span><br><span class="line">ADD CONSTRAINT valid_range_check CHECK (valid_to &gt;= valid_from);</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CHECK约束对于放置附加逻辑来限制列可以在数据库层接受的值非常有用。通过使用CHECK约束，可以确保将数据正确更新到数据库。</p>
</blockquote>
<h3 id="UNIQUE约束"><a href="#UNIQUE约束" class="headerlink" title="UNIQUE约束"></a>UNIQUE约束</h3><blockquote>
<p>UNIQUE约束确保存储在一个或一组列中的值在整个表中是唯一的。</p>
</blockquote>
<blockquote>
<p>使用UNIQUE约束，每次您插入新行时，PostgreSQL都会检查该值是否已在表中。如果发现新值已经存在，则拒绝更改并发出错误。进行相同的过程以更新现有数据。</p>
</blockquote>
<blockquote>
<p>当您向一列或一组列添加UNIQUE约束时，PostgreSQL将在相应的列或一组列上自动创建唯一索引。</p>
</blockquote>
<h4 id="UNIQUE约束示例"><a href="#UNIQUE约束示例" class="headerlink" title="UNIQUE约束示例"></a>UNIQUE约束示例</h4><blockquote>
<p>以下语句创建一个名为person的新表，该表对email列具有UNIQUE约束:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE person (</span></span><br><span class="line">   id serial PRIMARY KEY,</span><br><span class="line">   name VARCHAR (50),</span><br><span class="line">   email VARCHAR (50) UNIQUE</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，上面的UNIQUE约束可以重写为表约束，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># drop table person;</span></span><br><span class="line">DROP TABLE</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE person (</span></span><br><span class="line">   id SERIAL  PRIMARY KEY,</span><br><span class="line">   name VARCHAR (50),</span><br><span class="line">   email      VARCHAR (50),</span><br><span class="line">   UNIQUE(email)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先，我们使用INSERT语句在person表中插入新行：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO person(name,email)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'zhi'</span>,</span><br><span class="line">      <span class="string">'zhi@pg.com'</span></span><br><span class="line">   );</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其次，我们在另一行插入重复的电子邮件，PostgreSQL发出了错误消息:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO person(name,email)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'zhian'</span>,</span><br><span class="line">      <span class="string">'zhi@pg.com'</span></span><br><span class="line">   );</span><br><span class="line">错误:  重复键违反唯一约束<span class="string">"person_email_key"</span></span><br><span class="line">DETAIL:  键值<span class="string">"(email)=(zhi@pg.com)"</span> 已经存在</span><br></pre></td></tr></table></figure>
<h4 id="在多列上创建约束"><a href="#在多列上创建约束" class="headerlink" title="在多列上创建约束"></a>在多列上创建约束</h4><blockquote>
<p>使用以下语法为一组列创建UNIQUE约束：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table (</span><br><span class="line">    c1 data_type,</span><br><span class="line">    c2 data_type,</span><br><span class="line">    c3 data_type,</span><br><span class="line">    UNIQUE (c2, c3)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>在整个表中，列c2和c3中值的组合将是唯一的。列c2或c3的值不必唯一。</li>
</ul>
<h4 id="使用唯一索引添加唯一约束"><a href="#使用唯一索引添加唯一约束" class="headerlink" title="使用唯一索引添加唯一约束"></a>使用唯一索引添加唯一约束</h4><blockquote>
<p>向现有列或一组列添加唯一约束。</p>
</blockquote>
<blockquote>
<p>首先，假设有一个名为equipment的表：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE equipment (</span></span><br><span class="line">   id serial PRIMARY KEY,</span><br><span class="line">   name VARCHAR (50) NOT NULL,</span><br><span class="line">   equip_id VARCHAR (16) NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其次，基于equip_id列创建唯一索引。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE UNIQUE INDEX CONCURRENTLY equipment_equip_id</span></span><br><span class="line">ON equipment (equip_id);</span><br><span class="line">CREATE INDEX</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三，使用equipment_equip_id索引向设备表添加唯一约束。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE equipment</span></span><br><span class="line">ADD CONSTRAINT unique_equip_id</span><br><span class="line">UNIQUE USING INDEX equipment_equip_id;</span><br><span class="line">注意:  ALTER TABLE / ADD CONSTRAINT USING INDEX 会把索引 <span class="string">"equipment_equip_id"</span> 重命名为 <span class="string">"unique_equip_id"</span></span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，ALTER TABLE语句获取表的排他锁。如果有任何待处理的事务，它将在更改表之前等待所有事务完成。因此，应该使用以下查询检查pg_stat_activity表以查看当前正在进行的未决事务：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   datid,</span><br><span class="line">   datname,</span><br><span class="line">        usename,</span><br><span class="line">   state</span><br><span class="line">FROM</span><br><span class="line">   pg_stat_activity;</span><br><span class="line"> datid | datname | usename  | state</span><br><span class="line">-------+---------+----------+--------</span><br><span class="line">       |         |          |</span><br><span class="line">       |         | postgres |</span><br><span class="line"> 17043 | <span class="built_in">test</span>    | <span class="built_in">test</span>     | active</span><br><span class="line">       |         |          |</span><br><span class="line">       |         |          |</span><br><span class="line">       |         |          |</span><br><span class="line">(6 rows)</span><br></pre></td></tr></table></figure>
<h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><blockquote>
<p>在数据库理论中，NULL是未知或丢失的信息。NULL值不同于空字符串或数字零。</p>
</blockquote>
<blockquote>
<p>NULL值非常特殊。例如，NULL甚至不等于NULL。要检查值是否为NULL，请使用布尔运算符IS NULL或IS NOT NULL。该表达式NULL = NULL返回NULL。</p>
</blockquote>
<blockquote>
<p>PostgreSQL提供了非空约束来强制列不能接受NULL值。这意味着无论何时插入或更新数据，都必须指定一个与NULL值不同的值。</p>
</blockquote>
<h4 id="创建新表时将非空约束添加到列"><a href="#创建新表时将非空约束添加到列" class="headerlink" title="创建新表时将非空约束添加到列"></a>创建新表时将非空约束添加到列</h4><blockquote>
<p>CREATE TABLE语句创建一个具有非空约束的新表名invoice:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE invoice(</span></span><br><span class="line">  id serial PRIMARY KEY,</span><br><span class="line">  product_id int NOT NULL,</span><br><span class="line">  qty numeric NOT NULL CHECK(qty &gt; 0),</span><br><span class="line">  net_price numeric CHECK(net_price &gt; 0)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<ul>
<li>这里使用了NOT NULL，后跟该列的数据类型来声明not-null约束。在这种情况下，它是列约束。</li>
</ul>
<blockquote>
<p>请注意，一列可以具有多个约束，例如，not-null、check、unique、foreign key彼此相邻出现。顺序并不重要，因此PostgreSQL可以按任何顺序检查列表中的任何空约束。</p>
</blockquote>
<blockquote>
<p>如果使用NULL而不是NOT NULL，则该列将同时接受null和非null值。如果不同时使用NOT NULL和NULL，则PostgreSQL默认使用NULL。</p>
</blockquote>
<h4 id="将非空约束添加到现有表的列中"><a href="#将非空约束添加到现有表的列中" class="headerlink" title="将非空约束添加到现有表的列中"></a>将非空约束添加到现有表的列中</h4><blockquote>
<p>要将非空约束添加到现有表的列，请使用ALTER TABLE语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER  TABLE table_name</span><br><span class="line">ALTER COLUMN column_name SET NOT NULL;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要将非空约束添加到现有表的多个列，请使用以下语法：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER  TABLE table_name</span><br><span class="line">ALTER COLUMN column_name_1 SET NOT NULL,</span><br><span class="line">ALTER COLUMN column_name_2 SET NOT NULL;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先，创建一个名为production_orders的新表：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE production_orders (</span></span><br><span class="line">   ID serial PRIMARY KEY,</span><br><span class="line">   description VARCHAR (40) NOT NULL,</span><br><span class="line">   material_id VARCHAR (16),</span><br><span class="line">   qty NUMERIC,</span><br><span class="line">   start_date DATE,</span><br><span class="line">   finish_date DATE</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接下来，在production_orders表中插入新行：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO production_orders (description)</span></span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'fly'</span>);</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后，如果要确保qty字段不为null，以便将not-null约束添加到qty列。但是，该表中已经有数据。如果尝试添加非空约束，则PostgreSQL将发出错误消息:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE production_orders ALTER COLUMN qty</span></span><br><span class="line">SET NOT NULL;</span><br><span class="line">错误:  字段 <span class="string">"qty"</span> 包含空值</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因此，需要在添加非空约束之前先更新数据。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE production_orders</span></span><br><span class="line">SET qty = 1;</span><br><span class="line">UPDATE 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在就可以添加非空约束了。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE production_orders ALTER COLUMN qty</span></span><br><span class="line">SET NOT NULL;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>之后，可以更新material_id，start_date和finish_date列的非空约束：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE production_orders</span></span><br><span class="line">SET material_id = <span class="string">'ABC'</span>,</span><br><span class="line">    start_date = <span class="string">'2018-08-08'</span>,</span><br><span class="line">    finish_date = <span class="string">'2019-09-09'</span>;</span><br><span class="line">UPDATE 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>向多个列添加非空约束：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE production_orders</span></span><br><span class="line">ALTER COLUMN material_id SET NOT NULL,</span><br><span class="line">ALTER COLUMN start_date SET NOT NULL,</span><br><span class="line">ALTER COLUMN finish_date SET NOT NULL;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后，尝试打破非空约束，PostgreSQL发出错误消息：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE production_orders</span></span><br><span class="line">SET qty = NULL;</span><br><span class="line">错误:  在字段 <span class="string">"qty"</span> 中空值违反了非空约束</span><br><span class="line">DETAIL:  失败, 行包含(1, fly, ABC, null, 2018-08-08, 2019-09-09).</span><br></pre></td></tr></table></figure>
<h4 id="非空约束的特殊情况"><a href="#非空约束的特殊情况" class="headerlink" title="非空约束的特殊情况"></a>非空约束的特殊情况</h4><blockquote>
<p>使用检查约束来表示非空约束。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NOT NULL</span><br></pre></td></tr></table></figure>
<blockquote>
<p>相当于</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHECK(column IS NOT NULL)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这很有用，有时您可能希望a列或b列都不为空，但不能同时包含两者。例如，在users表中，您希望username或email列不为null或为空，则可以使用检查约束，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE users (</span></span><br><span class="line">ID serial PRIMARY KEY,</span><br><span class="line">username VARCHAR (50),</span><br><span class="line">PASSWORD VARCHAR (50),</span><br><span class="line">email VARCHAR (50),</span><br><span class="line">CONSTRAINT username_email_notnull CHECK (</span><br><span class="line">   NOT (</span><br><span class="line">     ( username IS NULL  OR  username = <span class="string">''</span> )</span><br><span class="line">     AND</span><br><span class="line">     ( email IS NULL  OR  email = <span class="string">''</span> )</span><br><span class="line">   )</span><br><span class="line">)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下插入语句有效:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO users (username, email)</span></span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'user1'</span>, NULL),</span><br><span class="line">   (NULL, <span class="string">'email1@example.com'</span>),</span><br><span class="line">   (<span class="string">'user2'</span>, <span class="string">'email2@example.com'</span>),</span><br><span class="line">   (<span class="string">'user3'</span>, <span class="string">''</span>);</span><br><span class="line">INSERT 0 4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是，如下由于违反了NOT NULL约束，因此此方法将不起作用：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO users (username, email)</span></span><br><span class="line">VALUES</span><br><span class="line">   (NULL, NULL),</span><br><span class="line">   (NULL, <span class="string">''</span>),</span><br><span class="line">   (<span class="string">''</span>, NULL),</span><br><span class="line">   (<span class="string">''</span>, <span class="string">''</span>);</span><br><span class="line">错误:  关系 <span class="string">"users"</span> 的新列违反了检查约束 <span class="string">"username_email_notnull"</span></span><br><span class="line">DETAIL:  失败, 行包含(5, null, null, null).</span><br></pre></td></tr></table></figure>
<h2 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h2><h3 id="布尔数据类型"><a href="#布尔数据类型" class="headerlink" title="布尔数据类型"></a>布尔数据类型</h3><blockquote>
<p>PostgreSQL支持单个布尔数据类型：BOOLEAN，它可以具有三种状态：TRUE，FALSE和NULL。 PostgreSQL使用一个字节在数据库中存储一个布尔值。BOOLEAN可以缩写为BOOL。</p>
</blockquote>
<blockquote>
<p>在标准SQL中，布尔值可以为TRUE，FALSE或NULL。但是，PostgreSQL在处理TRUE和FALSE值时非常灵活。下表显示了PostgreSQL中TRUE和FALSE的有效文字值:</p>
</blockquote>
<table>
<thead>
<tr>
<th>True</th>
<th>False</th>
</tr>
</thead>
<tbody>
<tr>
<td>  true</td>
<td>false</td>
</tr>
<tr>
<td>  ‘t’</td>
<td>‘f’</td>
</tr>
<tr>
<td> ‘true’</td>
<td>‘false’</td>
</tr>
<tr>
<td>  ‘y’</td>
<td>‘n’</td>
</tr>
<tr>
<td>  ‘yes’</td>
<td>‘no’</td>
</tr>
<tr>
<td>  ‘1’</td>
<td>‘0’</td>
</tr>
</tbody>
</table>
<blockquote>
<p>请注意，前导或尾随空格并不重要，除true和false以外的所有常量值都必须用单引号引起来。</p>
</blockquote>
<h4 id="布尔示例"><a href="#布尔示例" class="headerlink" title="布尔示例"></a>布尔示例</h4><blockquote>
<p>创建一个新表test9以记录哪些产品可用:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE test9 (</span></span><br><span class="line">   product_id INT NOT NULL PRIMARY KEY,</span><br><span class="line">   available BOOLEAN NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将一些数据插入到表中。我们将各种文字值用作布尔值。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test9 (product_id, available)</span></span><br><span class="line">VALUES</span><br><span class="line">   (100, TRUE),</span><br><span class="line">   (200, FALSE),</span><br><span class="line">   (300, <span class="string">'t'</span>),</span><br><span class="line">   (400, <span class="string">'1'</span>),</span><br><span class="line">   (500, <span class="string">'y'</span>),</span><br><span class="line">   (600, <span class="string">'yes'</span>),</span><br><span class="line">   (700, <span class="string">'no'</span>),</span><br><span class="line">   (800, <span class="string">'0'</span>);</span><br><span class="line">INSERT 0 8</span><br></pre></td></tr></table></figure>
<blockquote>
<p>进行检查</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   test9</span><br><span class="line">WHERE</span><br><span class="line">   available = <span class="string">'yes'</span>;</span><br><span class="line"> product_id | available</span><br><span class="line">------------+-----------</span><br><span class="line">        100 | t</span><br><span class="line">        300 | t</span><br><span class="line">        400 | t</span><br><span class="line">        500 | t</span><br><span class="line">        600 | t</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以使用不带任何运算符的布尔值列来隐含真值</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   test9</span><br><span class="line">WHERE</span><br><span class="line">   available;</span><br><span class="line"> product_id | available</span><br><span class="line">------------+-----------</span><br><span class="line">        100 | t</span><br><span class="line">        300 | t</span><br><span class="line">        400 | t</span><br><span class="line">        500 | t</span><br><span class="line">        600 | t</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同样，如果要查找错误的值，可以将布尔列的值与任何有效的布尔常量进行比较</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   test9</span><br><span class="line">WHERE</span><br><span class="line">   available = <span class="string">'no'</span>;</span><br><span class="line"> product_id | available</span><br><span class="line">------------+-----------</span><br><span class="line">        200 | f</span><br><span class="line">        700 | f</span><br><span class="line">        800 | f</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者，可以使用NOT运算符来检查Boolean列中的值是否为false</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   test9</span><br><span class="line">WHERE</span><br><span class="line">   NOT available;</span><br><span class="line"> product_id | available</span><br><span class="line">------------+-----------</span><br><span class="line">        200 | f</span><br><span class="line">        700 | f</span><br><span class="line">        800 | f</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<h4 id="设置布尔值列的默认值"><a href="#设置布尔值列的默认值" class="headerlink" title="设置布尔值列的默认值"></a>设置布尔值列的默认值</h4><blockquote>
<p>要为现有的布尔列设置默认值，请在ALTER TABLE语句中使用SET DEFAULT子句。</p>
</blockquote>
<blockquote>
<p>例如，以下ALTER TABLE语句为test9表中的可用列设置默认值：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE test9 ALTER COLUMN available</span></span><br><span class="line">SET DEFAULT FALSE;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果在未指定可用列的值的情况下插入行，则PostgreSQL默认使用FALSE值。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test9 (product_id)</span></span><br><span class="line">VALUES</span><br><span class="line">   (900);</span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   test9</span><br><span class="line">WHERE</span><br><span class="line">   product_id = 900;</span><br><span class="line"> product_id | available</span><br><span class="line">------------+-----------</span><br><span class="line">        900 | f</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同样，如果要在创建表时为布尔列设置默认值，则可以在列定义中使用DEFAULT子句，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE boolean_demo(</span><br><span class="line">   ...</span><br><span class="line">   is_ok BOOL DEFAULT <span class="string">'t'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="CHAR，VARCHAR和TEXT字符类型"><a href="#CHAR，VARCHAR和TEXT字符类型" class="headerlink" title="CHAR，VARCHAR和TEXT字符类型"></a>CHAR，VARCHAR和TEXT字符类型</h3><blockquote>
<p>PostgreSQL提供三种主要的字符类型:character(n)或char(n), character varying(n)或varchar(n), 以及text，其中n是一个正整数。</p>
</blockquote>
<table>
<thead>
<tr>
<th>角色类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>character varying(n), varchar(n)</td>
<td>有限制的可变长度</td>
</tr>
<tr>
<td>character(n), char(n)</td>
<td>定长，空白填充</td>
</tr>
<tr>
<td>text, varchar</td>
<td>可变的无限长度</td>
</tr>
</tbody>
</table>
<blockquote>
<p>char(n)和varchar(n)最多可以存储n个字符。如果尝试将更长的字符串存储在char(n)或varchar(n)列中，则PostgreSQL将发出错误消息。</p>
</blockquote>
<blockquote>
<p>但是，一个例外是，如果多余的字符都是空格，则PostgreSQL会将空格截断为最大长度并存储字符串。</p>
</blockquote>
<blockquote>
<p>如果字符串明确地转换为char(n)或varchar(n)，则PostgresQL将在插入表之前将字符串截断为n个字符。</p>
</blockquote>
<blockquote>
<p>文本数据类型可以存储长度不受限制的字符串。</p>
</blockquote>
<blockquote>
<p>如果未为varchar数据类型指定n整数，则其行为类似于text数据类型。varchar(无n)和文本的性能相同。</p>
</blockquote>
<blockquote>
<p>为varchar数据类型指定长度说明符的唯一好处是，如果尝试在varchar(n)列中插入更长的字符串，PostgreSQL将检查并发出错误。</p>
</blockquote>
<blockquote>
<p>与varchar不同，没有长度说明符的字符或char与character(1)或char(1)相同。</p>
</blockquote>
<blockquote>
<p>与其他数据库系统不同，在PostgreSQL中，三种字符类型之间没有性能差异。在大多数情况下，如果希望PostgreSQL检查长度限制，则应使用text或varchar和varchar(n)。</p>
</blockquote>
<h4 id="字符类型示例"><a href="#字符类型示例" class="headerlink" title="字符类型示例"></a>字符类型示例</h4><blockquote>
<p>创建列表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE test10 (</span></span><br><span class="line">   id serial PRIMARY KEY,</span><br><span class="line">   x CHAR (1),</span><br><span class="line">   y VARCHAR (10),</span><br><span class="line">   z TEXT</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在表中插入新行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test10 (x, y, z)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'Yes'</span>,</span><br><span class="line">      <span class="string">'This is a test for varchar'</span>,</span><br><span class="line">      <span class="string">'This is a very long text for the PostgreSQL text column'</span></span><br><span class="line">   );</span><br><span class="line">错误:  对于字符类型来说这个值太长了(1)</span><br></pre></td></tr></table></figure>
<ul>
<li>这是因为x列的数据类型为char(1)，我们试图在此列中插入一个包含三个字符的字符串。</li>
</ul>
<blockquote>
<p>修复该列</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test10 (x, y, z)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'Y'</span>,</span><br><span class="line">      <span class="string">'This is a test for varchar'</span>,</span><br><span class="line">      <span class="string">'This is a very long text for the PostgreSQL text column'</span></span><br><span class="line">   );</span><br><span class="line">错误:  对于可变字符类型来说，值太长了(10)</span><br></pre></td></tr></table></figure>
<ul>
<li>这里我们试图在y列中插入长度超过10个字符的字符串但是数据类型为VARCHAR (10)。</li>
</ul>
<blockquote>
<p>修复该行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test10 (x, y, z)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'Y'</span>,</span><br><span class="line">      <span class="string">'varchar'</span>,</span><br><span class="line">      <span class="string">'This is a very long text for the PostgreSQL text column'</span></span><br><span class="line">   );</span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT * FROM test10;</span></span><br><span class="line"> id | x |    y    |                            z</span><br><span class="line">----+---+---------+---------------------------------------------------------</span><br><span class="line">  1 | Y | varchar | This is a very long text <span class="keyword">for</span> the PostgreSQL text column</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>大多数时候，应该选择不带长度说明符的text或varchar类型。</p>
</blockquote>
<h3 id="NUMERIC数据类型"><a href="#NUMERIC数据类型" class="headerlink" title="NUMERIC数据类型"></a>NUMERIC数据类型</h3><blockquote>
<p>NUMERIC类型可以存储许多位数的数字。通常，对于需要精确度的货币或其他金额，请使用NUMERIC类型。</p>
</blockquote>
<h4 id="NUMERIC语法"><a href="#NUMERIC语法" class="headerlink" title="NUMERIC语法"></a>NUMERIC语法</h4><blockquote>
<p>要声明NUMERIC类型的列，请使用以下语法：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NUMERIC(precision, scale)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>精度是位数的总和，小数位数是小数部分的位数。例如，数字1234.567的精度为7，小数位数为3。</p>
</blockquote>
<blockquote>
<p>NUMERIC值最多可在小数点前131072位，在小数点后16383位。</p>
</blockquote>
<blockquote>
<p>NUMERIC类型的小数位数可以为零或正，以下语法定义了小数位数为零的NUMERIC列：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NUMERIC(precision)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果同时忽略精度和小数位数，则可以存储任何精度和小数位数，直到达到上述精度和小数位数的极限。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NUMERIC</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在PostgreSQL中，NUMERIC和DECIMAL类型是等效的，并且它们也是SQL标准的一部分。</p>
</blockquote>
<blockquote>
<p>如果不需要精度，则不应使用该NUMERIC类型，因为对NUMERIC值的计算要比integers，float和double precision 慢。</p>
</blockquote>
<h4 id="NUMERIC示例"><a href="#NUMERIC示例" class="headerlink" title="NUMERIC示例"></a>NUMERIC示例</h4><blockquote>
<p>如果存储的小数位数大于声明的NUMERIC列的小数位数，PostgreSQL将把该值四舍五入到指定的小数位数。</p>
</blockquote>
<blockquote>
<p>创建一个新表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE IF NOT EXISTS test11 (</span></span><br><span class="line">    id serial PRIMARY KEY,</span><br><span class="line">    name VARCHAR NOT NULL,</span><br><span class="line">    price NUMERIC (5, 2)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>插入价格超出price列中声明的价格范围的某些产品</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test11 (NAME, price)</span></span><br><span class="line">VALUES</span><br><span class="line">    (<span class="string">'Phone'</span>,500.215),</span><br><span class="line">    (<span class="string">'Tablet'</span>,500.214);</span><br><span class="line">INSERT 0 2</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    test11;</span><br><span class="line"> id |  name  | price</span><br><span class="line">----+--------+--------</span><br><span class="line">  1 | Phone  | 500.22</span><br><span class="line">  2 | Tablet | 500.21</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为该price列的小数位数为2，所以PostgreSQL将值四舍五入500.215到500.22，四舍五入500.214到500.21</p>
</blockquote>
<blockquote>
<p>如果存储的值的精度超过声明的精度，则PostgreSQL将引发错误，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test11 (name, price)</span></span><br><span class="line">VALUES</span><br><span class="line">    (<span class="string">'Phone'</span>,123456.21);</span><br><span class="line">错误:  数字字段溢出</span><br><span class="line">DETAIL:  精度为5,范围是2的字段必须四舍五入到小于10^3的绝对值.</span><br></pre></td></tr></table></figure>
<h4 id="NUMERIC和NaN"><a href="#NUMERIC和NaN" class="headerlink" title="NUMERIC和NaN"></a>NUMERIC和NaN</h4><blockquote>
<p>除了存储数值外，该NUMERIC列还可以存储称为not-a-number或NaN的特殊值。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE test11</span></span><br><span class="line">SET price = <span class="string">'NaN'</span></span><br><span class="line">WHERE</span><br><span class="line">    id = 1;</span><br><span class="line">UPDATE 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此示例中，我们将id为1的产品的价格更新为NaN。请注意，您必须使用引号将NaN括起来。</p>
</blockquote>
<blockquote>
<p>通常，NaN不等于任何数字，包括自身。这意味着表达式NaN = NaN返回false。但是，PostgreSQL将NaN值视为相等并且NaN大于任何非NaN值。此实现允许PostgreSQL对NUMERIC值进行排序并在基于树的索引中使用它们。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    test11</span><br><span class="line">ORDER BY</span><br><span class="line">    price DESC;</span><br><span class="line"> id |  name  | price</span><br><span class="line">----+--------+--------</span><br><span class="line">  1 | Phone  |    NaN</span><br><span class="line">  2 | Tablet | 500.21</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如上，NaN大于500.21。</p>
</blockquote>
<h3 id="整数数据类型"><a href="#整数数据类型" class="headerlink" title="整数数据类型"></a>整数数据类型</h3><blockquote>
<p>要存储PostgreSQL的全数字，使用以下的整数类型之一：SMALLINT，INTEGER，和BIGINT。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">名字</th>
<th style="text-align:center">储存空间</th>
<th style="text-align:center">Min</th>
<th style="text-align:right">Max</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SMALLINT</td>
<td style="text-align:center">2 bytes</td>
<td style="text-align:center">-32,768</td>
<td style="text-align:right">+32,767</td>
</tr>
<tr>
<td style="text-align:left">INTEGER</td>
<td style="text-align:center">4 bytes</td>
<td style="text-align:center">-2,147,483,648</td>
<td style="text-align:right">+2,147,483,647</td>
</tr>
<tr>
<td style="text-align:left">BIGINT</td>
<td style="text-align:center">8 bytes</td>
<td style="text-align:center">-9,223,372,036,854,775,808</td>
<td style="text-align:right">+9,223,372,036,854,775,807</td>
</tr>
</tbody>
</table>
<blockquote>
<p>如果存储超出允许范围的值，PostgreSQL将发出错误。</p>
</blockquote>
<blockquote>
<p>与MySQL integer不同，PostgreSQL不提供无符号整数类型。</p>
</blockquote>
<h4 id="SMALLINT"><a href="#SMALLINT" class="headerlink" title="SMALLINT"></a>SMALLINT</h4><blockquote>
<p>SMALLINT需要2字节的存储大小，可以存储（-32,767，32,767）范围内的任何整数。可以使用SMALLINT类型存储诸如人们的年龄，一本书的页数等之类的信息。</p>
</blockquote>
<blockquote>
<p>以下语句创建一个名为book的表:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE book (</span></span><br><span class="line">    book_id SERIAL PRIMARY KEY,</span><br><span class="line">    title VARCHAR (255) NOT NULL,</span><br><span class="line">    pages SMALLINT NOT NULL CHECK (pages &gt; 0)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此示例中，该pages列是SMALLINT列。因为一本书的页数必须为正，所以我们添加了一个CHECK约束来强制执行此规则。</p>
</blockquote>
<h4 id="INTEGER"><a href="#INTEGER" class="headerlink" title="INTEGER"></a>INTEGER</h4><blockquote>
<p>INTEGER是整数类型之间最常见的选择，因为它在存储大小，范围和性能之间提供了最佳的平衡。</p>
</blockquote>
<blockquote>
<p>INTEGER类型需要4个字节的存储大小，可以存储（-2,147,483,648，2,147,483,647）范围内的数字。</p>
</blockquote>
<blockquote>
<p>可以将INTEGER类型用于存储相当大的整数（例如城市或国家/地区的人口）的列，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE cities (</span></span><br><span class="line">    city_id serial PRIMARY KEY,</span><br><span class="line">    city_name VARCHAR (255) NOT NULL,</span><br><span class="line">    population INT NOT NULL CHECK (population &gt;= 0)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，INT是INTEGER的同义词。</p>
</blockquote>
<h4 id="BIGINT"><a href="#BIGINT" class="headerlink" title="BIGINT"></a>BIGINT</h4><blockquote>
<p>如果要存储超出INTEGER类型范围的整数，则可以使用BIGINT类型。</p>
</blockquote>
<blockquote>
<p>BIGINT类型需要8个字节的存储大小，该大小可以存储（-9,223,372,036,854,775,808，+ 9,223,372,036,854,775,807）范围内的任何数字。</p>
</blockquote>
<blockquote>
<p>使用BIGINT类型不仅会占用大量存储空间，而且还会降低数据库的性能，因此，您应该有充分的理由再使用它。</p>
</blockquote>
<h3 id="DATE数据类型"><a href="#DATE数据类型" class="headerlink" title="DATE数据类型"></a>DATE数据类型</h3><blockquote>
<p>要存储日期值，请使用PostgreSQL DATE数据类型。PostgreSQL使用4个字节来存储日期值。 DATE数据类型的最低和最高值为4713 BC和5874897 AD。</p>
</blockquote>
<blockquote>
<p>在存储日期值时，PostgreSQL使用yyyy-mm-dd格式，例如2012-12-12。它还使用此格式将数据插入日期列。</p>
</blockquote>
<blockquote>
<p>如果创建的表具有DATE列，并且希望将当前日期用作该列的默认值，则可以在DEFAULT关键字后使用CURRENT_DATE。</p>
</blockquote>
<blockquote>
<p>例如，以下语句创建documents表，该表posting_date列具有DATE数据类型。posting_date列接受当前日期作为默认值:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE cities (</span></span><br><span class="line">    city_id serial PRIMARY KEY,</span><br><span class="line">    city_name VARCHAR (255) NOT NULL,</span><br><span class="line">    population INT NOT NULL CHECK (population &gt;= 0)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE documents (</span></span><br><span class="line">   document_id serial PRIMARY KEY,</span><br><span class="line">   header_text VARCHAR (255) NOT NULL,</span><br><span class="line">   posting_date DATE NOT NULL DEFAULT CURRENT_DATE</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">INSERT INTO documents (header_text)</span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'Billing to customer XYZ'</span>);</span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   documents;</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line"> document_id |       header_text       | posting_date</span><br><span class="line">-------------+-------------------------+--------------</span><br><span class="line">           1 | Billing to customer XYZ | 2019-11-30</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="DATE函数"><a href="#DATE函数" class="headerlink" title="DATE函数"></a>DATE函数</h4><blockquote>
<p>创建一个名为的test12表，该表由test_id，name，birth_date和hire_date列组成，其中birate_date和hire_date列的数据类型为DATE。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE test12 (</span></span><br><span class="line">   test_id serial PRIMARY KEY,</span><br><span class="line">   name VARCHAR (355),</span><br><span class="line">   birth_date DATE NOT NULL,</span><br><span class="line">   hire_date DATE NOT NULL</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">INSERT INTO test12 (name, birth_date, hire_date)</span><br><span class="line">VALUES (<span class="string">'Shannon'</span>,<span class="string">'2001-01-01'</span>,<span class="string">'2012-12-12'</span>),</span><br><span class="line">      (<span class="string">'Sheila'</span>,<span class="string">'1988-08-08'</span>,<span class="string">'2008-08-08'</span>),</span><br><span class="line">      (<span class="string">'Ethel'</span>,<span class="string">'1995-05-05'</span>,<span class="string">'2005-05-05'</span>);</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line">INSERT 0 3</span><br></pre></td></tr></table></figure>
<h4 id="获取当前日期"><a href="#获取当前日期" class="headerlink" title="获取当前日期"></a>获取当前日期</h4><blockquote>
<p>要获取当前日期和时间，请使用内置NOW()功能。但是，仅获取日期部分(不包括时间部分)，可以使用双冒号(::)将DATETIME值转换为DATE值。</p>
</blockquote>
<blockquote>
<p>获取数据库服务器的当前日期</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT NOW()::date;</span></span><br><span class="line">    now</span><br><span class="line">------------</span><br><span class="line"> 2019-11-30</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用CURRENT_DATE获取当前日期</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT CURRENT_DATE;</span></span><br><span class="line"> current_date</span><br><span class="line">--------------</span><br><span class="line"> 2019-11-30</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="以特定格式输出日期值"><a href="#以特定格式输出日期值" class="headerlink" title="以特定格式输出日期值"></a>以特定格式输出日期值</h4><blockquote>
<p>要以特定格式输出日期值，请使用TO_CHAR()功能。TO_CHAR()函数接受两个参数。第一个参数是要设置格式的值，第二个参数是定义输出格式的模板。</p>
</blockquote>
<blockquote>
<p>以dd/mm/yyyy格式显示当前日期:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT TO_CHAR(NOW() :: DATE, 'dd/mm/yyyy');</span></span><br><span class="line">  to_char</span><br><span class="line">------------</span><br><span class="line"> 30/11/2019</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或以类似于Dec 12,2012的格式显示日期</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT TO_CHAR(NOW() :: DATE, 'Mon dd, yyyy');</span></span><br><span class="line">   to_char</span><br><span class="line">--------------</span><br><span class="line"> Nov 30, 2019</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="获取两个日期之间的间隔"><a href="#获取两个日期之间的间隔" class="headerlink" title="获取两个日期之间的间隔"></a>获取两个日期之间的间隔</h4><blockquote>
<p>要获取两个日期之间的间隔，请使用减号（-）运算符。 </p>
</blockquote>
<blockquote>
<p>例如，要获取员工的工作天数，可以使用当前时间减去hire_date列中的值进行查询：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   name,</span><br><span class="line">   now() - hire_date as diff</span><br><span class="line">FROM</span><br><span class="line">   test12;</span><br><span class="line">  name   |           diff</span><br><span class="line">---------+---------------------------</span><br><span class="line"> Shannon | 2545 days 00:02:49.320311</span><br><span class="line"> Sheila  | 4132 days 00:02:49.320311</span><br><span class="line"> Ethel   | 5323 days 00:02:49.320311</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<h4 id="计算年、月和日的年龄"><a href="#计算年、月和日的年龄" class="headerlink" title="计算年、月和日的年龄"></a>计算年、月和日的年龄</h4><blockquote>
<p>要使用年、月和日来计算当前日期的年龄，请使用该AGE()函数。以下语句使用AGE()函数计算test12表中员工的年龄:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   test_id,</span><br><span class="line">   name,</span><br><span class="line">   AGE(birth_date)</span><br><span class="line">FROM</span><br><span class="line">   test12;</span><br><span class="line"> test_id |  name   |           age</span><br><span class="line">---------+---------+-------------------------</span><br><span class="line">       1 | Shannon | 18 years 11 mons</span><br><span class="line">       2 | Sheila  | 31 years 3 mons 24 days</span><br><span class="line">       3 | Ethel   | 24 years 6 mons 27 days</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果将日期值传递给AGE()函数，它将从当前日期中减去该日期值。如果将两个参数传递给AGE()函数，它将从第一个参数中减去第二个参数。</p>
</blockquote>
<blockquote>
<p>例如，要获取2012年12月12日的员工年龄，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   test_id,</span><br><span class="line">   name,</span><br><span class="line">   AGE(<span class="string">'2012-12-12'</span>,birth_date)</span><br><span class="line">FROM</span><br><span class="line">   test12;</span><br><span class="line"> test_id |  name   |           age</span><br><span class="line">---------+---------+--------------------------</span><br><span class="line">       1 | Shannon | 11 years 11 mons 11 days</span><br><span class="line">       2 | Sheila  | 24 years 4 mons 4 days</span><br><span class="line">       3 | Ethel   | 17 years 7 mons 7 days</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<h4 id="从日期值中提取年、季度、月、周、日"><a href="#从日期值中提取年、季度、月、周、日" class="headerlink" title="从日期值中提取年、季度、月、周、日"></a>从日期值中提取年、季度、月、周、日</h4><blockquote>
<p>要从日期值中获取日期值中的年，季度，月，周，日，请使用此EXTRACT()函数。以下语句将雇员的出生日期提取为年，月和日：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   test_id,</span><br><span class="line">   name,   </span><br><span class="line">   EXTRACT (YEAR FROM birth_date) AS YEAR,</span><br><span class="line">   EXTRACT (MONTH FROM birth_date) AS MONTH,</span><br><span class="line">   EXTRACT (DAY FROM birth_date) AS DAY</span><br><span class="line">FROM</span><br><span class="line">   test12;</span><br><span class="line"> test_id |  name   | year | month | day</span><br><span class="line">---------+---------+------+-------+-----</span><br><span class="line">       1 | Shannon | 2001 |     1 |   1</span><br><span class="line">       2 | Sheila  | 1988 |     8 |   8</span><br><span class="line">       3 | Ethel   | 1995 |     5 |   5</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<h3 id="时间戳数据类型"><a href="#时间戳数据类型" class="headerlink" title="时间戳数据类型"></a>时间戳数据类型</h3><blockquote>
<p>PostgreSQL提供了两种用于处理时间戳的时间数据类型，一种不带时区（timestamp），一种带时区（timestamptz）。</p>
</blockquote>
<blockquote>
<p>时间戳数据类型允许您存储日期和时间。但是，它没有任何时区数据。这意味着，当您更改数据库服务器的时区时，存储在数据库中的时间戳记值不会更改。</p>
</blockquote>
<blockquote>
<p>timestamptz数据是带有时区的时间戳。时间戳是可识别时区的日期和时间数据类型。PostgreSQL以UTC值存储时间戳。当您在timestamptz列中插入值时，PostgreSQL会将timestamptz值转换为UTC值并将UTC值存储在表中。</p>
</blockquote>
<blockquote>
<p>当您从数据库中查询timestamptz时，PostgreSQL将UTC值转换回数据库服务器，用户或当前数据库连接设置的时区的时间值。</p>
</blockquote>
<blockquote>
<p>请注意，timestamp和timestamptz都使用8个字节来存储时间戳值，如以下查询所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">      typname,</span><br><span class="line">      typlen</span><br><span class="line">FROM</span><br><span class="line">      pg_type</span><br><span class="line">WHERE</span><br><span class="line">      typname ~ <span class="string">'^timestamp'</span>;</span><br><span class="line">   typname   | typlen</span><br><span class="line">-------------+--------</span><br><span class="line"> timestamp   |      8</span><br><span class="line"> timestamptz |      8</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请务必注意，timestamptz值存储为UTC值。PostgreSQL不使用timestamptz值存储任何时区数据。</p>
</blockquote>
<h4 id="时间戳示例"><a href="#时间戳示例" class="headerlink" title="时间戳示例"></a>时间戳示例</h4><blockquote>
<p>创建由timestamp和timestamptz列组成的表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE timestamp_demo (ts TIMESTAMP, tstz TIMESTAMPTZ);</span></span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将数据库服务器的时区设置为Asia/Shanghai</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SET timezone = 'Asia/Shanghai';</span></span><br><span class="line">SET</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看当前时区</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SHOW TIMEZONE;</span></span><br><span class="line">   TimeZone</span><br><span class="line">---------------</span><br><span class="line"> Asia/Shanghai</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>插入新行timstamp_demo</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO timestamp_demo (ts, tstz)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'2018-08-08 20:20:20-07'</span>,</span><br><span class="line">      <span class="string">'2018-08-08 20:20:20-07'</span></span><br><span class="line">   );</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>进行查看</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   timestamp_demo;</span><br><span class="line">         ts          |          tstz</span><br><span class="line">---------------------+------------------------</span><br><span class="line"> 2018-08-08 20:20:20 | 2018-08-09 11:20:20+08</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常，最佳实践是使用timestamptz数据类型存储时间戳数据。</p>
</blockquote>
<h4 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT NOW();</span></span><br><span class="line">             now</span><br><span class="line">------------------------------</span><br><span class="line"> 2019-12-01 01:02:38.40504+08</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT CURRENT_TIMESTAMP;</span></span><br><span class="line">       current_timestamp</span><br><span class="line">-------------------------------</span><br><span class="line"> 2019-12-01 01:03:10.767703+08</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>获取没有日期的当前时间</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT CURRENT_TIME;</span></span><br><span class="line">    current_time</span><br><span class="line">--------------------</span><br><span class="line"> 01:05:31.757504+08</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，CURRENT_TIMESTAMP和CURRENT_TIME都返回带有时区的当前时间。</p>
</blockquote>
<blockquote>
<p>要使用字符串格式获取一天中的时间，请使用timeofday()函数:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT TIMEOFDAY();</span></span><br><span class="line">              timeofday</span><br><span class="line">-------------------------------------</span><br><span class="line"> Sun Dec 01 01:08:34.266333 2019 CST</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="在时区之间转换"><a href="#在时区之间转换" class="headerlink" title="在时区之间转换"></a>在时区之间转换</h4><blockquote>
<p>要将时间戳转换为另一个时区，可以使用timezone(zone, timestamp) 函数。如下，转换具体时间到Asia/chongqing时区:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SHOW TIMEZONE;</span></span><br><span class="line">   TimeZone</span><br><span class="line">---------------</span><br><span class="line"> Asia/Shanghai</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT timezone('Asia/chongqing','2019-12-01 00:00');</span></span><br><span class="line">      timezone</span><br><span class="line">---------------------</span><br><span class="line"> 2019-12-01 00:00:00</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，我们将时间戳记作为字符串传递给timezone()函数，PostgreSQL将其隐式转换为时间戳记。最好将时间戳值显式转换为timestamptz数据类型，如以下语句所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT timezone(<span class="string">'Asia/chongqing'</span>,<span class="string">'2019-12-01 00:00'</span>::timestamptz);</span><br></pre></td></tr></table></figure>
<h3 id="间隔数据类型"><a href="#间隔数据类型" class="headerlink" title="间隔数据类型"></a>间隔数据类型</h3><blockquote>
<p>时间间隔数据类型使您可以存储和操纵以年，月，日，小时，分钟，秒等为单位的时间段。以下说明了时间间隔类型：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ interval [ fields ] [ (p) ]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个间隔值需要16个字节的存储大小，可以存储一个范围为-178,000,000年至178,000,000年的周期。此外，间隔值可以具有可选的精度值p，其允许范围为0到6。精度p是保留在第二个字段中的小数位数。at符号（@）是可选的，可以忽略。</p>
</blockquote>
<blockquote>
<p>以下示例显示了一些时间间隔值:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interval <span class="string">'2 months ago'</span>;</span><br><span class="line">interval <span class="string">'3 hours 20 minutes'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在内部，PostgreSQL将间隔值存储为月，天和秒。月和日的值是整数，而秒可以字段可以是分数。</p>
</blockquote>
<blockquote>
<p>在进行日期或时间算术时，间隔值非常有用。例如，如果您想知道去年当前时间3小时30分钟前的时间，则可以使用以下语句:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   now(),</span><br><span class="line">   now() - INTERVAL <span class="string">'1 year 3 hours 30 minutes'</span></span><br><span class="line">             AS <span class="string">"3 hours 30 minutes ago of last year"</span>;</span><br><span class="line">              now              | 3 hours 30 minutes ago of last year</span><br><span class="line">-------------------------------+-------------------------------------</span><br><span class="line"> 2019-12-01 01:29:21.353013+08 | 2018-11-30 21:59:21.353013+08</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="PostgreSQL间隔输入格式"><a href="#PostgreSQL间隔输入格式" class="headerlink" title="PostgreSQL间隔输入格式"></a>PostgreSQL间隔输入格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quantity unit [quantity unit...] [direction]</span><br></pre></td></tr></table></figure>
<ul>
<li>quantity是数字，也可以使用符号+或-</li>
</ul>
<ul>
<li>unit可以是千年，世纪，十年，年，月，周，日，小时，分钟，秒，毫秒，微秒或缩写（y，m，d等）中的任何一种，也可以是复数形式（月，日，等等）。</li>
</ul>
<ul>
<li>direction可以是ago或为空字符串’’<blockquote>
<p>此格式称为postgres_verbose，也用于间隔输出格式。 </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>以下示例说明了一些使用详细语法的时间间隔值:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INTERVAL <span class="string">'1 year 2 months 3 days'</span>;</span><br><span class="line">INTERVAL <span class="string">'2 weeks ago'</span>;</span><br></pre></td></tr></table></figure>
<h4 id="ISO-8601间隔格式"><a href="#ISO-8601间隔格式" class="headerlink" title="ISO 8601间隔格式"></a>ISO 8601间隔格式</h4><blockquote>
<p>除了上述冗长的语法外，PostgreSQL还允许您使用ISO 8601时间间隔以两种方式写入间隔值:带指示符的格式和替代格式。</p>
</blockquote>
<blockquote>
<p>ISO 8601带有指示符的格式如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P quantity unit [ quantity unit ...] [ T [ quantity unit ...]]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这种格式下，间隔值必须以字母开头P。字母T用于确定时间单位。</p>
</blockquote>
<blockquote>
<p>ISO 8601间隔单位的缩写:<br> 缩写 |    描述<br>——|——<br>  Y      | 年份<br>  M      |月（在日期部分）<br>  W      | 周数<br>  D      |  天<br>  H      | 小时<br>  M      |分钟（在时间部分）<br>  S      |  秒</p>
</blockquote>
<blockquote>
<p>请注意，M可以是几个月或几分钟，具体取决于它出现在字母T之前还是之后。</p>
</blockquote>
<blockquote>
<p>例如，可以使用ISO 8601指示符格式将6年5个月4天3小时2分1秒的时间间隔编写为： </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P6Y5M4DT3H2M1S</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ISO 8601的替代形式是：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P [ years-months-days ] [ T hours:minutes:seconds ]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>它还必须以字母P开头，字母T分隔间隔值的日期和时间部分。例如，间隔6年5个月4天3小时2分1秒可以用ISO 8601替代格式编写为：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P0006-05-04T03:02:01</span><br></pre></td></tr></table></figure>
<h4 id="PostgreSQL间隔输出格式"><a href="#PostgreSQL间隔输出格式" class="headerlink" title="PostgreSQL间隔输出格式"></a>PostgreSQL间隔输出格式</h4><blockquote>
<p>间隔值的输出样式是使用SET intervalstyle命令设置的，例如：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET intervalstyle = <span class="string">'sql_standard'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PostgreSQL提供了四种输出格式：sql标准，postgres，postgresverbose和iso_8601。默认情况下，PostgresQL使用postgres样式来格式化间隔值。</p>
</blockquote>
<blockquote>
<p>以下代表四种样式中6年5个月4天3小时2分钟1秒的间隔：</p>
</blockquote>
<ul>
<li>sql标准    </li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SET intervalstyle = 'sql_standard';</span></span><br><span class="line">SET</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   INTERVAL <span class="string">'6 years 5 months 4 days 3 hours 2 minutes 1 second'</span>;</span><br><span class="line">     interval</span><br><span class="line">------------------</span><br><span class="line"> +6-5 +4 +3:02:01</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<ul>
<li>Postgres</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SET intervalstyle = 'postgres';</span></span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">   INTERVAL <span class="string">'6 years 5 months 4 days 3 hours 2 minutes 1 second'</span>;</span><br><span class="line">SET</span><br><span class="line"></span><br><span class="line">            interval</span><br><span class="line">--------------------------------</span><br><span class="line"> 6 years 5 mons 4 days 03:02:01</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<ul>
<li>Postgres详细    </li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SET intervalstyle = 'postgres_verbose';</span></span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">   INTERVAL <span class="string">'6 years 5 months 4 days 3 hours 2 minutes 1 second'</span>;</span><br><span class="line">SET</span><br><span class="line"></span><br><span class="line">                   interval</span><br><span class="line">----------------------------------------------</span><br><span class="line"> @ 6 years 5 mons 4 days 3 hours 2 mins 1 sec</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<ul>
<li>iso_8601<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SET intervalstyle = 'iso_8601';</span></span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">   INTERVAL <span class="string">'6 years 5 months 4 days 3 hours 2 minutes 1 second'</span>;</span><br><span class="line">SET</span><br><span class="line"></span><br><span class="line">    interval</span><br><span class="line">----------------</span><br><span class="line"> P6Y5M4DT3H2M1S</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="PostgreSQL间隔相关的运算符和函数"><a href="#PostgreSQL间隔相关的运算符和函数" class="headerlink" title="PostgreSQL间隔相关的运算符和函数"></a>PostgreSQL间隔相关的运算符和函数</h4><h5 id="间隔运算符"><a href="#间隔运算符" class="headerlink" title="间隔运算符"></a>间隔运算符</h5><blockquote>
<p>将算术运算符（+，-，*等）应用于间隔值，例如：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">INTERVAL <span class="string">'2h 50m'</span> + INTERVAL <span class="string">'10m'</span>; -- 03:00:00</span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">INTERVAL <span class="string">'2h 50m'</span> - INTERVAL <span class="string">'50m'</span>; -- 02:00:00</span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">600 * INTERVAL <span class="string">'1 minute'</span>; -- 10:00:00</span><br></pre></td></tr></table></figure>
<h5 id="将PostgreSQL间隔转换为字符串"><a href="#将PostgreSQL间隔转换为字符串" class="headerlink" title="将PostgreSQL间隔转换为字符串"></a>将PostgreSQL间隔转换为字符串</h5><blockquote>
<p>要将间隔值转换为字符串，请使用TO_CHAR()函数。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TO_CHAR(interval,format)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>TO_CHAR()函数将第一个参数用作间隔值，将第二个参数用作格式，并返回表示指定格式的间隔的字符串。参见以下示例：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    TO_CHAR(</span><br><span class="line">        INTERVAL <span class="string">'17h 20m 05s'</span>,</span><br><span class="line">        <span class="string">'HH24:MI:SS'</span></span><br><span class="line">    );</span><br><span class="line"> to_char</span><br><span class="line">----------</span><br><span class="line"> 17:20:05</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="从PostgreSQL间隔中提取数据"><a href="#从PostgreSQL间隔中提取数据" class="headerlink" title="从PostgreSQL间隔中提取数据"></a>从PostgreSQL间隔中提取数据</h4><blockquote>
<p>要从间隔中提取年，月，日等字段，请使用EXTRACT()功能。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXTRACT(field FROM interval)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该字段可以是您要从时间间隔中提取的年，月，日，时，分等。提取函数返回双精度类型的值。以下示例从间隔中提取分钟:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    EXTRACT (</span><br><span class="line">        MINUTE</span><br><span class="line">        FROM</span><br><span class="line">            INTERVAL <span class="string">'5 hours 21 minutes'</span></span><br><span class="line">    );</span><br><span class="line"> date_part</span><br><span class="line">-----------</span><br><span class="line">        21</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h5 id="调整间隔值"><a href="#调整间隔值" class="headerlink" title="调整间隔值"></a>调整间隔值</h5><blockquote>
<p>PostgreSQL提供两个功能justifydays和justifyhours，您可以将30天的间隔调整为一个月，将24小时的间隔调整为一日：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    justify_days(INTERVAL <span class="string">'30 days'</span>),</span><br><span class="line">    justify_hours(INTERVAL <span class="string">'24 hours'</span>);</span><br><span class="line"> justify_days | justify_hours</span><br><span class="line">--------------+---------------</span><br><span class="line"> P1M          | P1D</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另外，justify_interval函数使用justifydays和justifyhours来调整间隔，并进行其他符号调整：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    justify_interval(interval <span class="string">'1 year -1 hour'</span>);</span><br><span class="line"> justify_interval</span><br><span class="line">------------------</span><br><span class="line"> P11M29DT23H</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h3 id="TIME数据类型"><a href="#TIME数据类型" class="headerlink" title="TIME数据类型"></a>TIME数据类型</h3><h4 id="TIME数据类型语法"><a href="#TIME数据类型语法" class="headerlink" title="TIME数据类型语法"></a>TIME数据类型语法</h4><blockquote>
<p>PostgreSQL提供了TIME数据类型，它允许您存储一天中的时间值。以下语句说明了如何声明具有TIME数据类型的列：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column_name TIME(precision);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间值的精度最高为6位数字。精度指定放置在第二个字段中的小数位数。</p>
</blockquote>
<blockquote>
<p>TIME数据类型需要8个字节，其允许范围为00:00:00至24:00:00。TIME值的常见格式：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HH:MM  </span><br><span class="line">HH:MM:SS</span><br><span class="line">HHMMSS</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">01:02</span><br><span class="line">01:02:03</span><br><span class="line">010203</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要使用精度，可以使用以下格式：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MM:SS.pppppp    </span><br><span class="line">HH:MM:SS.pppppp</span><br><span class="line">HHMMSS.pppppp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以这种形式，p就是精度。例如：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">04:59.999999</span><br><span class="line">04:05:06.777777</span><br><span class="line">040506.777777</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PostgreSQL实际上接受几乎任何合理的TIME格式，包括SQL兼容、ISO 8601等。</p>
</blockquote>
<h4 id="TIME示例"><a href="#TIME示例" class="headerlink" title="TIME示例"></a>TIME示例</h4><blockquote>
<p>我们通常将TIME数据类型用于仅存储一天中时间的列，例如事件或班次的时间。</p>
</blockquote>
<blockquote>
<p>使用CREATE TABLE语句创建一个名为shifts的新表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE shifts (</span></span><br><span class="line">    id serial PRIMARY KEY,</span><br><span class="line">    shift_name VARCHAR NOT NULL,</span><br><span class="line">    start_at TIME NOT NULL,</span><br><span class="line">    end_at TIME NOT NULL</span><br><span class="line">);  </span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在表中插入一些行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO shifts(shift_name, start_at, end_at)</span></span><br><span class="line">VALUES(<span class="string">'Morning'</span>, <span class="string">'08:00:00'</span>, <span class="string">'12:00:00'</span>),</span><br><span class="line">      (<span class="string">'Afternoon'</span>, <span class="string">'13:00:00'</span>, <span class="string">'17:00:00'</span>),</span><br><span class="line">      (<span class="string">'Night'</span>, <span class="string">'18:00:00'</span>, <span class="string">'22:00:00'</span>);</span><br><span class="line">INSERT 0 3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看数据</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    shifts;</span><br><span class="line"> id | shift_name | start_at |  end_at</span><br><span class="line">----+------------+----------+----------</span><br><span class="line">  1 | Morning    | 08:00:00 | 12:00:00</span><br><span class="line">  2 | Afternoon  | 13:00:00 | 17:00:00</span><br><span class="line">  3 | Night      | 18:00:00 | 22:00:00</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<h4 id="时区类型的PostgreSQL-TIME"><a href="#时区类型的PostgreSQL-TIME" class="headerlink" title="时区类型的PostgreSQL TIME"></a>时区类型的PostgreSQL TIME</h4><blockquote>
<p>除TIME数据类型外，PostgreSQL还为TIME提供了带时区的数据类型，使您可以存储和操作带时区的一天中的时间。</p>
</blockquote>
<blockquote>
<p>以下语句说明了如何声明具有时区的数据类型为TIME的列:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column TIME with time zone</span><br></pre></td></tr></table></figure>
<blockquote>
<p>带有时区数据类型的TIME的存储大小为12个字节，可以存储时区范围从00:00:00+1459到24:00:00-1459的时间值。</p>
</blockquote>
<blockquote>
<p>下面说明了带有时区值的TIME：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">04:05:06 PST    </span><br><span class="line">04:05:06.789-8</span><br></pre></td></tr></table></figure>
<h4 id="处理PostgreSQL-TIME值"><a href="#处理PostgreSQL-TIME值" class="headerlink" title="处理PostgreSQL TIME值"></a>处理PostgreSQL TIME值</h4><h5 id="获取当前时间-1"><a href="#获取当前时间-1" class="headerlink" title="获取当前时间"></a>获取当前时间</h5><blockquote>
<p>要获取具有时区的当前时间，请使用CURRENT_TIME函数，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT CURRENT_TIME;</span></span><br><span class="line">    current_time</span><br><span class="line">--------------------</span><br><span class="line"> 14:47:11.435945+08</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要以特定的精度获取当前时间，请使用CURRENT_TIME(precision)函数:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT CURRENT_TIME(5);</span></span><br><span class="line">   current_time</span><br><span class="line">-------------------</span><br><span class="line"> 14:49:53.25791+08</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，在未指定精度的情况下，CURRENT_TIME函数将返回具有完整可用精度的时间值。</p>
</blockquote>
<blockquote>
<p>要获取当地时间，请使用LOCALTIME函数：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT LOCALTIME;</span></span><br><span class="line">    localtime</span><br><span class="line">-----------------</span><br><span class="line"> 14:51:09.619903</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同样，要获取具有特定精度的本地时间，请使用LOCALTIME(precision)函数:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT LOCALTIME(0);</span></span><br><span class="line"> localtime</span><br><span class="line">-----------</span><br><span class="line"> 14:51:40</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h5 id="将时间转换为其他时区"><a href="#将时间转换为其他时区" class="headerlink" title="将时间转换为其他时区"></a>将时间转换为其他时区</h5><blockquote>
<p>要将时间转换为其他时区，请使用以下格式：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[TIME with time zone] AT TIME ZONE time_zone</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如，要将本地时间转换为UTC-8时区的时间，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT LOCALTIME AT TIME ZONE 'UTC-8';</span></span><br><span class="line">     timezone</span><br><span class="line">-------------------</span><br><span class="line"> 14:57:19.23764+08</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h5 id="从时间值中提取小时、分钟、秒"><a href="#从时间值中提取小时、分钟、秒" class="headerlink" title="从时间值中提取小时、分钟、秒"></a>从时间值中提取小时、分钟、秒</h5><blockquote>
<p>要从时间值中提取小时、分钟、秒，请使用EXTRACT功能：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXTRACT(field FROM time_value);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该字段可以是小时、分钟、秒、毫秒，如以下示例所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    LOCALTIME,</span><br><span class="line">    EXTRACT (HOUR FROM LOCALTIME) as hour,</span><br><span class="line">    EXTRACT (MINUTE FROM LOCALTIME) as minute,</span><br><span class="line">    EXTRACT (SECOND FROM LOCALTIME) as second,</span><br><span class="line">    EXTRACT (milliseconds FROM LOCALTIME) as milliseconds;</span><br><span class="line">    localtime    | hour | minute |  second   | milliseconds</span><br><span class="line">-----------------+------+--------+-----------+--------------</span><br><span class="line"> 15:06:19.365592 |   15 |      6 | 19.365592 |    19365.592</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h5 id="时间值的算术运算"><a href="#时间值的算术运算" class="headerlink" title="时间值的算术运算"></a>时间值的算术运算</h5><blockquote>
<p>PostgreSQL允许您对时间值以及时间和间隔值之间应用算术运算符，例如+，-和* 。</p>
</blockquote>
<blockquote>
<p>以下语句返回两个时间值之间的间隔：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT time '10:00' - time '02:00';</span></span><br><span class="line"> ?column?</span><br><span class="line">----------</span><br><span class="line"> PT8H</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下语句将本地时间增加了2个小时：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT LOCALTIME + interval '2 hours';</span></span><br><span class="line">    ?column?</span><br><span class="line">-----------------</span><br><span class="line"> 17:13:24.405449</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h3 id="UUID数据类型"><a href="#UUID数据类型" class="headerlink" title="UUID数据类型"></a>UUID数据类型</h3><blockquote>
<p>UUID代表由RFC 4122和其他相关标准定义的通用唯一标识符。UUID值是一种算法生成的128位数量，使用相同的算法在已知的Universe中使其唯一。下面显示了一些UUID值示例:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">40e6215d-b5c6-4896-987c-f30f3678f608</span><br><span class="line">6ecd8c99-4036-403d-bf84-cf8400f67836</span><br><span class="line">3f333df6-90a4-4fda-8dd3-9485d27cee36</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如您所见，UUID是由连字符分隔的组表示的32位十六进制数字的序列。</p>
</blockquote>
<blockquote>
<p>由于其唯一性功能，可以经常在分布式系统中找到UUID，因为它可以保证比SERIAL数据类型更好的唯一性，而SERIAL数据类型仅在单个数据库中生成唯一值。</p>
</blockquote>
<blockquote>
<p>要将UUID值存储在PostgreSQL数据库中，请使用UUID数据类型。</p>
</blockquote>
<h4 id="生成UUID值"><a href="#生成UUID值" class="headerlink" title="生成UUID值"></a>生成UUID值</h4><blockquote>
<p>PostgreSQL允许您存储和比较UUID值，但它不包含用于在其核心中生成UUID值的函数。相反，它依赖于提供特定算法以生成UUID的第三方模块。</p>
</blockquote>
<blockquote>
<p>例如，uuid-ossp模块提供了一些方便的功能，这些功能实现了用于生成UUID的标准算法。要安装uuid-ossp模块，请使用CREATE EXTENSION语句，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum -y install postgresql12-contrib</span></span><br><span class="line"><span class="comment"># psql -h 192.168.100.133 -U postgres</span></span><br><span class="line">用户 postgres 的口令：</span><br><span class="line">psql (12.1)</span><br><span class="line">输入 <span class="string">"help"</span> 来获取帮助信息.</span><br><span class="line"></span><br><span class="line">postgres=<span class="comment"># CREATE EXTENSION IF NOT EXISTS "uuid-ossp";</span></span><br><span class="line">CREATE EXTENSION</span><br></pre></td></tr></table></figure>
<ul>
<li>IF NOT EXISTS子句允许您避免重新安装模块。</li>
</ul>
<blockquote>
<p>要基于计算机的MAC地址、当前时间戳和随机值的组合生成UUID值，请使用uuid_generate_v1()函数：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT uuid_generate_v1();</span></span><br><span class="line">           uuid_generate_v1</span><br><span class="line">--------------------------------------</span><br><span class="line"> 3db0aed4-1420-11ea-85a4-000c2975eafe</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要仅基于随机数生成UUID值，则可以使用该uuid_generate_v4()函数:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT uuid_generate_v4();</span></span><br><span class="line">           uuid_generate_v4</span><br><span class="line">--------------------------------------</span><br><span class="line"> f5263124-b29c-4cab-85f9-d046d44e2405</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="使用UUID列创建表"><a href="#使用UUID列创建表" class="headerlink" title="使用UUID列创建表"></a>使用UUID列创建表</h4><ul>
<li>contact_id列的数据类型为UUID，其具有uuid_generate_v4()函数提供的默认值。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE TABLE contacts (</span></span><br><span class="line">    contact_id uuid DEFAULT uuid_generate_v4 (),</span><br><span class="line">    first_name VARCHAR NOT NULL,</span><br><span class="line">    last_name VARCHAR NOT NULL,</span><br><span class="line">    email VARCHAR NOT NULL,</span><br><span class="line">    phone VARCHAR,</span><br><span class="line">    PRIMARY KEY (contact_id)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<ul>
<li>插入数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># INSERT INTO contacts (</span></span><br><span class="line">    first_name,</span><br><span class="line">    last_name,</span><br><span class="line">    email,</span><br><span class="line">    phone</span><br><span class="line">)</span><br><span class="line">VALUES</span><br><span class="line">    (</span><br><span class="line">        <span class="string">'John'</span>,</span><br><span class="line">        <span class="string">'Smith'</span>,</span><br><span class="line">        <span class="string">'john@example.com'</span>,</span><br><span class="line">        <span class="string">'4082-2345'</span></span><br><span class="line">    ),</span><br><span class="line">    (</span><br><span class="line">        <span class="string">'Jane'</span>,</span><br><span class="line">        <span class="string">'Smith'</span>,</span><br><span class="line">        <span class="string">'jane@example.com'</span>,</span><br><span class="line">        <span class="string">'4082-2344'</span></span><br><span class="line">    ),</span><br><span class="line">    (</span><br><span class="line">        <span class="string">'Alex'</span>,</span><br><span class="line">        <span class="string">'Smith'</span>,</span><br><span class="line">        <span class="string">'alex@example.com'</span>,</span><br><span class="line">        <span class="string">'4037-2343'</span></span><br><span class="line">    );</span><br><span class="line">INSERT 0 3</span><br></pre></td></tr></table></figure>
<ul>
<li>进行查看</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    contacts;</span><br><span class="line">              contact_id              | first_name | last_name |      email       |   phone</span><br><span class="line">--------------------------------------+------------+-----------+------------------+-----------</span><br><span class="line"> 3fc6f6a9-2fb3-4c65-9465-576cf3bdb776 | John       | Smith     | john@example.com | 4082-2345</span><br><span class="line"> ec307779-360b-4ac3-a1b8-3ae9800cfae1 | Jane       | Smith     | jane@example.com | 4082-2344</span><br><span class="line"> be6cb08a-f185-4ac0-b900-0cea07c5b71b | Alex       | Smith     | alex@example.com | 4037-2343</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<h3 id="JSON数据类型"><a href="#JSON数据类型" class="headerlink" title="JSON数据类型"></a>JSON数据类型</h3><blockquote>
<p>JSON代表JavaScript对象符号。JSON是一种开放标准格式，由键值对组成。JSON的主要用途是在服务器和Web应用程序之间传输数据。</p>
</blockquote>
<blockquote>
<p>首先，创建一个用于练习JSON数据类型的新表。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE orders (</span></span><br><span class="line">   ID serial NOT NULL PRIMARY KEY,</span><br><span class="line">   info json NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该orders表由两列组成：</p>
<ul>
<li>id 列是标识订单的主键列。</li>
</ul>
<ul>
<li>info列以JSON形式存储数据。</li>
</ul>
</blockquote>
<h4 id="插入JSON数据"><a href="#插入JSON数据" class="headerlink" title="插入JSON数据"></a>插入JSON数据</h4><blockquote>
<p>要将数据插入JSON列，必须确保数据采用有效的JSON格式。以下INSERT语句在orders表中插入新行:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO orders (info)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'&#123; "customer": "Tom", "items": &#123;"product": "Beer","qty": 6&#125;&#125;'</span></span><br><span class="line">   );</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同时插入多行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO orders (info)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'&#123; "customer": "Lily", "items": &#123;"product": "TV","qty": 1&#125;&#125;'</span></span><br><span class="line">   ),</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'&#123; "customer": "William", "items": &#123;"product": "Toy Car","qty": 2&#125;&#125;'</span></span><br><span class="line">   ),</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'&#123; "customer": "Mary", "items": &#123;"product": "Toy Train","qty": 3&#125;&#125;'</span></span><br><span class="line">   );</span><br><span class="line">INSERT 0 3</span><br></pre></td></tr></table></figure>
<h4 id="查询JSON数据"><a href="#查询JSON数据" class="headerlink" title="查询JSON数据"></a>查询JSON数据</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   info</span><br><span class="line">FROM</span><br><span class="line">   orders;</span><br><span class="line">                                info</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line"> &#123; <span class="string">"customer"</span>: <span class="string">"Tom"</span>, <span class="string">"items"</span>: &#123;<span class="string">"product"</span>: <span class="string">"Beer"</span>,<span class="string">"qty"</span>: 6&#125;&#125;</span><br><span class="line"> &#123; <span class="string">"customer"</span>: <span class="string">"Lily"</span>, <span class="string">"items"</span>: &#123;<span class="string">"product"</span>: <span class="string">"TV"</span>,<span class="string">"qty"</span>: 1&#125;&#125;</span><br><span class="line"> &#123; <span class="string">"customer"</span>: <span class="string">"William"</span>, <span class="string">"items"</span>: &#123;<span class="string">"product"</span>: <span class="string">"Toy Car"</span>,<span class="string">"qty"</span>: 2&#125;&#125;</span><br><span class="line"> &#123; <span class="string">"customer"</span>: <span class="string">"Mary"</span>, <span class="string">"items"</span>: &#123;<span class="string">"product"</span>: <span class="string">"Toy Train"</span>,<span class="string">"qty"</span>: 3&#125;&#125;</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PostgreSQL以JSON的形式返回结果集。</p>
</blockquote>
<blockquote>
<p>PostgreSQL提供了两个本机运算符-&gt;和-&gt;&gt;来帮助您查询JSON数据:</p>
<ul>
<li>运算符-&gt;按键返回JSON对象字段。</li>
</ul>
<ul>
<li>运算符-&gt;&gt;按文本返回JSON对象字段。</li>
</ul>
</blockquote>
<blockquote>
<p>以下查询使用运算符-&gt;以JSON形式获取所有客户:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   info -&gt; <span class="string">'customer'</span> AS customer</span><br><span class="line">FROM</span><br><span class="line">   orders;</span><br><span class="line"> customer</span><br><span class="line">-----------</span><br><span class="line"> <span class="string">"Tom"</span></span><br><span class="line"> <span class="string">"Lily"</span></span><br><span class="line"> <span class="string">"William"</span></span><br><span class="line"> <span class="string">"Mary"</span></span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下查询使用运算符-&gt;&gt;以文本形式获取所有客户:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   info -&gt;&gt; <span class="string">'customer'</span> AS customer</span><br><span class="line">FROM</span><br><span class="line">   orders;</span><br><span class="line"> customer</span><br><span class="line">----------</span><br><span class="line"> Tom</span><br><span class="line"> Lily</span><br><span class="line"> William</span><br><span class="line"> Mary</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于-&gt;运算符返回JSON对象，因此可以将其与运算符-&gt;&gt;链接以检索特定节点。例如，以下语句返回所有出售的产品：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   info -&gt; <span class="string">'items'</span> -&gt;&gt; <span class="string">'product'</span> as product</span><br><span class="line">FROM</span><br><span class="line">   orders</span><br><span class="line">ORDER BY</span><br><span class="line">   product;</span><br><span class="line">  product</span><br><span class="line">-----------</span><br><span class="line"> Beer</span><br><span class="line"> Toy Car</span><br><span class="line"> Toy Train</span><br><span class="line"> TV</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个信息-&gt;’items’将项目作为JSON对象返回。然后info-&gt;’items’-&gt;&gt;’product’以文本形式返回所有产品。</li>
</ul>
<h4 id="在WHERE子句中使用JSON运算符"><a href="#在WHERE子句中使用JSON运算符" class="headerlink" title="在WHERE子句中使用JSON运算符"></a>在WHERE子句中使用JSON运算符</h4><blockquote>
<p>可以在WHERE子句中使用JSON运算符来过滤返回的行。例如，要查找谁购买了TV，我们使用以下查询:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   info -&gt;&gt; <span class="string">'customer'</span> AS customer</span><br><span class="line">FROM</span><br><span class="line">   orders</span><br><span class="line">WHERE</span><br><span class="line">   info -&gt; <span class="string">'items'</span> -&gt;&gt; <span class="string">'product'</span> = <span class="string">'TV'</span>;</span><br><span class="line"> customer</span><br><span class="line">----------</span><br><span class="line"> Lily</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了找出谁一次购买了两种产品，使用以下查询：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   info -&gt;&gt; <span class="string">'customer'</span> AS customer,</span><br><span class="line">   info -&gt; <span class="string">'items'</span> -&gt;&gt; <span class="string">'product'</span> AS product</span><br><span class="line">FROM</span><br><span class="line">   orders</span><br><span class="line">WHERE</span><br><span class="line">   CAST (</span><br><span class="line">      info -&gt; <span class="string">'items'</span> -&gt;&gt; <span class="string">'qty'</span> AS INTEGER</span><br><span class="line">   ) = 2;</span><br><span class="line"> customer | product</span><br><span class="line">----------+---------</span><br><span class="line"> William  | Toy Car</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，我们使用类型转换将qty字段转换为INTEGER类型并将其与两个进行比较。</p>
</blockquote>
<h4 id="将聚合函数应用于JSON数据"><a href="#将聚合函数应用于JSON数据" class="headerlink" title="将聚合函数应用于JSON数据"></a>将聚合函数应用于JSON数据</h4><blockquote>
<p>将聚合函数（例如MIN，MAX，AVERAGE，SUM等）应用于JSON数据。例如，以下语句返回最小数量，最大数量，平均数量和所售产品的总数量。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   MIN (</span><br><span class="line">      CAST (</span><br><span class="line">         info -&gt; <span class="string">'items'</span> -&gt;&gt; <span class="string">'qty'</span> AS INTEGER</span><br><span class="line">      )</span><br><span class="line">   ),</span><br><span class="line">   MAX (</span><br><span class="line">      CAST (</span><br><span class="line">         info -&gt; <span class="string">'items'</span> -&gt;&gt; <span class="string">'qty'</span> AS INTEGER</span><br><span class="line">      )</span><br><span class="line">   ),</span><br><span class="line">   SUM (</span><br><span class="line">      CAST (</span><br><span class="line">         info -&gt; <span class="string">'items'</span> -&gt;&gt; <span class="string">'qty'</span> AS INTEGER</span><br><span class="line">      )</span><br><span class="line">   ),</span><br><span class="line">   AVG (</span><br><span class="line">      CAST (</span><br><span class="line">         info -&gt; <span class="string">'items'</span> -&gt;&gt; <span class="string">'qty'</span> AS INTEGER</span><br><span class="line">      )</span><br><span class="line">   )</span><br><span class="line"> </span><br><span class="line">FROM</span><br><span class="line">   orders;</span><br><span class="line"> min | max | sum |        avg</span><br><span class="line">-----+-----+-----+--------------------</span><br><span class="line">   1 |   6 |  12 | 3.0000000000000000</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="JSON函数"><a href="#JSON函数" class="headerlink" title="JSON函数"></a>JSON函数</h4><h5 id="json-each函数"><a href="#json-each函数" class="headerlink" title="json_each函数"></a>json_each函数</h5><blockquote>
<p>json_each()函数允许我们将最外面的JSON对象扩展为一组键值对。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   json_each (info)</span><br><span class="line">FROM</span><br><span class="line">   orders;</span><br><span class="line">                     json_each</span><br><span class="line">---------------------------------------------------</span><br><span class="line"> (customer,<span class="string">""</span><span class="string">"Tom"</span><span class="string">""</span>)</span><br><span class="line"> (items,<span class="string">"&#123;"</span><span class="string">"product"</span><span class="string">": "</span><span class="string">"Beer"</span><span class="string">","</span><span class="string">"qty"</span><span class="string">": 6&#125;"</span>)</span><br><span class="line"> (customer,<span class="string">""</span><span class="string">"Lily"</span><span class="string">""</span>)</span><br><span class="line"> (items,<span class="string">"&#123;"</span><span class="string">"product"</span><span class="string">": "</span><span class="string">"TV"</span><span class="string">","</span><span class="string">"qty"</span><span class="string">": 1&#125;"</span>)</span><br><span class="line"> (customer,<span class="string">""</span><span class="string">"William"</span><span class="string">""</span>)</span><br><span class="line"> (items,<span class="string">"&#123;"</span><span class="string">"product"</span><span class="string">": "</span><span class="string">"Toy Car"</span><span class="string">","</span><span class="string">"qty"</span><span class="string">": 2&#125;"</span>)</span><br><span class="line"> (customer,<span class="string">""</span><span class="string">"Mary"</span><span class="string">""</span>)</span><br><span class="line"> (items,<span class="string">"&#123;"</span><span class="string">"product"</span><span class="string">": "</span><span class="string">"Toy Train"</span><span class="string">","</span><span class="string">"qty"</span><span class="string">": 3&#125;"</span>)</span><br><span class="line">(8 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要获取一组键值对作为文本，请改用json_each_text()函数。</p>
</blockquote>
<h5 id="json-object-keys函数"><a href="#json-object-keys函数" class="headerlink" title="json_object_keys函数"></a>json_object_keys函数</h5><blockquote>
<p>要在最外层JSON对象中获取一组键，请使用json_object_keys()函数。以下查询返回列中嵌套items对象的所有键info:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   json_object_keys (info-&gt;<span class="string">'items'</span>)</span><br><span class="line">FROM</span><br><span class="line">   orders;</span><br><span class="line"> json_object_keys</span><br><span class="line">------------------</span><br><span class="line"> product</span><br><span class="line"> qty</span><br><span class="line"> product</span><br><span class="line"> qty</span><br><span class="line"> product</span><br><span class="line"> qty</span><br><span class="line"> product</span><br><span class="line"> qty</span><br><span class="line">(8 rows)</span><br></pre></td></tr></table></figure>
<h5 id="json-typeof函数"><a href="#json-typeof函数" class="headerlink" title="json_typeof函数"></a>json_typeof函数</h5><blockquote>
<p>json_typeof()函数以字符串形式返回最外面的JSON值的类型。可以是number，boolean，null，object，array和string。</p>
</blockquote>
<blockquote>
<p>以下查询返回项目的数据类型：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   json_typeof (info-&gt;<span class="string">'items'</span>)</span><br><span class="line">FROM</span><br><span class="line">   orders;</span><br><span class="line"> json_typeof</span><br><span class="line">-------------</span><br><span class="line"> object</span><br><span class="line"> object</span><br><span class="line"> object</span><br><span class="line"> object</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下查询返回嵌套项目JSON对象的qty字段的数据类型:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   json_typeof (info-&gt;<span class="string">'items'</span>-&gt;<span class="string">'qty'</span>)</span><br><span class="line">FROM</span><br><span class="line">   orders;</span><br><span class="line"> json_typeof</span><br><span class="line">-------------</span><br><span class="line"> number</span><br><span class="line"> number</span><br><span class="line"> number</span><br><span class="line"> number</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<h3 id="hstore数据类型"><a href="#hstore数据类型" class="headerlink" title="hstore数据类型"></a>hstore数据类型</h3><blockquote>
<p>hstore模块实现了用于将键值对存储为单个值的hstore数据类型。hstore数据类型在许多情况下非常有用，例如半结构化数据或具有很少查询的许多属性的行。请注意，键和值仅是文本字符串。</p>
</blockquote>
<h4 id="启用hstore扩展"><a href="#启用hstore扩展" class="headerlink" title="启用hstore扩展"></a>启用hstore扩展</h4><blockquote>
<p>在使用hstore数据类型之前，需要启用hstore扩展，以将contrib模块加载到PostgreSQL实例。</p>
</blockquote>
<h4 id="创建具有hstore数据类型的表"><a href="#创建具有hstore数据类型的表" class="headerlink" title="创建具有hstore数据类型的表"></a>创建具有hstore数据类型的表</h4><blockquote>
<p>创建一个表books ，该表具有三列：</p>
<ul>
<li>id 是识别书籍的主键。</li>
</ul>
<ul>
<li>title 是产品的标题</li>
</ul>
<ul>
<li>attr 存储书籍的属性，例如ISBN，重量和平装本。attr列的数据类型为hstore。</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE TABLE books (</span></span><br><span class="line">   id serial primary key,</span><br><span class="line">   title VARCHAR (255),</span><br><span class="line">   attr hstore</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<h4 id="将数据插入hstore列"><a href="#将数据插入hstore列" class="headerlink" title="将数据插入hstore列"></a>将数据插入hstore列</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># INSERT INTO books (title, attr)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'PostgreSQL'</span>,</span><br><span class="line">      <span class="string">'"paperback" =&gt; "243",</span></span><br><span class="line"><span class="string">      "publisher" =&gt; "postgresql.org",</span></span><br><span class="line"><span class="string">      "language"  =&gt; "English",</span></span><br><span class="line"><span class="string">      "ISBN-13"   =&gt; "978-1449370000",</span></span><br><span class="line"><span class="string">       "weight"    =&gt; "11.2 ounces"'</span></span><br><span class="line">   );</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>插入到hstore列中的数据是用逗号分隔的key =&gt; value对的列表。键和值都用双引号（“”）引起来。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># INSERT INTO books (title, attr)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'PostgreSQL'</span>,</span><br><span class="line">      <span class="string">'</span></span><br><span class="line"><span class="string">"paperback" =&gt; "5",</span></span><br><span class="line"><span class="string">"publisher" =&gt; "postgresql.org",</span></span><br><span class="line"><span class="string">"language"  =&gt; "English",</span></span><br><span class="line"><span class="string">"ISBN-13"   =&gt; "978-1449370001",</span></span><br><span class="line"><span class="string">"weight"    =&gt; "1 ounces"'</span></span><br><span class="line">   );</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<h4 id="从hstore列查询数据"><a href="#从hstore列查询数据" class="headerlink" title="从hstore列查询数据"></a>从hstore列查询数据</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   attr</span><br><span class="line">FROM</span><br><span class="line">   books;</span><br><span class="line">                                                              attr</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> <span class="string">"weight"</span>=&gt;<span class="string">"11.2 ounces"</span>, <span class="string">"ISBN-13"</span>=&gt;<span class="string">"978-1449370000"</span>, <span class="string">"language"</span>=&gt;<span class="string">"English"</span>, <span class="string">"paperback"</span>=&gt;<span class="string">"243"</span>, <span class="string">"publisher"</span>=&gt;<span class="string">"postgresql.org"</span></span><br><span class="line"> <span class="string">"weight"</span>=&gt;<span class="string">"1 ounces"</span>, <span class="string">"ISBN-13"</span>=&gt;<span class="string">"978-1449370001"</span>, <span class="string">"language"</span>=&gt;<span class="string">"English"</span>, <span class="string">"paperback"</span>=&gt;<span class="string">"5"</span>, <span class="string">"publisher"</span>=&gt;<span class="string">"postgresql.org"</span></span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h4 id="查询特定键的值"><a href="#查询特定键的值" class="headerlink" title="查询特定键的值"></a>查询特定键的值</h4><blockquote>
<p>PostgreSQL hstore提供了-&gt;运算符，可从hstore列中查询特定键的值。例如，如果我们想知道books表中所有可用书籍的ISBN-13，则可以使用-&gt;运算符，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   attr -&gt; <span class="string">'ISBN-13'</span> AS isbn</span><br><span class="line">FROM</span><br><span class="line">   books;</span><br><span class="line">      isbn</span><br><span class="line">----------------</span><br><span class="line"> 978-1449370000</span><br><span class="line"> 978-1449370001</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h4 id="在WHERE子句中使用值"><a href="#在WHERE子句中使用值" class="headerlink" title="在WHERE子句中使用值"></a>在WHERE子句中使用值</h4><blockquote>
<p>可以在WHERE子句中使用-&gt;运算符来过滤其hstore列的值与输入值匹配的行。例如，查询检索ISBN-13值匹配978-1449370000的书的书名和重量：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   attr -&gt; <span class="string">'weight'</span> AS weight</span><br><span class="line">FROM</span><br><span class="line">   books</span><br><span class="line">WHERE</span><br><span class="line">   attr -&gt; <span class="string">'ISBN-13'</span> = <span class="string">'978-1449370000'</span>;</span><br><span class="line">   weight</span><br><span class="line">-------------</span><br><span class="line"> 11.2 ounces</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="将键值对添加到现有行"><a href="#将键值对添加到现有行" class="headerlink" title="将键值对添加到现有行"></a>将键值对添加到现有行</h4><blockquote>
<p>使用hstore列，可以轻松地将新的键值对添加到现有行。例如，可以将免费送货键添加到books表的attr列，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># UPDATE books</span></span><br><span class="line">SET attr = attr || <span class="string">'"freeshipping"=&gt;"yes"'</span> :: hstore;</span><br><span class="line">UPDATE 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在，可以检查“freeshipping” =&gt;“yes”对是否已成功添加:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   title,</span><br><span class="line">        attr -&gt; <span class="string">'freeshipping'</span> AS freeshipping</span><br><span class="line">FROM</span><br><span class="line">   books;</span><br><span class="line">   title    | freeshipping</span><br><span class="line">------------+--------------</span><br><span class="line"> PostgreSQL | yes</span><br><span class="line"> PostgreSQL | yes</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h4 id="更新现有的键值对"><a href="#更新现有的键值对" class="headerlink" title="更新现有的键值对"></a>更新现有的键值对</h4><blockquote>
<p>可以使用UPDATE语句更新现有的键值对。以下语句将“freeshipping”键的值更新为“no”:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># UPDATE books</span></span><br><span class="line">SET attr = attr || <span class="string">'"freeshipping"=&gt;"no"'</span> :: hstore;</span><br><span class="line">UPDATE 2</span><br></pre></td></tr></table></figure>
<h4 id="删除现有的键值对"><a href="#删除现有的键值对" class="headerlink" title="删除现有的键值对"></a>删除现有的键值对</h4><blockquote>
<p>PostgreSQL允许从hstore列中删除现有的键/值对。以下语句删除attr列中的“freeshipping” =&gt;“ no”键值对:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># UPDATE books</span></span><br><span class="line">SET attr = delete(attr, <span class="string">'freeshipping'</span>);</span><br><span class="line">UPDATE 2</span><br></pre></td></tr></table></figure>
<h4 id="检查hstore列中的特定键"><a href="#检查hstore列中的特定键" class="headerlink" title="检查hstore列中的特定键"></a>检查hstore列中的特定键</h4><blockquote>
<p>可以使用？检查hstore列中的特定键，WHERE子句中的运算符。以下语句返回所有包含attr包含密钥发布者的行：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">  title,</span><br><span class="line">  attr-&gt;<span class="string">'publisher'</span> as publisher,</span><br><span class="line">  attr</span><br><span class="line">FROM</span><br><span class="line">   books</span><br><span class="line">WHERE</span><br><span class="line">   attr ? <span class="string">'publisher'</span>;</span><br><span class="line">   title    |   publisher    |                                                              attr</span><br><span class="line">------------+----------------+--------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> PostgreSQL | postgresql.org | <span class="string">"weight"</span>=&gt;<span class="string">"11.2 ounces"</span>, <span class="string">"ISBN-13"</span>=&gt;<span class="string">"978-1449370000"</span>, <span class="string">"language"</span>=&gt;<span class="string">"English"</span>, <span class="string">"paperback"</span>=&gt;<span class="string">"243"</span>, <span class="string">"publisher"</span>=&gt;<span class="string">"postgresql.org"</span></span><br><span class="line"> PostgreSQL | postgresql.org | <span class="string">"weight"</span>=&gt;<span class="string">"1 ounces"</span>, <span class="string">"ISBN-13"</span>=&gt;<span class="string">"978-1449370001"</span>, <span class="string">"language"</span>=&gt;<span class="string">"English"</span>, <span class="string">"paperback"</span>=&gt;<span class="string">"5"</span>, <span class="string">"publisher"</span>=&gt;<span class="string">"postgresql.org"</span></span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h4 id="检查键值对"><a href="#检查键值对" class="headerlink" title="检查键值对"></a>检查键值对</h4><blockquote>
<p>可以使用@&gt;运算符基于hstore键值对进行查询。以下语句检索attr列包含匹配“重量” =&gt;“ 11.2盎司”的键值对的所有行:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   title</span><br><span class="line">FROM</span><br><span class="line">   books</span><br><span class="line">WHERE</span><br><span class="line">   attr @&gt; <span class="string">'"weight"=&gt;"11.2 ounces"'</span> :: hstore;</span><br><span class="line">   title</span><br><span class="line">------------</span><br><span class="line"> PostgreSQL</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="查询包含多个指定键的行"><a href="#查询包含多个指定键的行" class="headerlink" title="查询包含多个指定键的行"></a>查询包含多个指定键的行</h4><blockquote>
<p>可以使用？＆运算符查询其hstore列包含多个键的行。可以在attr列中同时包含语言键和重量键的书籍:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   title</span><br><span class="line">FROM</span><br><span class="line">   books</span><br><span class="line">WHERE</span><br><span class="line">   attr ?&amp; ARRAY [ <span class="string">'language'</span>, <span class="string">'weight'</span> ];</span><br><span class="line">   title</span><br><span class="line">------------</span><br><span class="line"> PostgreSQL</span><br><span class="line"> PostgreSQL</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要检查其hstore列中的行是否包含键列表中的任何键，请使用？|运算符，而不是？＆运算符。</p>
</blockquote>
<h4 id="从hstore列获取所有密钥"><a href="#从hstore列获取所有密钥" class="headerlink" title="从hstore列获取所有密钥"></a>从hstore列获取所有密钥</h4><blockquote>
<p>要从hstore列获取所有密钥，请使用akeys()函数，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   akeys (attr)</span><br><span class="line">FROM</span><br><span class="line">   books;</span><br><span class="line">                     akeys</span><br><span class="line">-----------------------------------------------</span><br><span class="line"> &#123;weight,ISBN-13,language,paperback,publisher&#125;</span><br><span class="line"> &#123;weight,ISBN-13,language,paperback,publisher&#125;</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者，如果希望PostgreSQL将结果作为集合返回，则可以使用skey()函数。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   skeys (attr)</span><br><span class="line">FROM</span><br><span class="line">   books;</span><br><span class="line">   skeys</span><br><span class="line">-----------</span><br><span class="line"> weight</span><br><span class="line"> ISBN-13</span><br><span class="line"> language</span><br><span class="line"> paperback</span><br><span class="line"> publisher</span><br><span class="line"> weight</span><br><span class="line"> ISBN-13</span><br><span class="line"> language</span><br><span class="line"> paperback</span><br><span class="line"> publisher</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>
<h4 id="从hstore列获取所有值"><a href="#从hstore列获取所有值" class="headerlink" title="从hstore列获取所有值"></a>从hstore列获取所有值</h4><blockquote>
<p>像键一样，可以使用avals()函数以数组的形式从hstore列中获取所有值。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   avals (attr)</span><br><span class="line">FROM</span><br><span class="line">   books;</span><br><span class="line">                           avals</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"> &#123;<span class="string">"11.2 ounces"</span>,978-1449370000,English,243,postgresql.org&#125;</span><br><span class="line"> &#123;<span class="string">"1 ounces"</span>,978-1449370001,English,5,postgresql.org&#125;</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者，如果想将结果作为一个集合，则可以使用svals()函数。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   svals (attr)</span><br><span class="line">FROM</span><br><span class="line">   books;</span><br><span class="line">     svals</span><br><span class="line">----------------</span><br><span class="line"> 11.2 ounces</span><br><span class="line"> 978-1449370000</span><br><span class="line"> English</span><br><span class="line"> 243</span><br><span class="line"> postgresql.org</span><br><span class="line"> 1 ounces</span><br><span class="line"> 978-1449370001</span><br><span class="line"> English</span><br><span class="line"> 5</span><br><span class="line"> postgresql.org</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>
<h4 id="将Hstore数据转换为JSON"><a href="#将Hstore数据转换为JSON" class="headerlink" title="将Hstore数据转换为JSON"></a>将Hstore数据转换为JSON</h4><blockquote>
<p>PostgreSQL提供hstore_to_json()函数将hstore数据转换为JSON。请参阅以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">  title,</span><br><span class="line">  hstore_to_json (attr) json</span><br><span class="line">FROM</span><br><span class="line">  books;</span><br><span class="line">   title    |                                                               json</span><br><span class="line">------------+----------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> PostgreSQL | &#123;<span class="string">"weight"</span>: <span class="string">"11.2 ounces"</span>, <span class="string">"ISBN-13"</span>: <span class="string">"978-1449370000"</span>, <span class="string">"language"</span>: <span class="string">"English"</span>, <span class="string">"paperback"</span>: <span class="string">"243"</span>, <span class="string">"publisher"</span>: <span class="string">"postgresql.org"</span>&#125;</span><br><span class="line"> PostgreSQL | &#123;<span class="string">"weight"</span>: <span class="string">"1 ounces"</span>, <span class="string">"ISBN-13"</span>: <span class="string">"978-1449370001"</span>, <span class="string">"language"</span>: <span class="string">"English"</span>, <span class="string">"paperback"</span>: <span class="string">"5"</span>, <span class="string">"publisher"</span>: <span class="string">"postgresql.org"</span>&#125;</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h4 id="将Hstore数据转换为集合"><a href="#将Hstore数据转换为集合" class="headerlink" title="将Hstore数据转换为集合"></a>将Hstore数据转换为集合</h4><blockquote>
<p>要将hstore数据转换为集合，请使用each()函数，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   title,</span><br><span class="line">   (EACH(attr) ).*</span><br><span class="line">FROM</span><br><span class="line">   books;</span><br><span class="line">   title    |    key    |     value</span><br><span class="line">------------+-----------+----------------</span><br><span class="line"> PostgreSQL | weight    | 11.2 ounces</span><br><span class="line"> PostgreSQL | ISBN-13   | 978-1449370000</span><br><span class="line"> PostgreSQL | language  | English</span><br><span class="line"> PostgreSQL | paperback | 243</span><br><span class="line"> PostgreSQL | publisher | postgresql.org</span><br><span class="line"> PostgreSQL | weight    | 1 ounces</span><br><span class="line"> PostgreSQL | ISBN-13   | 978-1449370001</span><br><span class="line"> PostgreSQL | language  | English</span><br><span class="line"> PostgreSQL | paperback | 5</span><br><span class="line"> PostgreSQL | publisher | postgresql.org</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>
<h3 id="PostgreSQL数组"><a href="#PostgreSQL数组" class="headerlink" title="PostgreSQL数组"></a>PostgreSQL数组</h3><blockquote>
<p>数组在PostgreSQL中扮演重要角色。每个数据类型都有自己的伴随数组类型，例如integer具有integer []数组类型，character具有character[]数组类型等。如果定义了自己的数据类型，PostgreSQL会在后台为您创建一个对应的数组类型。PostgreSQL允许您将列定义为任何有效数据类型的数组，包括内置类型，用户定义类型或枚举类型。</p>
</blockquote>
<blockquote>
<p>下面的CREATE TABLE语句创建具有phones列的表，该列定义为文本数组:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE test15 (</span></span><br><span class="line">   id serial PRIMARY KEY,</span><br><span class="line">   name VARCHAR (100),</span><br><span class="line">   phones TEXT []</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该phones列是一维数组，其中包含联系人可能拥有的各种电话号码。</p>
</blockquote>
<h4 id="插入PostgreSQL数组值"><a href="#插入PostgreSQL数组值" class="headerlink" title="插入PostgreSQL数组值"></a>插入PostgreSQL数组值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test15 (name, phones)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'John'</span>,</span><br><span class="line">      ARRAY [ <span class="string">'(408)-589-5846'</span>,</span><br><span class="line">      <span class="string">'(408)-589-5555'</span> ]</span><br><span class="line">   );</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用ARRAY构造函数构造一个数组并将其插入表中。还可以如下使用花括号：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test15 (name, phones)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'Lily'</span>,</span><br><span class="line">      <span class="string">'&#123;"(408)-589-5841"&#125;'</span></span><br><span class="line">   ),</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'William'</span>,</span><br><span class="line">      <span class="string">'&#123;"(408)-589-5842","(408)-589-58423"&#125;'</span></span><br><span class="line">   );</span><br><span class="line">INSERT 0 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，当使用花括号时，可以使用单引号’将数组包装，将双引号”包裹文本数组项目。</p>
</blockquote>
<h4 id="查询数组数据"><a href="#查询数组数据" class="headerlink" title="查询数组数据"></a>查询数组数据</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   name,</span><br><span class="line">   phones</span><br><span class="line">FROM</span><br><span class="line">   test15;</span><br><span class="line">   name   |              phones</span><br><span class="line">----------+----------------------------------</span><br><span class="line"> John     | &#123;(408)-589-5846,(408)-589-5555&#125;</span><br><span class="line"> Lily     | &#123;(408)-589-5841&#125;</span><br><span class="line"> William  | &#123;(408)-589-5842,(408)-589-58423&#125;</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们使用方括号[]中的下标访问数组元素。默认情况下，PostgreSQL对数组元素使用基于1的编号。这意味着第一个数组元素以数字1开头。假设要获取联系人的姓名和第一个电话号码，我们使用以下查询：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   name,</span><br><span class="line">   phones [ 1 ]</span><br><span class="line">FROM</span><br><span class="line">   test15;</span><br><span class="line">   name   |     phones</span><br><span class="line">----------+----------------</span><br><span class="line"> John     | (408)-589-5846</span><br><span class="line"> Lily     | (408)-589-5841</span><br><span class="line"> William  | (408)-589-5842</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用WHERE子句中的数组元素作为过滤行的条件。例如，要找出谁拥有该电话号码(408)-589-58423 作为第二电话号码，使用以下查询:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   name</span><br><span class="line">FROM</span><br><span class="line">   test15</span><br><span class="line">WHERE</span><br><span class="line">   phones [ 2 ] = <span class="string">'(408)-589-58423'</span>;</span><br><span class="line">  name</span><br><span class="line">---------</span><br><span class="line"> William</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="修改PostgreSQL数组"><a href="#修改PostgreSQL数组" class="headerlink" title="修改PostgreSQL数组"></a>修改PostgreSQL数组</h4><blockquote>
<p>PostgreSQL允许更新数组的每个元素或整个数组。以下语句更新William的第二个电话号码:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE test15</span></span><br><span class="line">SET phones [ 2 ] = <span class="string">'(408)-589-5843'</span></span><br><span class="line">WHERE</span><br><span class="line">   ID = 3;</span><br><span class="line">UPDATE 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   name,</span><br><span class="line">   phones</span><br><span class="line">FROM</span><br><span class="line">   test15</span><br><span class="line">WHERE</span><br><span class="line">   id = 3;</span><br><span class="line">  name   |             phones</span><br><span class="line">---------+---------------------------------</span><br><span class="line"> William | &#123;(408)-589-5842,(408)-589-5843&#125;</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="在PostgreSQL数组中搜索"><a href="#在PostgreSQL数组中搜索" class="headerlink" title="在PostgreSQL数组中搜索"></a>在PostgreSQL数组中搜索</h4><blockquote>
<p>假设我们想知道谁拥有电话号码(408)-589-5555而不管电话号码在phones数组中的位置如何，我们使用ANY()函数:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   name,</span><br><span class="line">   phones</span><br><span class="line">FROM</span><br><span class="line">   test15</span><br><span class="line">WHERE</span><br><span class="line">   <span class="string">'(408)-589-5555'</span> = ANY (phones);</span><br><span class="line">   name   |             phones</span><br><span class="line">----------+---------------------------------</span><br><span class="line"> John     | &#123;(408)-589-5846,(408)-589-5555&#125;</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h3 id="展开阵列"><a href="#展开阵列" class="headerlink" title="展开阵列"></a>展开阵列</h3><blockquote>
<p>PostgreSQL提供了unnest()将数组扩展为行列表的功能。以下查询扩展该phones数组的所有电话号码:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   name,</span><br><span class="line">   unnest(phones)</span><br><span class="line">FROM</span><br><span class="line">   test15;</span><br><span class="line">   name   |     unnest</span><br><span class="line">----------+----------------</span><br><span class="line"> John     | (408)-589-5846</span><br><span class="line"> John     | (408)-589-5555</span><br><span class="line"> Lily     | (408)-589-5841</span><br><span class="line"> William  | (408)-589-5842</span><br><span class="line"> William  | (408)-589-5843</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure>
<h3 id="用户定义的数据类型"><a href="#用户定义的数据类型" class="headerlink" title="用户定义的数据类型"></a>用户定义的数据类型</h3><blockquote>
<p>除内置数据类型外，PostgreSQL还允许您通过以下语句创建用户定义的数据类型：</p>
<ul>
<li>CREATE DOMAIN创建具有约束的用户定义数据类型，例如NOT NULL，CHECK等。</li>
</ul>
<ul>
<li>CREATE TYPE通常用于创建在存储过程中用作返回数据类型的复合类型。</li>
</ul>
</blockquote>
<h4 id="创建域"><a href="#创建域" class="headerlink" title="创建域"></a>创建域</h4><blockquote>
<p>在PostgreSQL中，域是具有可选约束的数据类型，如NOT NULL，CHECK等。域在模式范围内具有唯一名称。</p>
</blockquote>
<blockquote>
<p>域对于集中管理具有公共约束的字段很有用。例如，某些表可能包含要求CHECK约束以确保值不为null且不包含空格的文本列。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE mail_list (</span></span><br><span class="line">    ID SERIAL PRIMARY KEY,</span><br><span class="line">    first_name VARCHAR NOT NULL,</span><br><span class="line">    last_name VARCHAR NOT NULL,</span><br><span class="line">    email VARCHAR NOT NULL,</span><br><span class="line">    CHECK (</span><br><span class="line">        first_name !~ <span class="string">'\s'</span></span><br><span class="line">        AND last_name !~ <span class="string">'\s'</span></span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>first_name和last_name列都不为null，并且不应包含空格。为了简化管理，contact_name可以按以下方式创建域：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE DOMAIN contact_name AS</span></span><br><span class="line">    VARCHAR NOT NULL CHECK (value !~ <span class="string">'\s'</span>);</span><br><span class="line">CREATE DOMAIN</span><br></pre></td></tr></table></figure>
<blockquote>
<p>并使用contact_name作为first_name和last_name列的数据类型：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># drop table mail_list;</span></span><br><span class="line">DROP TABLE</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE mail_list (</span></span><br><span class="line">    id serial PRIMARY KEY,</span><br><span class="line">    first_name contact_name,</span><br><span class="line">    last_name contact_name,</span><br><span class="line">    email VARCHAR NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在mail_list表中插入新行:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO mail_list (first_name, last_name, email)</span></span><br><span class="line">VALUES</span><br><span class="line">    (</span><br><span class="line">        <span class="string">'James V'</span>,</span><br><span class="line">        <span class="string">'Harden'</span>,</span><br><span class="line">        <span class="string">'james@example.com'</span></span><br><span class="line">    );</span><br><span class="line">错误:  域 contact_name 的值违反了检查约束 <span class="string">"contact_name_check"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>要更改或删除域，请分别使用ALTER DOMAIN或DROP DOMAIN。要查看当前数据库中的所有域，请使用\dD命令：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">test</span>=&gt; \dD</span><br><span class="line">                                                    共同值域列表</span><br><span class="line"> 架构模式 |     名称     |       类型        | 校对规则 |  可空的  | 预设 |                  检查                   </span><br><span class="line">----------+--------------+-------------------+----------+----------+------+-----------------------------------------</span><br><span class="line"> public   | contact_name | character varying |          | not null |      | CHECK (VALUE::text !~ <span class="string">'\s'</span>::text)</span><br><span class="line"> public   | year         | <span class="built_in">integer</span>           |          |          |      | CHECK (VALUE &gt;= 1901 AND VALUE &lt;= 2155)</span><br><span class="line">(2 行记录)</span><br></pre></td></tr></table></figure>
<h4 id="创建类型"><a href="#创建类型" class="headerlink" title="创建类型"></a>创建类型</h4><blockquote>
<p>CREATE TYPE语句允许您创建一个复合类型，该复合类型可用作函数的返回类型。</p>
</blockquote>
<blockquote>
<p>假设想要一个返回多个值的函数：film_id，title和release_year。 第一步是创建一个类型，例如film_summary，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TYPE film_summary AS (</span></span><br><span class="line">    film_id INT,</span><br><span class="line">    title VARCHAR,</span><br><span class="line">    release_year YEAR</span><br><span class="line">);</span><br><span class="line">CREATE TYPE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其次，使用film_summary数据类型作为函数的返回类型：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE FUNCTION get_film_summary (f_id INT)</span></span><br><span class="line">    RETURNS film_summary AS</span><br><span class="line">$$</span><br><span class="line">SELECT</span><br><span class="line">    film_id,</span><br><span class="line">    title,</span><br><span class="line">    release_year</span><br><span class="line">FROM</span><br><span class="line">    film</span><br><span class="line">WHERE</span><br><span class="line">    film_id = f_id ;</span><br><span class="line">$$</span><br><span class="line">LANGUAGE SQL;</span><br><span class="line">CREATE FUNCTION</span><br></pre></td></tr></table></figure>
<blockquote>
<p>三，调用get_film_summary()函数：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    get_film_summary (40);</span><br><span class="line"> film_id |      title       | release_year</span><br><span class="line">---------+------------------+--------------</span><br><span class="line">      40 | Army Flintstones |         2006</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要更改类型或删除类型，请分别使用ALTER TYPE或DROP TYPE语句。</p>
</blockquote>
<blockquote>
<p>列出当前数据库中所有用户定义类型的命令是\dT或\dT+：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; \dT</span><br><span class="line">          数据类型列表</span><br><span class="line"> 架构模式 |     名称     | 描述 </span><br><span class="line">----------+--------------+------</span><br><span class="line"> public   | contact_name | </span><br><span class="line"> public   | film_summary | </span><br><span class="line"> public   | mpaa_rating  | </span><br><span class="line"> public   | year         | </span><br><span class="line">(4 行记录)</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=&gt; \dT+</span><br><span class="line">                                    数据类型列表</span><br><span class="line"> 架构模式 |     名称     |   内部名称   | 大小  | 成员  |  拥有者  | 存取权限 | 描述 </span><br><span class="line">----------+--------------+--------------+-------+-------+----------+----------+------</span><br><span class="line"> public   | contact_name | contact_name | var   |       | <span class="built_in">test</span>     |          | </span><br><span class="line"> public   | film_summary | film_summary | tuple |       | <span class="built_in">test</span>     |          | </span><br><span class="line"> public   | mpaa_rating  | mpaa_rating  | 4     | G    +| postgres |          | </span><br><span class="line">          |              |              |       | PG   +|          |          | </span><br><span class="line">          |              |              |       | PG-13+|          |          | </span><br><span class="line">          |              |              |       | R    +|          |          | </span><br><span class="line">          |              |              |       | NC-17 |          |          | </span><br><span class="line"> public   | year         | year         | 4     |       | postgres |          | </span><br><span class="line">(4 行记录)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    
    
    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="zhijiansd.github.io/blog/pg9/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhiJian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhiJian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/pg9/" class="post-title-link" itemprop="zhijiansd.github.io/page/2/index.html">PostgreSQL之管理数据库和表</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-20 12:56:46 / 修改时间：12:58:22" itemprop="dateCreated datePublished" datetime="2020-05-20T12:56:46+08:00">2020-05-20</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/postresql/" itemprop="url" rel="index"><span itemprop="name">postresql</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/pg9/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/pg9/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">55k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1:31</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="管理数据库"><a href="#管理数据库" class="headerlink" title="管理数据库"></a>管理数据库</h2><h3 id="CREATE-DATABASE语句"><a href="#CREATE-DATABASE语句" class="headerlink" title="CREATE DATABASE语句"></a>CREATE DATABASE语句</h3><h4 id="CREATE-DATABASE语法"><a href="#CREATE-DATABASE语法" class="headerlink" title="CREATE DATABASE语法"></a>CREATE DATABASE语法</h4><blockquote>
<p>要创建新的PostgreSQL数据库，请使用CREATE DATABASE语句，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE db_name</span><br><span class="line"> OWNER =  role_name</span><br><span class="line"> TEMPLATE = template</span><br><span class="line"> ENCODING = encoding</span><br><span class="line"> LC_COLLATE = collate</span><br><span class="line"> LC_CTYPE = ctype</span><br><span class="line"> TABLESPACE = tablespace_name</span><br><span class="line"> CONNECTION LIMIT = max_concurrent_connection</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建新数据库时，CREATE DATABASE语句提供了各种选项:</p>
<ul>
<li>db_name：要创建的新数据库的名称。数据库名称在PostgreSQL数据库服务器中必须是唯一的。如果尝试创建一个与现有数据库同名的新数据库，PostgreSQL将发出错误消息。</li>
</ul>
<ul>
<li>role_name：拥有新数据库的用户的角色名称。PostgreSQL使用执行该CREATE DATABASE语句的用户角色名称作为默认角色名称。</li>
</ul>
<ul>
<li>template：是从中创建新数据库的数据库模板的名称。PostgreSQL允许您基于模板数据库创建数据库。template1是默认模板数据库。</li>
</ul>
<ul>
<li>encoding：指定新数据库的字符集编码。默认情况下，它是模板数据库的编码。</li>
</ul>
<ul>
<li>collate：指定新数据库的排序规则。 排序规则指定影响SELECT语句中ORDER BY子句结果的字符串的排序顺序。如果您未在LC_COLLATE参数中明确指定模板数据库的排序规则，则该排序规则是新数据库的默认排序规则。</li>
</ul>
<ul>
<li>ctype：指定新数据库的字符分类。该ctype影响分类例如:digit,lower和upper。默认值为模板数据库的字符分类。</li>
</ul>
<ul>
<li>tablespace_name：指定新数据库的表空间名称。默认值为模板数据库的表空间。</li>
</ul>
<ul>
<li>max_concurrent_connection：指定到新数据库的最大并发连接数。默认值为-1，即无限制。此功能在共享主机环境中非常有用，可以在其中为特定数据库配置最大并发连接数。</li>
</ul>
</blockquote>
<blockquote>
<p>除了CREATE DATABASE语句外，还可以使用createdb程序来创建新数据库。createdb程序在后台使用CREATE DATABASE语句。</p>
</blockquote>
<h4 id="创建数据库示例1"><a href="#创建数据库示例1" class="headerlink" title="创建数据库示例1"></a>创建数据库示例1</h4><blockquote>
<p>创建新数据库的最简单方法是使用所有默认设置，并且仅将数据库名称指定为以下查询：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE testdb1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PostgreSQL创建了一个名为testdb1的新数据库，该数据库具有默认模板数据库（即template1）中的默认参数。</p>
</blockquote>
<h4 id="创建数据库示例2"><a href="#创建数据库示例2" class="headerlink" title="创建数据库示例2"></a>创建数据库示例2</h4><blockquote>
<p>使用以下参数创建新的数据库名称hrdb:</p>
<ul>
<li>编码：utf-8。</li>
</ul>
<ul>
<li>所有者：hr，并假设hr用户存在于数据库服务器中。</li>
</ul>
<ul>
<li>最大并发连接数：25。</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE hrdb</span><br><span class="line"> WITH ENCODING=<span class="string">'UTF8'</span></span><br><span class="line"> OWNER=hr</span><br><span class="line"> CONNECTION LIMIT=25;</span><br></pre></td></tr></table></figure>
<h3 id="ALTER-DATABASE语句"><a href="#ALTER-DATABASE语句" class="headerlink" title="ALTER DATABASE语句"></a>ALTER DATABASE语句</h3><h4 id="ALTER-DATABASE"><a href="#ALTER-DATABASE" class="headerlink" title="ALTER DATABASE"></a>ALTER DATABASE</h4><blockquote>
<p>创建数据库后，可以使用ALTER DATABASE语句更改其功能，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE target_database action;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以在ALTER DATABASE之后指定要更改的数据库名称。PostgreSQL允许对现有数据库执行各种操作。</p>
</blockquote>
<h4 id="重命名数据库"><a href="#重命名数据库" class="headerlink" title="重命名数据库"></a>重命名数据库</h4><blockquote>
<p>要重命名数据库，请使用ALTER DATABASE RENAME TO语句，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE target_database RENAME TO new_database;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要重命名数据库，您必须连接到另一个数据库，例如postgres。</p>
</blockquote>
<h4 id="变更拥有者"><a href="#变更拥有者" class="headerlink" title="变更拥有者"></a>变更拥有者</h4><blockquote>
<p>要更改数据库的所有者，请使用ALTER DATABASE OWNER TO语句:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE target_database OWNER TO new_onwer;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只有数据库的超级用户superuser可以更改数据库的所有者。数据库所有者还必须具有CREATEDB特权才能重命名数据库。</p>
</blockquote>
<h4 id="变更表空间"><a href="#变更表空间" class="headerlink" title="变更表空间"></a>变更表空间</h4><blockquote>
<p>要更改数据库的默认表空间，请按以下方式使用ALTER DATABASE SET TABLESPACE：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE target_database SET TABLESPACE new_tablespace;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该语句将表和索引从旧表空间移到新表空间。</p>
</blockquote>
<h4 id="更改运行时配置变量的会话默认值"><a href="#更改运行时配置变量的会话默认值" class="headerlink" title="更改运行时配置变量的会话默认值"></a>更改运行时配置变量的会话默认值</h4><blockquote>
<p>无论何时连接到数据库，PostgreSQL都会加载postgresql.conf文件中显示的配置变量，并默认使用这些变量。</p>
</blockquote>
<blockquote>
<p>要覆盖特定数据库的这些设置，请使用ALTER DATABASE SET语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE target_database SET configuration_parameter = value;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在随后的会话中，PostgreSQL将覆盖postgresql.conf文件中的设置。</p>
</blockquote>
<blockquote>
<p>请注意，只有超级用户supperuser或数据库所有者才能更改数据库的默认会话变量。</p>
</blockquote>
<h4 id="ALTER-DATABASE示例"><a href="#ALTER-DATABASE示例" class="headerlink" title="ALTER DATABASE示例"></a>ALTER DATABASE示例</h4><blockquote>
<p>首先，以 postgres 用户身份登录并创建一个名为testdb2的新数据库</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE DATABASE testdb2;</span></span><br><span class="line">CREATE DATABASE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其次，使用以下语句将 testdb2 数据库重命名为testhrdb</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># ALTER DATABASE testdb2 RENAME TO testhrdb;</span></span><br><span class="line">ALTER DATABASE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三，创建 hr 角色</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE ROLE hr</span></span><br><span class="line"> VALID UNTIL <span class="string">'infinity'</span>;</span><br><span class="line">CREATE ROLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第四，执行以下语句，将testhrdb数据库的所有者从postgres更改为hr。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># ALTER DATABASE testhrdb OWNER TO hr;</span></span><br><span class="line">ALTER DATABASE</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 第五，创建表空间</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE TABLESPACE hr_default</span></span><br><span class="line"> OWNER hr</span><br><span class="line"> LOCATION <span class="string">'/usr/local/pgdata'</span>;</span><br><span class="line">CREATE TABLESPACE</span><br></pre></td></tr></table></figure>
<ul>
<li>/usr/local/pgdata目录必须存在且归属于postgres用户。</li>
</ul>
<blockquote>
<p>第六，将testhrdb的默认表空间从pg_default更改为hr_default</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># ALTER DATABASE testhrdb</span></span><br><span class="line">SET TABLESPACE hr_default;</span><br><span class="line">ALTER DATABASE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第七，要设置escape_string_warning配置变量为off，可以使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># ALTER DATABASE testhrdb SET escape_string_warning TO off;</span></span><br><span class="line">ALTER DATABASE</span><br></pre></td></tr></table></figure>
<h3 id="ALTER-DATABASE-RENAME-TO-语句"><a href="#ALTER-DATABASE-RENAME-TO-语句" class="headerlink" title="ALTER DATABASE RENAME TO 语句"></a>ALTER DATABASE RENAME TO 语句</h3><h4 id="重命名数据库步骤"><a href="#重命名数据库步骤" class="headerlink" title="重命名数据库步骤"></a>重命名数据库步骤</h4><blockquote>
<p>使用ALTER DATABASE RENAME TO语句重命名PostgreSQL数据库，请使用以下步骤:</p>
<ul>
<li>通过连接到其他数据库，与要重命名的数据库断开连接。</li>
</ul>
<ul>
<li>检查并终止与正在重命名的数据库的所有活动连接。</li>
</ul>
<ul>
<li>使用ALTER DATABASE语句将数据库重命名为新数据库。</li>
</ul>
</blockquote>
<h4 id="重命名数据库示例"><a href="#重命名数据库示例" class="headerlink" title="重命名数据库示例"></a>重命名数据库示例</h4><blockquote>
<p>重命名数据库test为newtest</p>
</blockquote>
<ul>
<li>首先，通过连接到另一个数据库（例如postgres），与要重命名的数据库断开连接。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; \connect postgres;</span><br><span class="line">您现在已经连接到数据库 <span class="string">"postgres"</span>,用户 <span class="string">"test"</span>.</span><br></pre></td></tr></table></figure>
<ul>
<li>接下来，检查与test数据库的所有活动连接:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    pg_stat_activity</span><br><span class="line">WHERE</span><br><span class="line">    datname = <span class="string">'test'</span>;</span><br><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">    pid</span><br><span class="line">FROM</span><br><span class="line">    pg_stat_activity</span><br><span class="line">WHERE</span><br><span class="line">    datname = <span class="string">'test'</span>;</span><br><span class="line">  pid</span><br><span class="line">-------</span><br><span class="line"> 71941</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<ul>
<li>这里可能会发现要重命名的数据库具有许多活动连接。在这种情况下，您需要在终止连接之前通知各个用户以及应用程序所有者，以避免数据丢失。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">    pg_terminate_backend (pid)</span><br><span class="line">FROM</span><br><span class="line">    pg_stat_activity</span><br><span class="line">WHERE</span><br><span class="line">    datname = <span class="string">'test'</span>;</span><br><span class="line"> pg_terminate_backend</span><br><span class="line">----------------------</span><br><span class="line"> t</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<ul>
<li>重命名数据库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># ALTER DATABASE test RENAME TO newtest;</span></span><br><span class="line">ALTER DATABASE</span><br></pre></td></tr></table></figure>
<ul>
<li>重登录数据库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># psql -h 192.168.100.133 -U test -d newtest</span></span><br><span class="line">用户 <span class="built_in">test</span> 的口令：</span><br><span class="line">psql (12.1)</span><br><span class="line">输入 <span class="string">"help"</span> 来获取帮助信息.</span><br><span class="line"></span><br><span class="line">newtest=&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-h指定数据库IP，-U指定用户名，-d指定需要登录的数据库(默认用户名即数据库名)</p>
</blockquote>
<h3 id="DROP-DATABASE-语句"><a href="#DROP-DATABASE-语句" class="headerlink" title="DROP DATABASE 语句"></a>DROP DATABASE 语句</h3><blockquote>
<p>一旦不再需要数据库，可以使用DROP DATABASE语句将其删除。</p>
</blockquote>
<h4 id="DROP-DATABASE语法"><a href="#DROP-DATABASE语法" class="headerlink" title="DROP DATABASE语法"></a>DROP DATABASE语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE [IF EXISTS] name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要删除数据库:</p>
<ul>
<li>在DROP DATABASE子句之后，指定要删除的数据库的名称。</li>
</ul>
<ul>
<li>使用IF EXISTS可以防止错误删除不存在的数据库，PostgreSQL将发出通知。</li>
</ul>
</blockquote>
<blockquote>
<p>DROP DATABASE语句永久删除目录条目和数据目录。此操作无法撤消，因此必须谨慎使用。</p>
</blockquote>
<blockquote>
<p>只有数据库所有者才能执行DROP DATABASE语句。此外，如果与数据库有任何活动连接，则无法执行DROP DATABASE语句。必须连接到另一个数据库（例如postgresql）才能执行DROP DATABASE语句。</p>
</blockquote>
<blockquote>
<p>PostgreSQL还提供了一个名为dropdb的实用程序来删除数据库。dropdb程序在后台执行DROP DATABASE语句。</p>
</blockquote>
<h4 id="删除具有活动连接的数据库"><a href="#删除具有活动连接的数据库" class="headerlink" title="删除具有活动连接的数据库"></a>删除具有活动连接的数据库</h4><blockquote>
<p>要删除仍具有活动连接的数据库，可以按照以下步骤操作:</p>
</blockquote>
<ul>
<li>首先，找到针对目标数据库进行的活动，可以通过以下查询pg_stat_activity查询该视图:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   pg_stat_activity</span><br><span class="line">WHERE</span><br><span class="line">   datname = <span class="string">'testhrdb'</span>;</span><br><span class="line"> datid | datname  |  pid  | usesysid | usename | application_name |   client_addr   | client_hostname | client_port |         backend_start         | xact_start | query_start |         state_change          | wait_event_type | wait_event | state | backend_xid | backend_xmin | query |  backend_type</span><br><span class="line">-------+----------+-------+----------+---------+------------------+-----------------+-----------------+-------------+-------------------------------+------------+-------------+-------------------------------+-----------------+------------+-------+-------------+--------------+-------+----------------</span><br><span class="line"> 17722 | testhrdb | 77367 |    16384 | <span class="built_in">test</span>    | psql             | 192.168.100.133 |                 |       41814 | 2019-11-27 11:32:02.213662+08 |            |             | 2019-11-27 11:32:02.231687+08 | Client          | ClientRead | idle  |             |              |       | client backend</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<ul>
<li>其次，通过发出以下查询来终止活动连接:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   pg_terminate_backend (pg_stat_activity.pid)</span><br><span class="line">FROM</span><br><span class="line">   pg_stat_activity</span><br><span class="line">WHERE</span><br><span class="line">   pg_stat_activity.datname = <span class="string">'testhrdb'</span>;</span><br><span class="line"> pg_terminate_backend</span><br><span class="line">----------------------</span><br><span class="line"> t</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<ul>
<li>第三，执行DROP DATABASE语句:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># DROP DATABASE testhrdb;</span></span><br><span class="line">DROP DATABASE</span><br></pre></td></tr></table></figure>
<h4 id="DROP-DATABASE示例"><a href="#DROP-DATABASE示例" class="headerlink" title="DROP DATABASE示例"></a>DROP DATABASE示例</h4><h5 id="创建示例数据库"><a href="#创建示例数据库" class="headerlink" title="创建示例数据库"></a>创建示例数据库</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE DATABASE hrdb;</span></span><br><span class="line">CREATE DATABASE testdb1;</span><br><span class="line">CREATE DATABASE</span><br><span class="line"></span><br><span class="line">CREATE DATABASE</span><br></pre></td></tr></table></figure>
<h5 id="删除没有活动连接的数据库"><a href="#删除没有活动连接的数据库" class="headerlink" title="删除没有活动连接的数据库"></a>删除没有活动连接的数据库</h5><blockquote>
<p>要删除hrdb数据库，请使用hrdb所有者连接到hrdb数据库以外的数据库，如postgres并执行以下语句:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># DROP DATABASE hrdb;</span></span><br><span class="line">DROP DATABASE</span><br></pre></td></tr></table></figure>
<h5 id="删除具有活动连接的数据库-1"><a href="#删除具有活动连接的数据库-1" class="headerlink" title="删除具有活动连接的数据库"></a>删除具有活动连接的数据库</h5><ul>
<li>删除数据库时PostgreSQL发出错误信息:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># DROP DATABASE testdb1;</span></span><br><span class="line">错误:  其他用户正在使用数据库 <span class="string">"testdb1"</span></span><br><span class="line">DETAIL:  那里有1个其它会话正在使用数据库.</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，查询pg_stat_activity视图以查找针对testdb1数据库正在发生的活动:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   pg_stat_activity</span><br><span class="line">WHERE</span><br><span class="line">   datname = <span class="string">'testdb1'</span>;</span><br><span class="line"> datid | datname |  pid  | usesysid | usename | application_name |   client_addr   | client_hostname | client_port |         backend_start         | xact_start | query_start |         state_change          | wait_event_type | wait_event | state | backend_xid | backend_xmin | query |  backend_type</span><br><span class="line">-------+---------+-------+----------+---------+------------------+-----------------+-----------------+-------------+-------------------------------+------------+-------------+-------------------------------+-----------------+------------+-------+-------------+--------------+-------+----------------</span><br><span class="line"> 17730 | testdb1 | 79644 |    16384 | <span class="built_in">test</span>    | psql             | 192.168.100.133 |                 |       41834 | 2019-11-27 12:14:49.143804+08 |            |             | 2019-11-27 12:14:49.160428+08 | Client          | ClientRead | idle  |             |              |       | client backend</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<ul>
<li>终止与数据库的连接</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   pg_terminate_backend (pg_stat_activity.pid)</span><br><span class="line">FROM</span><br><span class="line">   pg_stat_activity</span><br><span class="line">WHERE</span><br><span class="line">   pg_stat_activity.datname = <span class="string">'testdb1'</span>;</span><br><span class="line"> pg_terminate_backend</span><br><span class="line">----------------------</span><br><span class="line"> t</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用DROP DATABASE命令删除testdb1数据库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># DROP DATABASE testdb1;</span></span><br><span class="line">DROP DATABASE</span><br></pre></td></tr></table></figure>
<h3 id="复制数据库"><a href="#复制数据库" class="headerlink" title="复制数据库"></a>复制数据库</h3><h4 id="复制同一服务器内的数据库"><a href="#复制同一服务器内的数据库" class="headerlink" title="复制同一服务器内的数据库"></a>复制同一服务器内的数据库</h4><blockquote>
<p>通过CREATE DATABASE语句来进行复制</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE targetdb </span><br><span class="line">WITH TEMPLATE sourcedb;</span><br></pre></td></tr></table></figure>
<ul>
<li>该语句将sourcedb数据库复制到targetdb数据库。</li>
</ul>
<blockquote>
<p>将test数据库复制到newtest数据库</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE DATABASE newtest </span></span><br><span class="line">WITH TEMPLATE <span class="built_in">test</span>;</span><br><span class="line">CREATE DATABASE</span><br></pre></td></tr></table></figure>
<h4 id="将数据库从服务器复制到另一个服务器"><a href="#将数据库从服务器复制到另一个服务器" class="headerlink" title="将数据库从服务器复制到另一个服务器"></a>将数据库从服务器复制到另一个服务器</h4><blockquote>
<p>这里将源数据库转储到文件中，然后将文件复制到远程服务器上并进行还原。</p>
</blockquote>
<h5 id="复制步骤"><a href="#复制步骤" class="headerlink" title="复制步骤"></a>复制步骤</h5><ul>
<li>首先，将源数据库转储到文件中。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pg_dump -U postgres -O sourcedb sourcedb.sql</span><br></pre></td></tr></table></figure>
<ul>
<li>其次，将转储文件复制到远程服务器。</li>
</ul>
<ul>
<li>第三，在远程服务器上创建一个新数据库:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE targetdb;</span><br></pre></td></tr></table></figure>
<ul>
<li>第四，还原远程服务器上的转储文件:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql -U postgres -d targetdb -f sourcedb.sql</span><br></pre></td></tr></table></figure>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><blockquote>
<p>将test数据库从本地服务器复制到remote服务器</p>
</blockquote>
<ul>
<li>首先，将test数据库转储到备份文件中，例如test.sql</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pg_dump -U postgres -d test -f test.sql</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>pg_dump把一个数据库转储为纯文本文件或者是其它格式，-U 指定数据库用户名，-d 指定需要备份的数据库，-f 指定输出备份文件的文件名或路径。</p>
</blockquote>
<ul>
<li>其次，将备份文件复制到remote服务器</li>
</ul>
<ul>
<li>第三，在remote服务器上创建test数据库:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE DATABASE test;</span></span><br><span class="line">CREATE DATABASE</span><br></pre></td></tr></table></figure>
<ul>
<li>第四，还原remote服务器中的test.sql:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># psql -U postgres -d test -f test.sql</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果服务器之间的连接速度很快并且数据库文件不大，则可以使用以下命令:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># psql -h 192.168.100.128 -p 32271 -U postgres -d test -f test.sql</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>-h 指定remote服务器IP，-p 指定其数据库端口，-U 指定数据库用户名，-d 指定数据库，-f 指定备份文件路径。</p>
</blockquote>
<h3 id="获取数据库对象大小"><a href="#获取数据库对象大小" class="headerlink" title="获取数据库对象大小"></a>获取数据库对象大小</h3><h4 id="PostgreSQL表大小"><a href="#PostgreSQL表大小" class="headerlink" title="PostgreSQL表大小"></a>PostgreSQL表大小</h4><blockquote>
<p>要获取特定表的大小，请使用pg_relation_size()函数</p>
</blockquote>
<ul>
<li>在test数据库中获取film表的大小</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># select pg_relation_size('film');</span></span><br><span class="line"> pg_relation_size</span><br><span class="line">------------------</span><br><span class="line">           442368</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该pg_relation_size()函数以字节为单位返回特定表的大小。</p>
</blockquote>
<blockquote>
<p>为了使结果更易于阅读，可以使用pg_size_pretty()函数。该pg_size_pretty()函数采用另一个函数的结果，并根据需要使用字节，KB，MB，GB或TB对其进行格式化。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    pg_size_pretty (pg_relation_size(<span class="string">'film'</span>));</span><br><span class="line"> pg_size_pretty</span><br><span class="line">----------------</span><br><span class="line"> 432 kB</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该pg_relation_size()函数仅返回表的大小，不包括索引或其他对象。</p>
</blockquote>
<blockquote>
<p>要获取表的总大小，请使用pg_total_relation_size()函数。</p>
</blockquote>
<ul>
<li>获取film表的总大小</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    pg_size_pretty (</span><br><span class="line">        pg_total_relation_size (<span class="string">'film'</span>)</span><br><span class="line">    );</span><br><span class="line"> pg_size_pretty</span><br><span class="line">----------------</span><br><span class="line"> 688 kB</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<ul>
<li>查询test数据库中的前5个最大表</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    relname AS <span class="string">"relation"</span>,</span><br><span class="line">    pg_size_pretty (</span><br><span class="line">        pg_total_relation_size (C .oid)</span><br><span class="line">    ) AS <span class="string">"total_size"</span></span><br><span class="line">FROM</span><br><span class="line">    pg_class C</span><br><span class="line">LEFT JOIN pg_namespace N ON (N.oid = C .relnamespace)</span><br><span class="line">WHERE</span><br><span class="line">    nspname NOT IN (</span><br><span class="line">        <span class="string">'pg_catalog'</span>,</span><br><span class="line">        <span class="string">'information_schema'</span></span><br><span class="line">    )</span><br><span class="line">AND C .relkind &lt;&gt; <span class="string">'i'</span></span><br><span class="line">AND nspname !~ <span class="string">'^pg_toast'</span></span><br><span class="line">ORDER BY</span><br><span class="line">    pg_total_relation_size (C .oid) DESC</span><br><span class="line">LIMIT 5;</span><br><span class="line">  relation  | total_size</span><br><span class="line">------------+------------</span><br><span class="line"> rental     | 2472 kB</span><br><span class="line"> payment    | 2232 kB</span><br><span class="line"> film       | 688 kB</span><br><span class="line"> film_actor | 536 kB</span><br><span class="line"> inventory  | 464 kB</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure>
<h4 id="PostgreSQL数据库大小"><a href="#PostgreSQL数据库大小" class="headerlink" title="PostgreSQL数据库大小"></a>PostgreSQL数据库大小</h4><blockquote>
<p>要获取整个数据库的大小，请使用pg_database_size()函数。</p>
</blockquote>
<ul>
<li>查询test数据库的大小</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    pg_size_pretty (</span><br><span class="line">        pg_database_size (<span class="string">'test'</span>)</span><br><span class="line">    );</span><br><span class="line"> pg_size_pretty</span><br><span class="line">----------------</span><br><span class="line"> 17 MB</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<ul>
<li>获取当前数据库服务器中每个数据库的大小</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    pg_database.datname,</span><br><span class="line">    pg_size_pretty(pg_database_size(pg_database.datname)) AS size</span><br><span class="line">    FROM pg_database;</span><br><span class="line">  datname  |  size</span><br><span class="line">-----------+---------</span><br><span class="line"> postgres  | 8193 kB</span><br><span class="line"> template1 | 8193 kB</span><br><span class="line"> template0 | 8049 kB</span><br><span class="line"> db        | 8193 kB</span><br><span class="line"> <span class="built_in">test</span>      | 17 MB</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure>
<h4 id="PostgreSQL索引大小"><a href="#PostgreSQL索引大小" class="headerlink" title="PostgreSQL索引大小"></a>PostgreSQL索引大小</h4><blockquote>
<p>要获取连接到表的所有索引的总大小，请使用pg_indexes_size()函数。pg_indexes_size()函数接受OID或表名作为参数，并返回该表附加的所有索引使用的总磁盘空间。</p>
</blockquote>
<ul>
<li>获取附加到film表的所有索引的总大小</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    pg_size_pretty (pg_indexes_size(<span class="string">'film'</span>));</span><br><span class="line"> pg_size_pretty</span><br><span class="line">----------------</span><br><span class="line"> 224 kB</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="PostgreSQL表空间大小"><a href="#PostgreSQL表空间大小" class="headerlink" title="PostgreSQL表空间大小"></a>PostgreSQL表空间大小</h4><blockquote>
<p>要获取表空间的大小，请使用pg_tablespace_size()函数。该pg_tablespace_size()函数接受表空间名称，并以字节为单位返回大小。</p>
</blockquote>
<ul>
<li>以下语句返回pg_default表空间的大小:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    pg_size_pretty (</span><br><span class="line">        pg_tablespace_size (<span class="string">'pg_default'</span>)</span><br><span class="line">    );</span><br><span class="line"> pg_size_pretty</span><br><span class="line">----------------</span><br><span class="line"> 49 MB</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="PostgreSQL值大小"><a href="#PostgreSQL值大小" class="headerlink" title="PostgreSQL值大小"></a>PostgreSQL值大小</h4><blockquote>
<p>若要查找需要存储特定值的空间，请使用pg_column_size()函数。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># select pg_column_size(5::smallint);</span></span><br><span class="line"> pg_column_size</span><br><span class="line">----------------</span><br><span class="line">              2</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># select pg_column_size(5::int);</span></span><br><span class="line"> pg_column_size</span><br><span class="line">----------------</span><br><span class="line">              4</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># select pg_column_size(5::bigint);</span></span><br><span class="line"> pg_column_size</span><br><span class="line">----------------</span><br><span class="line">              8</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h2 id="管理表"><a href="#管理表" class="headerlink" title="管理表"></a>管理表</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><blockquote>
<p>PostgreSQL支持以下数据类型:</p>
<ul>
<li>布尔型</li>
</ul>
<ul>
<li>字符类型，例如char，varchar和text。</li>
</ul>
<ul>
<li>数值类型，例如整数和浮点数。</li>
</ul>
<ul>
<li>时间类型，例如date, time, timestamp和interval</li>
</ul>
<ul>
<li>用于存储通用唯一标识符的UUID</li>
</ul>
<ul>
<li>用于存储数组字符串，数字等的数组</li>
</ul>
<ul>
<li>JSON存储JSON数据</li>
</ul>
<ul>
<li>hstore存储键值对</li>
</ul>
<ul>
<li>特殊类型，例如网络地址和几何数据。</li>
</ul>
</blockquote>
<h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><blockquote>
<p>布尔数据类型可以包含三个可能的值之一：true，false或null。您可以使用boolean或bool关键字来声明具有Boolean数据类型的列。</p>
</blockquote>
<blockquote>
<p>当您将数据插入Boolean列时，PostgreSQL将其转换为布尔值，例如1，yes，y，t，true转换为true，0，no，n false，f转换为false。</p>
</blockquote>
<blockquote>
<p>当您从布尔值列中选择数据时，PostgreSQL会将值转换回，例如，t转换为true，f转换为false，空格转换为null。</p>
</blockquote>
<h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><blockquote>
<p>PostgreSQL提供三种字符数据类型：CHAR(n)，VARCHAR(n)和TEXT:</p>
<ul>
<li>CHAR(n)是定长字符，带有空格。如果插入的字符串短于该列的长度，则PostgreSQL将填充空格。如果插入的字符串长于该列的长度，则PostgreSQL将发出错误。</li>
</ul>
<ul>
<li>VARCHAR(n)是长度可变的字符串。使用VARCHAR(n)，最多可以存储n个字符。当存储的字符串短于该列的长度时，PostgreSQL不填充空格。</li>
</ul>
<ul>
<li>TEXT是变长字符串。从理论上讲，文本数据是长度不受限制的字符串。</li>
</ul>
</blockquote>
<h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><blockquote>
<p>PostgreSQL提供两种不同的数字类型:整数和浮点数。</p>
</blockquote>
<blockquote>
<p>PostgreSQL中有三种整数:</p>
<ul>
<li>小整数(SMALLINT)是2字节有符号整数，范围为-32768到32767。</li>
</ul>
<ul>
<li>整数(INT)是一个4字节整数，范围为-2147483648至2147483647。</li>
</ul>
<ul>
<li>Serial与整数相同，PostgreSQL将自动生成值并将其填充到SERIAL列中。这类似于MySQL中的AUTO_INCREMENT列或SQLite中的AUTOINCREMENT列。</li>
</ul>
</blockquote>
<blockquote>
<p>有三种主要类型的浮点数:</p>
<ul>
<li>float(n)是一个浮点数，其精度至少为n，最大为8个字节。</li>
</ul>
<ul>
<li>real或float8是一个4字节的浮点数。</li>
</ul>
<ul>
<li>numeric或numeric(p,s)是p位的小数点后为s的实数。数字(p,s)是确切的数字。</li>
</ul>
</blockquote>
<h4 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h4><blockquote>
<p>PostgreSQL有五种主要的时间数据类型:</p>
<ul>
<li>DATE仅存储日期。</li>
</ul>
<ul>
<li>TIME存储一天中的时间值。</li>
</ul>
<ul>
<li>TIMESTAMP同时存储日期和时间值。</li>
</ul>
<ul>
<li>TIMESTAMPTZ是可识别时区的时间戳数据类型。这是带有时区的时间戳的缩写。</li>
</ul>
<ul>
<li>INTERVAL存储时间段。<br>TIMESTAMPTZ是PostgreSQL对SQL标准的时态数据类型的扩展。</li>
</ul>
</blockquote>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><blockquote>
<p>在PostgreSQL中，您可以在数组列中存储字符串数组，整数数组等。如，存储一周中的某几天，一年中的几个月。</p>
</blockquote>
<h4 id="JSON格式"><a href="#JSON格式" class="headerlink" title="JSON格式"></a>JSON格式</h4><blockquote>
<p>PostgreSQL提供两种JSON数据类型:JSON和JSONB，用于存储JSON数据。</p>
</blockquote>
<blockquote>
<p>JSON数据类型存储需要为每个处理重新解析的纯JSON数据，而JSONB数据类型以二进制格式存储JSON数据，该二进制格式处理速度更快，但插入速度较慢。另外，JSONB支持索引编制，这可能是一个优势。</p>
</blockquote>
<h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><blockquote>
<p>UUID数据类型允许您存储RFC 4122定义的通用唯一标识符。与SERIAL相比，UUID值可确保更好的唯一性，并且可用于隐藏向公众公开的敏感数据，例如URL中的id值。</p>
</blockquote>
<h4 id="特殊数据类型"><a href="#特殊数据类型" class="headerlink" title="特殊数据类型"></a>特殊数据类型</h4><blockquote>
<p>除原始数据类型外，PostgreSQL还提供了几种与几何和网络有关的特殊数据类型:</p>
<ul>
<li>box – 一个矩形框。</li>
</ul>
<ul>
<li>line – 一组点。</li>
</ul>
<ul>
<li>point – 几何数字对。</li>
</ul>
<ul>
<li>lseg – 线段。</li>
</ul>
<ul>
<li>polygon – 封闭的几何图形。</li>
</ul>
<ul>
<li>inet – IP4地址。</li>
</ul>
<ul>
<li>macaddr – MAC地址。</li>
</ul>
</blockquote>
<h3 id="CREATE-TABLE语句"><a href="#CREATE-TABLE语句" class="headerlink" title="CREATE TABLE语句"></a>CREATE TABLE语句</h3><blockquote>
<p>要在PostgreSQL中创建新表，请使用CREATE TABLE语句。</p>
</blockquote>
<h4 id="CREATE-TABLE语法"><a href="#CREATE-TABLE语法" class="headerlink" title="CREATE TABLE语法"></a>CREATE TABLE语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name (</span><br><span class="line">   column_name TYPE column_constraint,</span><br><span class="line">   table_constraint table_constraint</span><br><span class="line">) INHERITS existing_table_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，在CREATE TABLE子句之后指定新表的名称。 </li>
</ul>
<ul>
<li>接下来，列出列名称，其数据类型和列约束。一个表可能有多个以逗号(,)分隔的列。列约束定义了列的规则，例如NOT NULL。</li>
</ul>
<ul>
<li>然后，在列列表之后，定义一个表级约束，该约束定义了表中数据的规则。</li>
</ul>
<ul>
<li>之后，指定一个新表继承现有表。这意味着新表包含现有表的所有列以及CREATE TABLE语句中定义的列。这是PostgreSQL对SQL的扩展。</li>
</ul>
<h4 id="PostgreSQL列约束"><a href="#PostgreSQL列约束" class="headerlink" title="PostgreSQL列约束"></a>PostgreSQL列约束</h4><blockquote>
<p>以下是PostgreSQL中常用的列约束：</p>
<ul>
<li>NOT NULL – 列的值不能为NULL。</li>
</ul>
<ul>
<li>UNIQUE – 列的值在整个表中必须是唯一的。但是，该列可以具有许多NULL值，因为PostgreSQL将每个NULL值都视为唯一。注意，SQL标准仅在具有UNIQUE约束的列中允许一个NULL值。</li>
</ul>
<ul>
<li>PRIMARY KEY – 此约束是NOT NULL和UNIQUE约束的组合。可以使用列级约束将一列定义为PRIMARY KEY。如果主键包含多个列，则必须使用表级约束。</li>
</ul>
<ul>
<li>CHECK – 可以在插入或更新数据时检查条件。如，产品表的价格列中的值必须为正值。</li>
</ul>
<ul>
<li>REFERENCES – 约束存在于另一个表的列中的列的值。可以使用REFERENCES定义外键约束。</li>
</ul>
</blockquote>
<h4 id="PostgreSQL表约束"><a href="#PostgreSQL表约束" class="headerlink" title="PostgreSQL表约束"></a>PostgreSQL表约束</h4><blockquote>
<p>表约束与列约束类似，不同之处在于它们适用于整个表而不是单个列。以下是表约束：</p>
<ul>
<li>UNIQUE(column_list) – 强制存储在括号内列出的列中的值唯一。</li>
</ul>
<ul>
<li>PRIMARY KEY(column_list) – 定义由多个列组成的主键。</li>
</ul>
<ul>
<li>CHECK(condition) – 在插入或更新数据时检查条件。</li>
</ul>
<ul>
<li>REFERENCES – 限制存储在另一表的列中必须存在的列中的值。</li>
</ul>
</blockquote>
<h4 id="CREATE-TABLE示例1"><a href="#CREATE-TABLE示例1" class="headerlink" title="CREATE TABLE示例1"></a>CREATE TABLE示例1</h4><blockquote>
<p>创建一个名为account的表，该表具有以下带有相应约束的列:</p>
<ul>
<li>user_id – 主键</li>
</ul>
<ul>
<li>用户名 – 唯一且不为空</li>
</ul>
<ul>
<li>密码 – 不为空</li>
</ul>
<ul>
<li>电子邮件 – 唯一且不为空</li>
</ul>
<ul>
<li>created_on – 不为空</li>
</ul>
<ul>
<li>last_login – 可为空</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE account(</span></span><br><span class="line">   user_id serial PRIMARY KEY,</span><br><span class="line">   username VARCHAR (50) UNIQUE NOT NULL,</span><br><span class="line">   password VARCHAR (50) NOT NULL,</span><br><span class="line">   email VARCHAR (355) UNIQUE NOT NULL,</span><br><span class="line">   created_on TIMESTAMP NOT NULL,</span><br><span class="line">   last_login TIMESTAMP</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<h4 id="CREATE-TABLE示例2"><a href="#CREATE-TABLE示例2" class="headerlink" title="CREATE TABLE示例2"></a>CREATE TABLE示例2</h4><blockquote>
<p>创建一个名为role的表，其由两列组成:role_id和role_name。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE role(</span></span><br><span class="line">   role_id serial PRIMARY KEY,</span><br><span class="line">   role_name VARCHAR (255) UNIQUE NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<h4 id="CREATE-TABLE示例3"><a href="#CREATE-TABLE示例3" class="headerlink" title="CREATE TABLE示例3"></a>CREATE TABLE示例3</h4><blockquote>
<p>创建名为account_roles的表，其有三列组成:user_id，role_id和grant_date。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE account_role</span></span><br><span class="line">(</span><br><span class="line">  user_id <span class="built_in">integer</span> NOT NULL,</span><br><span class="line">  role_id <span class="built_in">integer</span> NOT NULL,</span><br><span class="line">  grant_date timestamp without time zone,</span><br><span class="line">  PRIMARY KEY (user_id, role_id),</span><br><span class="line">  CONSTRAINT account_role_role_id_fkey FOREIGN KEY (role_id)</span><br><span class="line">      REFERENCES role (role_id) MATCH SIMPLE</span><br><span class="line">      ON UPDATE NO ACTION ON DELETE NO ACTION,</span><br><span class="line">  CONSTRAINT account_role_user_id_fkey FOREIGN KEY (user_id)</span><br><span class="line">      REFERENCES account (user_id) MATCH SIMPLE</span><br><span class="line">      ON UPDATE NO ACTION ON DELETE NO ACTION</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该 account_role 表的主键由两列组成：user_id 和role_id。</p>
<ul>
<li>使用主键表级约束来定义主键: PRIMARY KEY (user_id, role_id)</li>
</ul>
<ul>
<li>因为user_id列引用了account表中的user_id列，所以需要为user_id列定义外键约束：</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONSTRAINT account_role_user_id_fkey FOREIGN KEY (user_id)</span><br><span class="line">      REFERENCES account (user_id) MATCH SIMPLE</span><br><span class="line">      ON UPDATE NO ACTION ON DELETE NO ACTION</span><br></pre></td></tr></table></figure>
<ul>
<li>role_id列引用role表中的role_id列，还需要为该role_id列定义外键约束:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONSTRAINT account_role_role_id_fkey FOREIGN KEY (role_id)</span><br><span class="line">      REFERENCES role (role_id) MATCH SIMPLE</span><br><span class="line">      ON UPDATE NO ACTION ON DELETE NO ACTION,</span><br></pre></td></tr></table></figure>
<h3 id="SELECT-INTO语句"><a href="#SELECT-INTO语句" class="headerlink" title="SELECT INTO语句"></a>SELECT INTO语句</h3><blockquote>
<p>SELECT INTO语句允许创建一个新表并插入查询返回的数据。新表列具有与SELECT子句的输出列关联的名称和数据类型。与SELECT语句不同，SELECT INTO语句不会将数据返回给客户端。</p>
</blockquote>
<h4 id="SELECT-INTO语句语法"><a href="#SELECT-INTO语句语法" class="headerlink" title="SELECT INTO语句语法"></a>SELECT INTO语句语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    column_list</span><br><span class="line">INTO [ TEMPORARY | TEMP | UNLOGGED ] [ TABLE ] new_table_name</span><br><span class="line">FROM</span><br><span class="line">    table_name</span><br><span class="line">WHERE</span><br><span class="line">    condition;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要创建具有从结果集中派生的结构和数据的新表，请在INTO子句中指定新表名。</p>
</blockquote>
<blockquote>
<p>TEMP或TEMPORARY关键字是可选的； 它允许您创建一个临时表。</p>
</blockquote>
<blockquote>
<p>UNLOGGED关键字（如果可用）将使新表成为未记录表。</p>
</blockquote>
<blockquote>
<p>WHERE子句允许您从原始表中指定应插入新表中的数据。除了WHERE子句外，还可以将SELECT语句中的其他子句用于SELECT INTO语句，例如INNER JOIN，LEFT JOIN，GROUP BY和HAVING。</p>
</blockquote>
<blockquote>
<p>请注意，您不能在PL / pgSQL或ECPG中使用SELECT INTO语句，因为它们对INTO子句的解释不同。在这种情况下，可以使用CREATE TABLE AS语句，该语句比SELECT INTO语句提供更多的功能。</p>
</blockquote>
<h4 id="SELECT-INTO示例1"><a href="#SELECT-INTO示例1" class="headerlink" title="SELECT INTO示例1"></a>SELECT INTO示例1</h4><blockquote>
<p>创建一个名为film_r的新表且该表包含所有评级为R且租期大于5天的film表中的电影</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    film_id,</span><br><span class="line">    title,</span><br><span class="line">    rental_rate</span><br><span class="line">INTO TABLE film_r</span><br><span class="line">FROM</span><br><span class="line">    film</span><br><span class="line">WHERE</span><br><span class="line">    rating = <span class="string">'R'</span></span><br><span class="line">AND rental_duration = 5</span><br><span class="line">ORDER BY</span><br><span class="line">    title;</span><br><span class="line">SELECT 40</span><br></pre></td></tr></table></figure>
<blockquote>
<p>验证表的创建</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    film_r;</span><br><span class="line"> film_id |          title          | rental_rate</span><br><span class="line">---------+-------------------------+-------------</span><br><span class="line">      54 | Banger Pinocchio        |        0.99</span><br><span class="line">     115 | Campus Remember         |        2.99</span><br><span class="line">     138 | Chariots Conspiracy     |        2.99</span><br><span class="line">     159 | Closer Bang             |        4.99</span><br><span class="line">     168 | Comancheros Enemy       |        0.99</span><br><span class="line">     246 | Doubtfire Labyrinth     |        4.99</span><br><span class="line">     287 | Entrapment Satisfaction |        0.99</span><br><span class="line">     296 | Express Lonely          |        2.99</span><br><span class="line">     310 | Fever Empire            |        4.99</span><br><span class="line">     316 | Fire Wolves             |        4.99</span><br><span class="line">     339 | Frogmen Breaking        |        0.99</span><br><span class="line">     356 | Giant Troopers          |        2.99</span><br><span class="line">     358 | Gilmore Boiled          |        0.99</span><br><span class="line">     372 | Graceland Dynamite      |        4.99</span><br><span class="line">     384 | Grosse Wonderful        |        4.99</span><br><span class="line">     406 | Haunting Pianist        |        0.99</span><br><span class="line">     427 | Homeward Cider          |        0.99</span><br><span class="line">     447 | Ice Crossing            |        2.99</span><br><span class="line">     493 | Kane Exorcist           |        0.99</span><br><span class="line">     543 | Madigan Dorado          |        4.99</span><br><span class="line">     640 | Opus Ice                |        4.99</span><br><span class="line">     686 | Pluto Oleander          |        4.99</span><br><span class="line">     707 | Quest Mussolini         |        2.99</span><br><span class="line">     724 | Remember Diary          |        2.99</span><br><span class="line">     747 | Roxanne Rebel           |        0.99</span><br><span class="line">     788 | Ship Wonderland         |        2.99</span><br><span class="line">     808 | Sling Luke              |        0.99</span><br><span class="line">     833 | Splendor Patton         |        0.99</span><br><span class="line">     838 | Stagecoach Armageddon   |        4.99</span><br><span class="line">     840 | Stampede Disturbing     |        0.99</span><br><span class="line">     856 | Streetcar Intentions    |        4.99</span><br><span class="line">     858 | Submarine Bed           |        4.99</span><br><span class="line">     863 | Sun Confessions         |        0.99</span><br><span class="line">     884 | Terminator Club         |        4.99</span><br><span class="line">     890 | Tights Dawn             |        0.99</span><br><span class="line">     935 | Vanished Garden         |        0.99</span><br><span class="line">     945 | Virginian Pluto         |        0.99</span><br><span class="line">     967 | Weekend Personal        |        2.99</span><br><span class="line">     995 | Yentl Idaho             |        4.99</span><br><span class="line">     999 | Zoolander Fiction       |        2.99</span><br><span class="line">(40 rows)</span><br></pre></td></tr></table></figure>
<h4 id="SELECT-INTO示例2"><a href="#SELECT-INTO示例2" class="headerlink" title="SELECT INTO示例2"></a>SELECT INTO示例2</h4><blockquote>
<p>创建一个名为short_film的临时表，该表包含所有长度在60分钟以下的电影。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    film_id,</span><br><span class="line">    title,</span><br><span class="line">    length</span><br><span class="line">INTO TEMP TABLE short_film</span><br><span class="line">FROM</span><br><span class="line">    film</span><br><span class="line">WHERE</span><br><span class="line">    length &lt; 60</span><br><span class="line">ORDER BY</span><br><span class="line">    title;</span><br><span class="line">SELECT 96</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   short_film;</span><br><span class="line"> film_id |        title         | length </span><br><span class="line">---------+----------------------+--------</span><br><span class="line">       2 | Ace Goldfinger       |     48</span><br><span class="line">       3 | Adaptation Holes     |     50</span><br><span class="line">       8 | Airport Pollock      |     54</span><br><span class="line">      15 | Alien Center         |     46</span><br><span class="line">      18 | Alter Victory        |     57</span><br><span class="line">      66 | Beneath Rush         |     53</span><br><span class="line">      83 | Blues Instinct       |     50</span><br><span class="line">      97 | Bride Intrigue       |     56</span><br><span class="line">     110 | Cabin Flash          |     53</span><br><span class="line">     111 | Caddyshack Jedi      |     52</span><br><span class="line">     134 | Champion Flatliners  |     51</span><br><span class="line">     159 | Closer Bang          |     58</span><br><span class="line">     164 | Coast Rainbow        |     55</span><br><span class="line">     171 | Commandments Express |     59</span><br><span class="line">     187 | Cranes Reservoir     |     57</span><br><span class="line">     192 | Crossing Divorce     |     50</span><br><span class="line">     199 | Cupboard Sinners     |     56</span><br><span class="line">     205 | Dances None          |     58</span><br><span class="line">     214 | Daughter Madigan     |     59</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<h3 id="CREATE-TABLE-AS语句"><a href="#CREATE-TABLE-AS语句" class="headerlink" title="CREATE TABLE AS语句"></a>CREATE TABLE AS语句</h3><blockquote>
<p>CREATE TABLE AS语句创建一个新表，并用查询返回的数据填充该表。</p>
</blockquote>
<h4 id="CREATE-TABLE-AS语句语法"><a href="#CREATE-TABLE-AS语句语法" class="headerlink" title="CREATE TABLE AS语句语法"></a>CREATE TABLE AS语句语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE new_table_name</span><br><span class="line">AS query;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，在CREATE TABLE子句之后指定新的表名。</li>
</ul>
<ul>
<li>其次，提供一个查询，该查询的结果集将在AS关键字之后添加到新表中。</li>
</ul>
<blockquote>
<p>TEMPORARY或TEMP关键字允许您创建一个临时表：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TEMP TABLE new_table_name</span><br><span class="line">AS query;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>UNLOGGED关键字允许将新表创建为未记录表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNLOGGED TABLE new_table_name</span><br><span class="line">AS query;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>新表的列将具有与SELECT子句的输出列关联的名称和数据类型。</p>
</blockquote>
<blockquote>
<p>如果希望表列具有不同的名称，则可以在新表名称之后指定新表列：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE new_table_name (column_name_list)</span><br><span class="line">AS query;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要通过创建一个已经存在的新表来避免错误，则可以使用IF NOT EXISTS选项，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS new_table_name</span><br><span class="line">AS query;</span><br></pre></td></tr></table></figure>
<h4 id="CREATE-TABLE-AS语句示例1"><a href="#CREATE-TABLE-AS语句示例1" class="headerlink" title="CREATE TABLE AS语句示例1"></a>CREATE TABLE AS语句示例1</h4><blockquote>
<p>创建一个表，其中包含类别为1的动作片</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE action_film AS</span></span><br><span class="line">SELECT</span><br><span class="line">    film_id,</span><br><span class="line">    title,</span><br><span class="line">    release_year,</span><br><span class="line">    length,</span><br><span class="line">    rating</span><br><span class="line">FROM</span><br><span class="line">    film</span><br><span class="line">INNER JOIN film_category USING (film_id)</span><br><span class="line">WHERE</span><br><span class="line">    category_id = 1 ; -- action</span><br><span class="line">SELECT 64</span><br></pre></td></tr></table></figure>
<blockquote>
<p>验证表的创建</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    action_film</span><br><span class="line">ORDER BY</span><br><span class="line">    title;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>检查表结构</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>-&gt; \d action_film</span><br><span class="line">                   数据表 <span class="string">"public.action_film"</span></span><br><span class="line">     栏位     |          类型          | 校对规则 | 可空的 | 预设 </span><br><span class="line">--------------+------------------------+----------+--------+------</span><br><span class="line"> film_id      | <span class="built_in">integer</span>                |          |        | </span><br><span class="line"> title        | character varying(255) |          |        | </span><br><span class="line"> release_year | year                   |          |        | </span><br><span class="line"> length       | smallint               |          |        | </span><br><span class="line"> rating       | mpaa_rating            |          |        |</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从输出中可以清楚地看出，action_film表的名称和数据类型是从SELECT子句的列派生的。</p>
</blockquote>
<blockquote>
<p>如果SELECT子句包含表达式，则最好重写列，如:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE IF NOT EXISTS film_rating (rating, film_count)</span></span><br><span class="line">AS</span><br><span class="line">SELECT</span><br><span class="line">    rating,</span><br><span class="line">    COUNT (film_id)</span><br><span class="line">FROM</span><br><span class="line">    film</span><br><span class="line">GROUP BY</span><br><span class="line">    rating;</span><br><span class="line">SELECT 5</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">&gt; 此语句创建了一个新表film_rating，并用表中的摘要数据填充了该film表。它显式指定了新表的列名，而不是使用SELECT子句中的列名。</span><br><span class="line"></span><br><span class="line">&gt; 检查film_rating表的结构</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="built_in">test</span>-&gt; \d film_rating</span><br><span class="line">             数据表 <span class="string">"public.film_rating"</span></span><br><span class="line">    栏位    |    类型     | 校对规则 | 可空的 | 预设 </span><br><span class="line">------------+-------------+----------+--------+------</span><br><span class="line"> rating     | mpaa_rating |          |        | </span><br><span class="line"> film_count | bigint      |          |        |</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，CREATE TABLE AS语句类似于SELECT INTO语句，但是首选CREATE TABLE AS语句，因为它不会与PL/pgSQL中的SELECT INTO语法的其他用法混淆。另外，CREATE TABLE AS语句提供了SELECT INTO语句提供的功能的超集。</p>
</blockquote>
<h3 id="使用PostgreSQL-SERIAL创建自动增量列"><a href="#使用PostgreSQL-SERIAL创建自动增量列" class="headerlink" title="使用PostgreSQL SERIAL创建自动增量列"></a>使用PostgreSQL SERIAL创建自动增量列</h3><blockquote>
<p>在PostgreSQL中，序列是一种特殊的数据库对象，它生成整数序列。序列通常用作表中的主键列。</p>
</blockquote>
<h4 id="SERIAL-pseudo-type-语法"><a href="#SERIAL-pseudo-type-语法" class="headerlink" title="SERIAL pseudo-type 语法"></a>SERIAL pseudo-type 语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name(</span><br><span class="line">    id SERIAL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过将SERIAL伪类型分配给id列，PostgreSQL执行以下操作:</p>
<ul>
<li>首先，创建一个序列对象，并将该序列生成的下一个值设置为该列的默认值。</li>
</ul>
<ul>
<li>其次，将id列添加为NOT NULL约束，因为序列始终会生成一个整数，该整数是非null值。</li>
</ul>
<ul>
<li>第三，将序列的所有者分配给id列；结果，当删除id列或表时，将删除序列对象。</li>
</ul>
</blockquote>
<blockquote>
<p>以下语句:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name(</span><br><span class="line">    id SERIAL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>等效于以下语句:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE SEQUENCE table_name_id_seq;</span><br><span class="line"> </span><br><span class="line">CREATE TABLE table_name (</span><br><span class="line">    id <span class="built_in">integer</span> NOT NULL DEFAULT nextval(<span class="string">'table_name_id_seq'</span>)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">ALTER SEQUENCE table_name_id_seq</span><br><span class="line">OWNED BY table_name.id;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PostgreSQL提供了三个串行伪类型SMALLSERIAL，SERIAL以及BIGSERIAL:</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:center">储存空间</th>
<th style="text-align:right">范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SMALLSERIAL</td>
<td style="text-align:center">2 bytes</td>
<td style="text-align:right">1 至 32767</td>
</tr>
<tr>
<td style="text-align:left">SERIAL</td>
<td style="text-align:center">4 bytes</td>
<td style="text-align:right">1 至 2147483647</td>
</tr>
<tr>
<td style="text-align:left">BIGSERIAL</td>
<td style="text-align:center">8 bytes</td>
<td style="text-align:right">1 至 9223372036854775807</td>
</tr>
</tbody>
</table>
<h4 id="SERIAL范例1"><a href="#SERIAL范例1" class="headerlink" title="SERIAL范例1"></a>SERIAL范例1</h4><blockquote>
<p>注意，SERIAL不会在列上隐式创建索引或使该列成为主键列。但是，这可以通过PRIMARY KEY为SERIAL列指定约束来轻松完成。</p>
</blockquote>
<blockquote>
<p>以下语句使用id列作为SERIAL列创建fruits表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE fruits(</span></span><br><span class="line">   id SERIAL PRIMARY KEY,</span><br><span class="line">   name VARCHAR NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要在向表中插入行时为串行列分配默认值，请忽略列名或在INSERT语句中使用DEFAULT关键字。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO fruits(name)</span></span><br><span class="line">VALUES(<span class="string">'Orange'</span>);</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要么</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO fruits(id,name)</span></span><br><span class="line">VALUES(DEFAULT,<span class="string">'Apple'</span>);</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PostgreSQL在fruits表中插入了两行，其中id列的值为1和2。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT * FROM fruits;</span></span><br><span class="line"> id |  name</span><br><span class="line">----+--------</span><br><span class="line">  1 | Orange</span><br><span class="line">  2 | Apple</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要获取SERIAL表中列的序列名称，请使用pg_get_serial_sequence()函数:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pg_get_serial_sequence(<span class="string">'table_name'</span>,<span class="string">'column_name'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以将序列名称传递给currval()函数，以获取该序列生成的最新值。例如，以下语句返回由fruits_id_seq对象生成的最近值:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT currval(pg_get_serial_sequence('fruits', 'id'));</span></span><br><span class="line"> currval</span><br><span class="line">---------</span><br><span class="line">       2</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要在表中插入新行时获取序列生成的值，请在INSERT语句中使用RETURNING id子句。以下语句在fruits表中插入新行，并返回为id列生成的值:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO fruits(name)</span></span><br><span class="line">VALUES(<span class="string">'Banana'</span>)</span><br><span class="line">RETURNING id;</span><br><span class="line"> id</span><br><span class="line">----</span><br><span class="line">  3</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>序列生成器操作不是事务安全的。这意味着，如果两个并发数据库连接尝试从序列中获取下一个值，则每个客户端将获得一个不同的值。如果一个客户端回滚该事务，则该客户端的序列号将不被使用，从而在序列中产生间隙。</p>
</blockquote>
<h3 id="CREATE-SEQUENCE语句"><a href="#CREATE-SEQUENCE语句" class="headerlink" title="CREATE SEQUENCE语句"></a>CREATE SEQUENCE语句</h3><blockquote>
<p>PostgreSQL中的序列是用户定义的模式绑定对象，该对象根据指定的规范生成整数序列。要在PostgreSQL中创建序列，请使用CREATE SEQUENCE语句。</p>
</blockquote>
<h4 id="CREATE-SEQUENCE语句语法"><a href="#CREATE-SEQUENCE语句语法" class="headerlink" title="CREATE SEQUENCE语句语法"></a>CREATE SEQUENCE语句语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE SEQUENCE [ IF NOT EXISTS ] sequence_name</span><br><span class="line">    [ AS &#123; SMALLINT | INT | BIGINT &#125; ]</span><br><span class="line">    [ INCREMENT [ BY ] increment ]</span><br><span class="line">    [ MINVALUE minvalue | NO MINVALUE ]</span><br><span class="line">    [ MAXVALUE maxvalue | NO MAXVALUE ]</span><br><span class="line">    [ START [ WITH ] start ]</span><br><span class="line">    [ CACHE cache ]</span><br><span class="line">    [ [ NO ] CYCLE ]</span><br><span class="line">    [ OWNED BY &#123; table_name.column_name | NONE &#125; ]</span><br></pre></td></tr></table></figure>
<ul>
<li>sequence_name : 在CREATE SEQUENCE子句之后指定序列的名称。IF NOT EXISTS仅在不存在时才有条件地创建一个新序列。序列名称必须与同一架构中的任何其他序列、表、索引、视图或外部表不同。</li>
</ul>
<ul>
<li>[AS {SMALLINT | INT | BIGINT}]: 指定序列的数据类型。有效数据类型为SMALLINT，INT和BIGINT。默认数据类型，则为BIGINT。序列的数据类型，用于确定序列的最小值和最大值。</li>
</ul>
<ul>
<li>[ INCREMENT [ BY ] increment ]<br>: 增量指定将哪个值添加到当前序列值以创建新值。一个正数将形成一个升序，而一个负数将形成一个降序。默认增量值为1。</li>
</ul>
<ul>
<li>[ MINVALUE minvalue | NO MINVALUE ]</li>
</ul>
<ul>
<li>[ MAXVALUE maxvalue | NO MAXVALUE ]:<br>定义序列的最小值和最大值。如果使用NO MINVALUE和NO MAXVALUE，则序列将使用默认值。对于升序序列，缺省最大值是序列数据类型的最大值，缺省最小值是1。如果是降序序列，则默认最大值为-1，默认最小值为序列数据类型的最小值。</li>
</ul>
<ul>
<li>[ START [ WITH ] start ]:<br>START子句指定序列的起始值。缺省的起始值为升序的最小值和降序的最大值。</li>
</ul>
<ul>
<li>cache:<br>CACHE确定要预分配多少序列号并将其存储在内存中，以加快访问速度。 一次可以生成一个值。默认情况下，该序列一次生成一个值，即不生成缓存。</li>
</ul>
<ul>
<li>CYCLE | NO CYCLE:<br>如果达到限制，则可以使用CYCLE重新启动该值。下一个数字将是升序的最小值，是降序的最大值。如果使用NO CYCLE，则在达到限制时，尝试获取下一个值将导致错误。如果您未明确指定CYCLE或NO CYCLE，则默认为NO CYCLE。</li>
</ul>
<ul>
<li>OWNED BY table_name.column_name:<br>OWNED BY子句允许将表列与序列关联，以便在删除列或表时，PostgreSQL将自动删除关联的序列。注意，当对表的列使用SERIAL伪类型时，在后台，PostgreSQL会自动创建与该列关联的序列。</li>
</ul>
<h4 id="创建升序序列示例"><a href="#创建升序序列示例" class="headerlink" title="创建升序序列示例"></a>创建升序序列示例</h4><blockquote>
<p>使用CREATE SEQUENCE语句创建一个新的升序序列，从100开始，增量为5:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE SEQUENCE mysequence</span></span><br><span class="line">INCREMENT 5</span><br><span class="line">START 100;</span><br><span class="line">CREATE SEQUENCE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要从序列中获取下一个值，请使用nextval()函数</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT nextval('mysequence');</span></span><br><span class="line"> nextval</span><br><span class="line">---------</span><br><span class="line">     100</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果再次执行该语句，将从序列中获取下一个值:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT nextval('mysequence');</span></span><br><span class="line"> nextval</span><br><span class="line">---------</span><br><span class="line">     105</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="创建一个降序示例"><a href="#创建一个降序示例" class="headerlink" title="创建一个降序示例"></a>创建一个降序示例</h4><blockquote>
<p>使用cycle选项创建从3到1的降序序列</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE SEQUENCE three</span></span><br><span class="line">INCREMENT -1</span><br><span class="line">MINVALUE 1</span><br><span class="line">MAXVALUE 3</span><br><span class="line">START 3</span><br><span class="line">CYCLE;</span><br><span class="line">CREATE SEQUENCE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>多次执行以下语句时，您将看到数字从3、2、1开始，再回到3、2、1，依此类推:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT nextval('three');</span></span><br><span class="line"> nextval</span><br><span class="line">---------</span><br><span class="line">       3</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT nextval('three');</span></span><br><span class="line"> nextval</span><br><span class="line">---------</span><br><span class="line">       2</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT nextval('three');</span></span><br><span class="line"> nextval</span><br><span class="line">---------</span><br><span class="line">       1</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT nextval('three');</span></span><br><span class="line"> nextval</span><br><span class="line">---------</span><br><span class="line">       3</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="创建与表列关联的序列"><a href="#创建与表列关联的序列" class="headerlink" title="创建与表列关联的序列"></a>创建与表列关联的序列</h4><blockquote>
<p>首先，创建一个名为order_details的新表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE order_details(</span></span><br><span class="line">    order_id SERIAL,</span><br><span class="line">    item_id INT NOT NULL,</span><br><span class="line">    item_text TEXT NOT NULL,</span><br><span class="line">    price DEC(10,2) NOT NULL,</span><br><span class="line">    PRIMARY KEY(order_id, item_id)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其次，创建一个与order_details表的item_id列关联的新序列:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE SEQUENCE order_item_id</span></span><br><span class="line">START 10</span><br><span class="line">INCREMENT 10</span><br><span class="line">MINVALUE 10</span><br><span class="line">OWNED BY order_details.item_id;</span><br><span class="line">CREATE SEQUENCE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三，将三个订单行项目插入order_details表中:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO</span></span><br><span class="line">    order_details(order_id, item_id, item_text, price)</span><br><span class="line">VALUES</span><br><span class="line">    (100, nextval(<span class="string">'order_item_id'</span>),<span class="string">'DVD Player'</span>,100),</span><br><span class="line">    (100, nextval(<span class="string">'order_item_id'</span>),<span class="string">'Android TV'</span>,550),</span><br><span class="line">    (100, nextval(<span class="string">'order_item_id'</span>),<span class="string">'Speaker'</span>,250);</span><br><span class="line">INSERT 0 3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此语句中，我们使用nextval()函数从order_item_id序列中获取商品ID值。</p>
</blockquote>
<blockquote>
<p>第四，从order_details表中查询数据：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    order_id,</span><br><span class="line">    item_id,</span><br><span class="line">    item_text,</span><br><span class="line">    price</span><br><span class="line">FROM</span><br><span class="line">    order_details;  </span><br><span class="line"> order_id | item_id | item_text  | price</span><br><span class="line">----------+---------+------------+--------</span><br><span class="line">      100 |      10 | DVD Player | 100.00</span><br><span class="line">      100 |      20 | Android TV | 550.00</span><br><span class="line">      100 |      30 | Speaker    | 250.00</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<h4 id="列出数据库中的所有序列"><a href="#列出数据库中的所有序列" class="headerlink" title="列出数据库中的所有序列"></a>列出数据库中的所有序列</h4><blockquote>
<p>要列出当前数据库中的所有序列，请使用以下查询:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    relname sequence_name</span><br><span class="line">FROM</span><br><span class="line">    pg_class</span><br><span class="line">WHERE</span><br><span class="line">    relkind = <span class="string">'S'</span>;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line"><span class="comment">#### 删除序列</span></span><br><span class="line">&gt; 如果序列与表列相关联，则在删除表列或整个表后将自动删除该序列。否则，需要使用以下DROP SEQUENCE语句手动删除序列。</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">DROP SEQUENCE [ IF EXISTS ] sequence_name [, ...]</span><br><span class="line">[ CASCADE | RESTRICT ];</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，指定要删除的序列的名称。IF EXISTS选项有条件地删除该序列（如果存在）。如果要一次删除多个序列，则可以使用逗号分隔的序列名称列表。</li>
</ul>
<ul>
<li>然后，如果要自动删除依赖于序列的对象以及依赖于那些对象的对象，请使用CASCADE选项。</li>
</ul>
<h4 id="DROP-SEQUENCE语句示例"><a href="#DROP-SEQUENCE语句示例" class="headerlink" title="DROP SEQUENCE语句示例"></a>DROP SEQUENCE语句示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DROP TABLE order_details;</span></span><br><span class="line">DROP TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该语句删除表order_details。由于序列order_item_id与order_details的item_id相关联，因此它也将自动删除。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DROP SEQUENCE IF EXISTS mysequence, three;</span></span><br><span class="line">DROP SEQUENCE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本示例使用DROP SEQUENCE语句删除两个序列mysequence和three。</p>
</blockquote>
<h3 id="GENERATED-AS-IDENTITY约束"><a href="#GENERATED-AS-IDENTITY约束" class="headerlink" title="GENERATED AS IDENTITY约束"></a>GENERATED AS IDENTITY约束</h3><blockquote>
<p>GENERATED AS IDENTITY约束使您可以自动为列分配唯一值。GENERATED AS IDENTITY约束是PostgreSQL的SERIAL列的符合SQL标准的变体。</p>
</blockquote>
<h4 id="GENERATED-AS-IDENTITY约束的语法"><a href="#GENERATED-AS-IDENTITY约束的语法" class="headerlink" title="GENERATED AS IDENTITY约束的语法"></a>GENERATED AS IDENTITY约束的语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column_name <span class="built_in">type</span> GENERATED &#123; ALWAYS | BY DEFAULT &#125; AS IDENTITY[ ( sequence_option ) ]</span><br></pre></td></tr></table></figure>
<ul>
<li>类型可以是SMALLINT、INT或BIGINT。</li>
</ul>
<ul>
<li>GENERATED ALWAYS始终指示PostgreSQL为identity列始终生成一个值。如果您尝试将值插入（或更新）到“ GENERATED ALWAYS AS IDENTITY”列中，则PostgreSQL将发出错误消息。</li>
</ul>
<ul>
<li>GENERATED BY DEFAULT还指示PostgreSQL为Identity列生成一个值。但是，如果您提供用于插入或更新的值，则PostgreSQL将使用该值插入到Identity列中，而不是使用系统生成的值。PostgreSQL允许您在一个表中具有多个标识列。与SERIAL约束类似，GENERATED AS IDENTITY约束在内部也使用SEQUENCE对象。</li>
</ul>
<h4 id="GENERATED-ALWAYS示例"><a href="#GENERATED-ALWAYS示例" class="headerlink" title="GENERATED ALWAYS示例"></a>GENERATED ALWAYS示例</h4><blockquote>
<p>首先，创建一个名为color的表，并将color_id作为标识列:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE color (</span></span><br><span class="line">    color_id INT GENERATED ALWAYS AS IDENTITY,</span><br><span class="line">    color_name VARCHAR NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其次，在color表中插入新行:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO color (color_name)</span></span><br><span class="line">VALUES</span><br><span class="line">    (<span class="string">'Red'</span>);</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为color_id列具有GENERATED AS IDENTITY约束，所以PostgreSQL为其生成一个值，如下面的查询所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    color;</span><br><span class="line"> color_id | color_name</span><br><span class="line">----------+------------</span><br><span class="line">        1 | Red</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三，通过为color_id和color_name列提供值来插入新行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO color (color_id, color_name)</span></span><br><span class="line">VALUES</span><br><span class="line">    (2, <span class="string">'Green'</span>);</span><br><span class="line">错误:  无法插入到列<span class="string">"color_id"</span></span><br><span class="line">DETAIL:  列<span class="string">"color_id"</span>是定义为GENERATED ALWAYS的标识列.</span><br><span class="line">HINT:  使用OVERRIDING SYSTEM VALUE覆盖.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要解决此错误，在这种情况下，可以使用OVERRIDING SYSTEM VALUE子句:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO color (color_id, color_name)</span></span><br><span class="line">OVERRIDING SYSTEM VALUE</span><br><span class="line">VALUES</span><br><span class="line">    (2, <span class="string">'Green'</span>);</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或改用GENERATED BY DEFAULT AS IDENTITY。</p>
</blockquote>
<h4 id="GENERATED-BY-DEFAULT-AS-IDENTITY示例"><a href="#GENERATED-BY-DEFAULT-AS-IDENTITY示例" class="headerlink" title="GENERATED BY DEFAULT AS IDENTITY示例"></a>GENERATED BY DEFAULT AS IDENTITY示例</h4><blockquote>
<p>首先，删除color表并重新创建它。这次，改为使用GENERATED BY DEFAULT AS IDENTITY:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DROP TABLE color;</span></span><br><span class="line"> </span><br><span class="line">CREATE TABLE color (</span><br><span class="line">    color_id INT GENERATED BY DEFAULT AS IDENTITY,</span><br><span class="line">    color_name VARCHAR NOT NULL</span><br><span class="line">);</span><br><span class="line">DROP TABLE</span><br><span class="line"></span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第二，在color表中插入一行:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO color (color_name)</span></span><br><span class="line">VALUES</span><br><span class="line">    (<span class="string">'White'</span>);</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三，插入另一行，并为该color_id列添加值：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO color (color_id, color_name)</span></span><br><span class="line">VALUES</span><br><span class="line">    (2, <span class="string">'Yellow'</span>);</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>与前面的示例使用GENERATED ALWAYS AS IDENTITY约束不同，此语句有效。</p>
</blockquote>
<h4 id="SEQUENCE选项示例"><a href="#SEQUENCE选项示例" class="headerlink" title="SEQUENCE选项示例"></a>SEQUENCE选项示例</h4><blockquote>
<p>由于GENERATED AS IDENTITY约束使用SEQUENCE对象，因此可以为系统生成的值指定序列选项。</p>
</blockquote>
<blockquote>
<p>指定起始值和增量，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DROP TABLE color;</span></span><br><span class="line"> </span><br><span class="line">CREATE TABLE color (</span><br><span class="line">    color_id INT GENERATED BY DEFAULT AS IDENTITY</span><br><span class="line">    (START WITH 10 INCREMENT BY 10),</span><br><span class="line">    color_name VARCHAR NOT NULL</span><br><span class="line">);</span><br><span class="line">DROP TABLE</span><br><span class="line"></span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此示例中，color_id列的系统生成值以10开头，增量值为10。</p>
</blockquote>
<blockquote>
<p>首先，在color表中插入新行：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO color (color_name)</span></span><br><span class="line">VALUES</span><br><span class="line">    (<span class="string">'Orange'</span>);</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>color_id列的起始值为10，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    color;</span><br><span class="line"> color_id | color_name</span><br><span class="line">----------+------------</span><br><span class="line">       10 | Orange</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第二，在color表中插入另一行:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO color (color_name)</span></span><br><span class="line">VALUES</span><br><span class="line">    (<span class="string">'Purple'</span>);</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于增加选项，第二行的color_id的值为20。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    color;</span><br><span class="line"> color_id | color_name</span><br><span class="line">----------+------------</span><br><span class="line">       10 | Orange</span><br><span class="line">       20 | Purple</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h4 id="将标识列添加到现有表"><a href="#将标识列添加到现有表" class="headerlink" title="将标识列添加到现有表"></a>将标识列添加到现有表</h4><blockquote>
<p>可以使用以下形式的ALTER TABLE语句将标识列添加到现有表中:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">ALTER COLUMN column_name</span><br><span class="line">ADD GENERATED &#123; ALWAYS | BY DEFAULT &#125; AS IDENTITY &#123; ( sequence_option ) &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先，创建一个名为shape的新表:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE shape (</span></span><br><span class="line">    shape_id INT NOT NULL,</span><br><span class="line">    shape_name VARCHAR NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第二，将shape_id列更改为标识列:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE shape</span></span><br><span class="line">ALTER COLUMN shape_id ADD GENERATED ALWAYS AS IDENTITY;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三，查看表结构</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; \d shape</span><br><span class="line">                                数据表 <span class="string">"public.shape"</span></span><br><span class="line">    栏位    |       类型        | 校对规则 |  可空的  |             预设             </span><br><span class="line">------------+-------------------+----------+----------+------------------------------</span><br><span class="line"> shape_id   | <span class="built_in">integer</span>           |          | not null | generated always as identity</span><br><span class="line"> shape_name | character varying |          | not null |</span><br></pre></td></tr></table></figure>
<h4 id="更改身份列"><a href="#更改身份列" class="headerlink" title="更改身份列"></a>更改身份列</h4><blockquote>
<p>可以使用ALTER TABLE语句来更改现有标识列的特征</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">ALTER COLUMN column_name</span><br><span class="line">&#123; SET GENERATED &#123; ALWAYS| BY DEFAULT &#125; |</span><br><span class="line">  SET sequence_option | RESTART [ [ WITH ] restart ] &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如，以下语句将shape表的shape_id列更改为GENERATED BY DEFAULT:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE shape</span></span><br><span class="line">ALTER COLUMN shape_id SET GENERATED BY DEFAULT;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看表结构</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; \d shape</span><br><span class="line">                                  数据表 <span class="string">"public.shape"</span></span><br><span class="line">    栏位    |       类型        | 校对规则 |  可空的  |               预设               </span><br><span class="line">------------+-------------------+----------+----------+----------------------------------</span><br><span class="line"> shape_id   | <span class="built_in">integer</span>           |          | not null | generated by default as identity</span><br><span class="line"> shape_name | character varying |          | not null |</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从输出中可以看到，该shape_id列从GENERATED ALWAYS变为GENERATED BY DEFAULT。</p>
</blockquote>
<h4 id="除去GENERATED-AS-IDENTITY约束"><a href="#除去GENERATED-AS-IDENTITY约束" class="headerlink" title="除去GENERATED AS IDENTITY约束"></a>除去GENERATED AS IDENTITY约束</h4><blockquote>
<p>以下语句从现有表中删除GENERATED AS IDENTITY约束:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">ALTER COLUMN column_name</span><br><span class="line">DROP IDENTITY [ IF EXISTS ]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>按如下所示从shape表的shape_id列中删除GENERATED AS IDENTITY约束列：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE shape</span></span><br><span class="line">ALTER COLUMN shape_id</span><br><span class="line">DROP IDENTITY IF EXISTS;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看表结构</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; \d shape</span><br><span class="line">                    数据表 <span class="string">"public.shape"</span></span><br><span class="line">    栏位    |       类型        | 校对规则 |  可空的  | 预设 </span><br><span class="line">------------+-------------------+----------+----------+------</span><br><span class="line"> shape_id   | <span class="built_in">integer</span>           |          | not null | </span><br><span class="line"> shape_name | character varying |          | not null |</span><br></pre></td></tr></table></figure>
<h3 id="ALTER-TABLE语句"><a href="#ALTER-TABLE语句" class="headerlink" title="ALTER TABLE语句"></a>ALTER TABLE语句</h3><blockquote>
<p>要更改现有的表结构，请使用ALTER TABLE语句。</p>
</blockquote>
<h4 id="ALTER-TABLE语法"><a href="#ALTER-TABLE语法" class="headerlink" title="ALTER TABLE语法"></a>ALTER TABLE语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name action;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加列，删除列，重命名列或更改列的数据类型。</li>
</ul>
<ul>
<li>为列设置默认值。</li>
</ul>
<ul>
<li>向列添加CHECK约束。</li>
</ul>
<ul>
<li>重命名表。</li>
</ul>
<blockquote>
<p>要将新列添加到表，请使用ALTER TBLE ADD COLUMN 语句:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD COLUMN new_column_name TYPE;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要删除现有列，请使用ALTER TABLE DROP COLUMN 语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name DROP COLUMN column_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要重命名现有列，请使用ALTER TABLE RENAME COLUMN TO 语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要更改列的默认值，请使用ALTER TABLE ALTER COLUMN SET DEFAULT 或 DROP DEFAULT：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ALTER COLUMN column_name [SET DEFAULT value | DROP DEFAULT];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要更改NOT NULL约束，请使用ALTER TABLE ALTER COLUMN 语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ALTER COLUMN column_name [SET NOT NULL| DROP NOT NULL];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要添加CHECK约束，请使用ALTER TABLE ADD CHECK 语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD CHECK expression;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要添加约束，请使用ALTER TABLE ADD CONSTRAINT 语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD CONSTRAINT constraint_name constraint_definition;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要重命名表，请使用ALTER TABLE RENAME TO 语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name RENAME TO new_table_name;</span><br></pre></td></tr></table></figure>
<h4 id="ALTER-TABLE示例"><a href="#ALTER-TABLE示例" class="headerlink" title="ALTER TABLE示例"></a>ALTER TABLE示例</h4><blockquote>
<p>创建一个名为links的新表，以使用ALTER TABLE语句进行练习。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE links (</span></span><br><span class="line">   link_id serial PRIMARY KEY,</span><br><span class="line">   title VARCHAR (512) NOT NULL,</span><br><span class="line">   url VARCHAR (1024) NOT NULL UNIQUE</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>添加名为active的新列</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE links ADD COLUMN active boolean;</span></span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从links表中删除active列</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE links DROP COLUMN active;</span></span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将title列重命名为link_title</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE links RENAME COLUMN title TO link_title;</span></span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将一个名为target的新列添加到links表中</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE links ADD COLUMN target VARCHAR(10);</span></span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将_blank设置为link表中目标列的默认值</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE links ALTER COLUMN target</span></span><br><span class="line">SET DEFAULT <span class="string">'_blank'</span>;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将新行插入links表中而未指定该target列的值，则该target列将_blank作为默认值</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO links (link_title, url)</span></span><br><span class="line">VALUES(<span class="string">'PostgreSQL'</span>,<span class="string">'http://www.postgresql.org/'</span>);</span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT * FROM links;</span></span><br><span class="line"> link_id | link_title |            url             | target</span><br><span class="line">---------+------------+----------------------------+--------</span><br><span class="line">       1 | PostgreSQL | http://www.postgresql.org/ | _blank</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下语句将CHECK条件添加到目标列，以便target列仅接受以下值：_self，_blank，_parent和_top：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE links ADD CHECK (target IN ('_self', '_blank', '_parent', '_top'));</span></span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果尝试插入违反该列CHECK约束设置的新行target，PostgreSQL将发出错误，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO links(link_title,url,target)</span></span><br><span class="line">VALUES(<span class="string">'PG'</span>,<span class="string">'http://www.postgresql.cn/'</span>,<span class="string">'pgsql'</span>);</span><br><span class="line">错误:  关系 <span class="string">"links"</span> 的新列违反了检查约束 <span class="string">"links_target_check"</span></span><br><span class="line">DETAIL:  失败, 行包含(2, PG, http://www.postgresql.cn/, pgsql).</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将links表重命名为url</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE links RENAME TO url;</span></span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<h3 id="RENAME-TO子句"><a href="#RENAME-TO子句" class="headerlink" title="RENAME TO子句"></a>RENAME TO子句</h3><h4 id="重命名表语法"><a href="#重命名表语法" class="headerlink" title="重命名表语法"></a>重命名表语法</h4><blockquote>
<p>要重命名现有表，请使用以下ALTER TABLE语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">RENAME TO new_table_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，在ALTER TABLE子句后指定要重命名的表的名称。</li>
</ul>
<ul>
<li>其次，在RENAME TO子句后输入新的表名。</li>
</ul>
<blockquote>
<p>如果尝试重命名一个不存在的表，PostgreSQL将发出一个错误。为避免这种情况，可以IF EXISTS如下添加选项：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE IF EXISTS table_name</span><br><span class="line">RENAME TO new_table_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这种情况下，如果table_name不存在，PostgreSQL将发出通知。</li>
</ul>
<blockquote>
<p>要重命名多个表，您必须执行多个ALTER TABLE RENAME TO语句。不可能在单个语句中做到这一点。</p>
</blockquote>
<h4 id="重命名表示例"><a href="#重命名表示例" class="headerlink" title="重命名表示例"></a>重命名表示例</h4><blockquote>
<p>创建了一个名为vendors的新表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE vendors (</span></span><br><span class="line">    id serial PRIMARY KEY,</span><br><span class="line">    name VARCHAR NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将vendors表重命名为suppliers</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE vendors RENAME TO suppliers;</span></span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>假设vendor或supplier都属于一个组。要管理这种关系，我们需要添加supplier_groups表，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE supplier_groups (</span></span><br><span class="line">    ID serial PRIMARY KEY,</span><br><span class="line">    name VARCHAR NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们还需要在Suppliers表中添加一个名为group_id的新列。此列是外键列，它链接到provider_groups表的id列。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE suppliers</span></span><br><span class="line">ADD COLUMN group_id INT NOT NULL;</span><br><span class="line"> </span><br><span class="line">ALTER TABLE suppliers</span><br><span class="line">ADD FOREIGN KEY (group_id) REFERENCES supplier_groups (ID);</span><br><span class="line">ALTER TABLE</span><br><span class="line"></span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将表重命名为新表时，PostgreSQL将自动更新其依赖对象，例如外键约束，视图和索引。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; \d suppliers</span><br><span class="line">                                数据表 <span class="string">"public.suppliers"</span></span><br><span class="line">   栏位   |       类型        | 校对规则 |  可空的  |                预设                 </span><br><span class="line">----------+-------------------+----------+----------+-------------------------------------</span><br><span class="line"> id       | <span class="built_in">integer</span>           |          | not null | nextval(<span class="string">'vendors_id_seq'</span>::regclass)</span><br><span class="line"> name     | character varying |          | not null | </span><br><span class="line"> group_id | <span class="built_in">integer</span>           |          | not null | </span><br><span class="line">索引：</span><br><span class="line">    <span class="string">"vendors_pkey"</span> PRIMARY KEY, btree (id)</span><br><span class="line">外部键(FK)限制：</span><br><span class="line">    <span class="string">"suppliers_group_id_fkey"</span> FOREIGN KEY (group_id) REFERENCES supplier_groups(id)</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=&gt; ALTER TABLE supplier_groups RENAME TO groups;</span><br><span class="line">ALTER TABLE</span><br><span class="line"><span class="built_in">test</span>=&gt; \d suppliers</span><br><span class="line">                                数据表 <span class="string">"public.suppliers"</span></span><br><span class="line">   栏位   |       类型        | 校对规则 |  可空的  |                预设                 </span><br><span class="line">----------+-------------------+----------+----------+-------------------------------------</span><br><span class="line"> id       | <span class="built_in">integer</span>           |          | not null | nextval(<span class="string">'vendors_id_seq'</span>::regclass)</span><br><span class="line"> name     | character varying |          | not null | </span><br><span class="line"> group_id | <span class="built_in">integer</span>           |          | not null | </span><br><span class="line">索引：</span><br><span class="line">    <span class="string">"vendors_pkey"</span> PRIMARY KEY, btree (id)</span><br><span class="line">外部键(FK)限制：</span><br><span class="line">    <span class="string">"suppliers_group_id_fkey"</span> FOREIGN KEY (group_id) REFERENCES groups(id)</span><br></pre></td></tr></table></figure>
<h3 id="ADD-COLUMN语句"><a href="#ADD-COLUMN语句" class="headerlink" title="ADD COLUMN语句"></a>ADD COLUMN语句</h3><h4 id="ADD-COLUMN语句语法"><a href="#ADD-COLUMN语句语法" class="headerlink" title="ADD COLUMN语句语法"></a>ADD COLUMN语句语法</h4><blockquote>
<p>要将新列添加到现有表中，请使用以下语句:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">ADD COLUMN new_column_name data_type;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，在ALTER TABLE子句中指定要添加新列的表。</li>
</ul>
<ul>
<li>其次，在ADD COLUMN子句中使用其属性（例如数据类型，默认值等）指示列名称。当向表中添加新列时，PostgreSQL会将其追加到表末尾。PostgreSQL暂时无法选择指定表中新列的位置。</li>
</ul>
<blockquote>
<p>要将多个列添加到现有表中，请在ALTER TABLE语句中使用多个ADD COLUMN子句，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">ADD COLUMN new_column_name_1 data_type constraint,</span><br><span class="line">ADD COLUMN new_column_name_2 data_type constraint,</span><br><span class="line">...</span><br><span class="line">ADD COLUMN new_column_name_n data_type constraint;</span><br></pre></td></tr></table></figure>
<h4 id="ADD-COLUMN示例"><a href="#ADD-COLUMN示例" class="headerlink" title="ADD COLUMN示例"></a>ADD COLUMN示例</h4><blockquote>
<p>以下CREATE TABLE语句创建一个名为customers的新表，该表具有两列：id和customer_name</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE customers (</span></span><br><span class="line">   id SERIAL PRIMARY KEY,</span><br><span class="line">   customer_name VARCHAR NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将phone列添加到customers表中:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE customers</span></span><br><span class="line">ADD COLUMN phone VARCHAR;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将fax和email列添加到customers表中:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE customers</span></span><br><span class="line">ADD COLUMN fax VARCHAR,</span><br><span class="line">ADD COLUMN email VARCHAR;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看表结构</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; \d customers</span><br><span class="line">                                    数据表 <span class="string">"public.customers"</span></span><br><span class="line">     栏位      |       类型        | 校对规则 |  可空的  |                 预设                  </span><br><span class="line">---------------+-------------------+----------+----------+---------------------------------------</span><br><span class="line"> id            | <span class="built_in">integer</span>           |          | not null | nextval(<span class="string">'customers_id_seq'</span>::regclass)</span><br><span class="line"> customer_name | character varying |          | not null | </span><br><span class="line"> phone         | character varying |          |          | </span><br><span class="line"> fax           | character varying |          |          | </span><br><span class="line"> email         | character varying |          |          | </span><br><span class="line">索引：</span><br><span class="line">    <span class="string">"customers_pkey"</span> PRIMARY KEY, btree (id)</span><br></pre></td></tr></table></figure>
<h4 id="将具有NOT-NULL约束的列添加到具有数据的表中"><a href="#将具有NOT-NULL约束的列添加到具有数据的表中" class="headerlink" title="将具有NOT NULL约束的列添加到具有数据的表中"></a>将具有NOT NULL约束的列添加到具有数据的表中</h4><blockquote>
<p>插入数据</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO customers (customer_name)</span></span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'Apple'</span>),</span><br><span class="line">   (<span class="string">'Samsung'</span>),</span><br><span class="line">   (<span class="string">'Sony'</span>);</span><br><span class="line">INSERT 0 3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里假设将contact_name列添加到customers表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE customers</span></span><br><span class="line">ADD COLUMN contact_name VARCHAR NOT NULL;</span><br><span class="line">错误:  字段 <span class="string">"contact_name"</span> 包含空值</span><br></pre></td></tr></table></figure>
<ul>
<li>这是因为contact_name列具有NOT NULL约束。PostgreSQL添加该列时，此新列采用NULL值，这违反了NOT NULL约束。</li>
</ul>
<blockquote>
<p>为了解决这个问题，首先需要添加没有NOT NULL 约束的列。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE customers</span></span><br><span class="line">ADD COLUMN contact_name VARCHAR;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其次，更新contact_name列的值。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE customers</span></span><br><span class="line">SET contact_name = <span class="string">'John'</span></span><br><span class="line">WHERE</span><br><span class="line">   ID = 1;</span><br><span class="line"> </span><br><span class="line">UPDATE customers</span><br><span class="line">SET contact_name = <span class="string">'Mary'</span></span><br><span class="line">WHERE</span><br><span class="line">   ID = 2;</span><br><span class="line"> </span><br><span class="line">UPDATE customers</span><br><span class="line">SET contact_name = <span class="string">'Lily'</span></span><br><span class="line">WHERE</span><br><span class="line">   ID = 3;</span><br><span class="line">UPDATE 1</span><br><span class="line"></span><br><span class="line">UPDATE 1</span><br><span class="line"></span><br><span class="line">UPDATE 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三，为contact_name列设置NOT NULL约束。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE customers</span></span><br><span class="line">ALTER COLUMN contact_name SET NOT NULL;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<h3 id="DROP-COLUMN子句"><a href="#DROP-COLUMN子句" class="headerlink" title="DROP COLUMN子句"></a>DROP COLUMN子句</h3><h4 id="DROP-COLUMN子句的语法"><a href="#DROP-COLUMN子句的语法" class="headerlink" title="DROP COLUMN子句的语法"></a>DROP COLUMN子句的语法</h4><blockquote>
<p>要删除表的列，请在ALTER TABLE语句中使用DROP COLUMN子句，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">DROP COLUMN column_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>当您从表中删除列时，PostgreSQL将自动删除它与该列有关的所有索引和约束。</li>
</ul>
<blockquote>
<p>如果要删除的列已在其他数据库对象（例如视图，触发器，存储过程等）中使用，则不能删除该列，因为其他对象依赖该列。在这种情况下，将CASCADE选项添加到DROP COLUMN子句中以删除列及其所有关联对象：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">DROP COLUMN column_name CASCADE;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果删除不存在的列，PostgreSQL将发出一个错误。为避免这种情况，您可以IF EXISTS如下添加选项：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">DROP COLUMN IF EXISTS column_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这种形式下，如果删除不存在的列，PostgreSQL将发出通知而不是错误。</li>
</ul>
<blockquote>
<p>如果要在单个命令中删除表的多个列，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">DROP COLUMN column_name_1,</span><br><span class="line">DROP COLUMN column_name_2,</span><br><span class="line">...;</span><br></pre></td></tr></table></figure>
<ul>
<li>请注意，每个DROP COLUMN子句都用逗号（，）分隔。</li>
</ul>
<blockquote>
<p>PostgreSQL允许删除表的唯一列，从而导致零列表，但这在SQL标准中是不允许的。</p>
</blockquote>
<h4 id="DROP-COLUMN示例"><a href="#DROP-COLUMN示例" class="headerlink" title="DROP COLUMN示例"></a>DROP COLUMN示例</h4><blockquote>
<p>创建示例表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE publishers (</span></span><br><span class="line">    publisher_id serial PRIMARY KEY,</span><br><span class="line">    name VARCHAR NOT NULL</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">CREATE TABLE categories (</span><br><span class="line">    category_id serial PRIMARY KEY,</span><br><span class="line">    name VARCHAR NOT NULL</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">CREATE TABLE books (</span><br><span class="line">    book_id serial PRIMARY KEY,</span><br><span class="line">    title VARCHAR NOT NULL,</span><br><span class="line">    isbn VARCHAR NOT NULL,</span><br><span class="line">    published_date DATE NOT NULL,</span><br><span class="line">    description VARCHAR,</span><br><span class="line">    category_id INT NOT NULL,</span><br><span class="line">    publisher_id INT NOT NULL,</span><br><span class="line">    FOREIGN KEY (publisher_id) REFERENCES publishers (publisher_id),</span><br><span class="line">    FOREIGN KEY (category_id) REFERENCES categories (category_id)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建视图</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE VIEW book_info AS SELECT</span></span><br><span class="line">    book_id,</span><br><span class="line">    title,</span><br><span class="line">    isbn,</span><br><span class="line">    published_date,</span><br><span class="line">    name</span><br><span class="line">FROM</span><br><span class="line">    books b</span><br><span class="line">INNER JOIN publishers P ON P .publisher_id = b.publisher_id</span><br><span class="line">ORDER BY</span><br><span class="line">    title;</span><br><span class="line">CREATE VIEW</span><br></pre></td></tr></table></figure>
<blockquote>
<p>假设您要删除books表的category_id列，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE books DROP COLUMN category_id;</span></span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看表结构</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; \d books;</span><br><span class="line">                                       数据表 <span class="string">"public.books"</span></span><br><span class="line">      栏位      |       类型        | 校对规则 |  可空的  |                  预设                  </span><br><span class="line">----------------+-------------------+----------+----------+----------------------------------------</span><br><span class="line"> book_id        | <span class="built_in">integer</span>           |          | not null | nextval(<span class="string">'books_book_id_seq'</span>::regclass)</span><br><span class="line"> title          | character varying |          | not null | </span><br><span class="line"> isbn           | character varying |          | not null | </span><br><span class="line"> published_date | date              |          | not null | </span><br><span class="line"> description    | character varying |          |          | </span><br><span class="line"> publisher_id   | <span class="built_in">integer</span>           |          | not null | </span><br><span class="line">索引：</span><br><span class="line">    <span class="string">"books_pkey"</span> PRIMARY KEY, btree (book_id)</span><br><span class="line">外部键(FK)限制：</span><br><span class="line">    <span class="string">"books_publisher_id_fkey"</span> FOREIGN KEY (publisher_id) REFERENCES publishers(publisher_id)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如上，该语句不仅删除了category_id列，还删除了涉及该列的外键约束category_id。</p>
</blockquote>
<blockquote>
<p>尝试删除publisher_id列：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE books DROP COLUMN publisher_id;</span></span><br><span class="line">错误:  无法删除 表 books的列publisher_id 因为有其它对象倚赖它</span><br><span class="line">DETAIL:  视图 book_info 倚赖于 表 books的列publisher_id</span><br><span class="line">HINT:  使用 DROP .. CASCADE 把倚赖对象一并删除.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如上所示book_info视图正在使用books表的column_id列。您需要使用CASCADE选项来删除Publisher_id列和book_info视图，如以下语句所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE books DROP COLUMN publisher_id CASCADE;</span></span><br><span class="line">注意:  递归删除 视图 book_info</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要在单个语句中同时删除isbn和description列，请添加多个DROP COLUMN子句，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE books</span></span><br><span class="line">  DROP COLUMN isbn,</span><br><span class="line">  DROP COLUMN description;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<h3 id="更改列类型"><a href="#更改列类型" class="headerlink" title="更改列类型"></a>更改列类型</h3><h4 id="更改列类型语法"><a href="#更改列类型语法" class="headerlink" title="更改列类型语法"></a>更改列类型语法</h4><blockquote>
<p>要更改列的数据类型，请使用ALTER TABLE语句，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">ALTER COLUMN column_name [SET DATA] TYPE new_data_type;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，在ALTER TABLE子句中指定要更改的列所属的表的名称。</li>
</ul>
<ul>
<li>其次，在ALTER COLUMN子句中输入其数据类型将更改的列的名称。</li>
</ul>
<ul>
<li>第三，在TYPE关键字之后为列提供新的数据类型。可以使用SET DATA TYPE或TYPE。</li>
</ul>
<blockquote>
<p>要在单个语句中更改多个列的数据类型，请使用以下语法：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">ALTER COLUMN column_name_1 [SET DATA] TYPE new_data_type,</span><br><span class="line">ALTER COLUMN column_name_2 [SET DATA] TYPE new_data_type,</span><br><span class="line">...;</span><br></pre></td></tr></table></figure>
<ul>
<li>在此语法中，用逗号（，）分隔每个ALTER COLUMN子句，以便一次更改多个列的类型。</li>
</ul>
<blockquote>
<p>PostgreSQL允许通过添加USING子句，将旧的列值转换为新的列值，同时更改列的数据类型，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">ALTER COLUMN column_name TYPE new_data_type USING expression;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用USING子句可以从旧值中计算出新的列值。</li>
</ul>
<ul>
<li>如果省略USING子句，则PostgreSQL会将旧的列值隐式转换为新的列值。如果强制转换失败，PostgreSQL将发出错误，并要求您为USING子句提供转换表达式。</li>
</ul>
<ul>
<li>表达式可以像column_name :: new_data_type这样简单，例如price :: numeric，也可以像自定义函数一样复杂。</li>
</ul>
<h4 id="更改列类型示例"><a href="#更改列类型示例" class="headerlink" title="更改列类型示例"></a>更改列类型示例</h4><blockquote>
<p>创建一个名为assets的新表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE assets (</span></span><br><span class="line">    id serial PRIMARY KEY,</span><br><span class="line">    name TEXT NOT NULL,</span><br><span class="line">    asset_no VARCHAR NOT NULL,</span><br><span class="line">    description TEXT,</span><br><span class="line">    LOCATION TEXT,</span><br><span class="line">    acquired_date DATE NOT NULL</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">INSERT INTO assets (</span><br><span class="line">    NAME,</span><br><span class="line">    asset_no,</span><br><span class="line">    location,</span><br><span class="line">    acquired_date</span><br><span class="line">)</span><br><span class="line">VALUES</span><br><span class="line">    (</span><br><span class="line">        <span class="string">'Server'</span>,</span><br><span class="line">        <span class="string">'10001'</span>,</span><br><span class="line">        <span class="string">'Server room'</span>,</span><br><span class="line">        <span class="string">'2017-01-01'</span></span><br><span class="line">    ),</span><br><span class="line">    (</span><br><span class="line">        <span class="string">'UPS'</span>,</span><br><span class="line">        <span class="string">'10002'</span>,</span><br><span class="line">        <span class="string">'Server room'</span>,</span><br><span class="line">        <span class="string">'2018-08-08'</span></span><br><span class="line">	);</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line">INSERT 0 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将name列的数据类型更改为VARCHAR:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE assets ALTER COLUMN name TYPE VARCHAR;</span></span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将description和location列的数据类型从TEXT更改为VARCHAR:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE assets</span></span><br><span class="line">    ALTER COLUMN location TYPE VARCHAR,</span><br><span class="line">    ALTER COLUMN description TYPE VARCHAR;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将asset_no列的数据类型更改为整数</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE assets ALTER COLUMN asset_no TYPE INT;</span></span><br><span class="line">错误:  字段 <span class="string">"asset_no"</span> 不能自动转换成类型 <span class="built_in">integer</span></span><br><span class="line">HINT:  您可能需要指定<span class="string">"USING asset_no::integer"</span>。</span><br></pre></td></tr></table></figure>
<ul>
<li>PostgreSQL发出一个错误和一个非常有用的提示，要求您指定USING子句。</li>
</ul>
<blockquote>
<p>添加USING子句</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE assets</span></span><br><span class="line">    ALTER COLUMN asset_no TYPE INT USING asset_no::<span class="built_in">integer</span>;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<h3 id="RENAME-COLUMN子句"><a href="#RENAME-COLUMN子句" class="headerlink" title="RENAME COLUMN子句"></a>RENAME COLUMN子句</h3><h4 id="RENAME-COLUMN子句的语法"><a href="#RENAME-COLUMN子句的语法" class="headerlink" title="RENAME COLUMN子句的语法"></a>RENAME COLUMN子句的语法</h4><blockquote>
<p>要重命名表的列，请使用带有RENAME COLUMN子句的ALTER TABLE语句，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">RENAME COLUMN column_name TO new_column_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，在ALTER TABLE子句之后，指定包含要重命名的列的表。</li>
</ul>
<ul>
<li>其次，在RENAME COLUMN子句后提供列名。</li>
</ul>
<ul>
<li>第三，在TO关键字之后输入新的列名称。</li>
</ul>
<blockquote>
<p>语句中的COLUMN关键字是可选的，因此可以忽略它，如以下语句所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">RENAME column_name TO new_column_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果尝试重命名不存在的列，PostgreSQL将发出错误。</li>
</ul>
<blockquote>
<p>要重命名多列，需要多次执行ALTER TABLE RENAME COLUMN语句，一次重命名一列:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">RENAME column_name_1 TO new_column_name_1;</span><br><span class="line"> </span><br><span class="line">ALTER TABLE table_name</span><br><span class="line">RENAME column_name_2 TO new_column_name_2;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果重命名由其他数据库对象（例如视图，外键约束，触发器和存储过程）引用的列，则PostgreSQL还将更改其所有从属对象。</p>
</blockquote>
<h4 id="RENAME-COLUMN示例"><a href="#RENAME-COLUMN示例" class="headerlink" title="RENAME COLUMN示例"></a>RENAME COLUMN示例</h4><blockquote>
<p>首先，创建两个新表cust和cust_groups。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE cust_groups (</span></span><br><span class="line">    id serial PRIMARY KEY,</span><br><span class="line">    name VARCHAR NOT NULL</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">CREATE TABLE cust (</span><br><span class="line">    id serial PRIMARY KEY,</span><br><span class="line">    name VARCHAR NOT NULL,</span><br><span class="line">    phone VARCHAR NOT NULL,</span><br><span class="line">    email VARCHAR,</span><br><span class="line">    group_id INT,</span><br><span class="line">    FOREIGN KEY (group_id) REFERENCES cust_groups (id)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后，基于cust和cust_groups表创建一个名为cust_data的新视图。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE VIEW cust_data</span></span><br><span class="line">AS SELECT</span><br><span class="line">    c.id,</span><br><span class="line">    c.name,</span><br><span class="line">    g.name cust_group</span><br><span class="line">FROM</span><br><span class="line">    cust c</span><br><span class="line">INNER JOIN cust_groups g ON g.id = c.group_id;</span><br><span class="line">CREATE VIEW</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用ALTER TABLE RENAME COLUMN语句将cust表的email列重命名为contact_email</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE cust</span></span><br><span class="line">RENAME COLUMN email TO contact_email;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用RENAME COLUMN重命名具有从属对象的列。将cust_groups表的name列重命名为group_name。 name列用于customer_data视图。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE cust_groups</span></span><br><span class="line">RENAME COLUMN name TO group_name;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>检查name列的更改是否已级联到cust_data视图</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt;  \d+ cust_data</span><br><span class="line">                           视图 <span class="string">"public.cust_data"</span></span><br><span class="line">    栏位    |       类型        | 校对规则 | 可空的 | 预设 |   存储   | 描述 </span><br><span class="line">------------+-------------------+----------+--------+------+----------+------</span><br><span class="line"> id         | <span class="built_in">integer</span>           |          |        |      | plain    | </span><br><span class="line"> name       | character varying |          |        |      | extended | </span><br><span class="line"> cust_group | character varying |          |        |      | extended | </span><br><span class="line">视图定义:</span><br><span class="line"> SELECT c.id,</span><br><span class="line">    c.name,</span><br><span class="line">    g.group_name AS cust_group</span><br><span class="line">   FROM cust c</span><br><span class="line">     JOIN cust_groups g ON g.id = c.group_id;</span><br></pre></td></tr></table></figure>
<ul>
<li>正如您在视图定义中看到的，name列已更改为group_name。</li>
</ul>
<blockquote>
<p>使用多个RENAME COLUMN重命名多个列。分别将customers表的两列name和phone重命名为customer_name和contact_phone。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE cust</span></span><br><span class="line">RENAME COLUMN name TO customer_name;</span><br><span class="line"> </span><br><span class="line">ALTER TABLE cust</span><br><span class="line">RENAME COLUMN phone TO contact_phone;</span><br><span class="line">ALTER TABLE</span><br><span class="line"></span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<h3 id="DROP-TABLE语句"><a href="#DROP-TABLE语句" class="headerlink" title="DROP TABLE语句"></a>DROP TABLE语句</h3><h4 id="DROP-TABLE语法"><a href="#DROP-TABLE语法" class="headerlink" title="DROP TABLE语法"></a>DROP TABLE语法</h4><blockquote>
<p>要从数据库中删除现有表，请使用DROP TABLE语句</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] table_name [CASCADE | RESTRICT];</span><br></pre></td></tr></table></figure>
<ul>
<li>可以在DROP TABLE关键字之后指定表名称，以从数据库中永久删除该表。</li>
</ul>
<ul>
<li>如果删除不存在的表，PostgreSQL会发出一个错误。为了避免这种情况，可以使用IF EXISTS参数，后跟DROP TABLE子句。</li>
</ul>
<ul>
<li>如果要删除的表用在视图、约束或任何其他对象中，则CASCADE允许您将那些从属对象与表一起自动删除。</li>
</ul>
<ul>
<li>如果有任何对象依赖，RESTRICT拒绝删除表。 PostgreSQL默认使用RESTRICT。</li>
</ul>
<ul>
<li><p>可以在DROP TABLE之后放置一个表列表，以一次删除多个表，每个表之间用逗号分隔。</p>
</li>
<li><p>请注意，只有超级用户，schema所有者和表所有者才具有删除表的足够特权。</p>
</li>
</ul>
<h4 id="DROP-TABLE示例"><a href="#DROP-TABLE示例" class="headerlink" title="DROP TABLE示例"></a>DROP TABLE示例</h4><blockquote>
<p>在数据库中删除名为author的表:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">est=<span class="comment"># DROP TABLE author;</span></span><br><span class="line">错误:  表 <span class="string">"author"</span> 不存在</span><br></pre></td></tr></table></figure>
<ul>
<li>PostgreSQL发出错误，因为author表不存在。</li>
</ul>
<blockquote>
<p>为避免此错误，可以使用IF EXISTS参数。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DROP TABLE IF EXISTS author;</span></span><br><span class="line">注意:  表 <span class="string">"author"</span> 不存在</span><br><span class="line">DROP TABLE</span><br></pre></td></tr></table></figure>
<ul>
<li>从输出中可以清楚地看到，PostgreSQL发出通知而不是错误。</li>
</ul>
<blockquote>
<p>创建名为author和page的新表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE author (</span></span><br><span class="line">   author_id INT NOT NULL PRIMARY KEY,</span><br><span class="line">   firstname VARCHAR (50),</span><br><span class="line">   lastname VARCHAR (50)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">CREATE TABLE page (</span><br><span class="line">   page_id serial PRIMARY KEY,</span><br><span class="line">   title VARCHAR (255) NOT NULL,</span><br><span class="line">   CONTENT TEXT,</span><br><span class="line">   author_id INT NOT NULL,</span><br><span class="line">   FOREIGN KEY (author_id) REFERENCES author (author_id)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下语句删除author表：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DROP TABLE IF EXISTS author;</span></span><br><span class="line">错误:  无法删除 表 author 因为有其它对象倚赖它</span><br><span class="line">DETAIL:  在表 page上的约束page_author_id_fkey  倚赖于 表 author</span><br><span class="line">HINT:  使用 DROP .. CASCADE 把倚赖对象一并删除.</span><br></pre></td></tr></table></figure>
<ul>
<li>因为page表的约束取决于author表，所以PostgreSQL发出一条错误消息。</li>
</ul>
<blockquote>
<p>在这种情况下，需要先删除所有依赖对象，然后再删除author表或使用CASCADE参数，如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DROP TABLE author CASCADE;</span></span><br><span class="line">注意:  递归删除 在表 page上的约束page_author_id_fkey</span><br><span class="line">DROP TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PostgreSQL删除了author表以及page表中的约束。另外，它发出通知。</p>
</blockquote>
<h3 id="TRUNCATE-TABLE语句"><a href="#TRUNCATE-TABLE语句" class="headerlink" title="TRUNCATE TABLE语句"></a>TRUNCATE TABLE语句</h3><blockquote>
<p>要从表中删除所有数据，请使用DELETE语句。但是，对于大表，使用TRUNCATE TABLE语句效率更高。</p>
</blockquote>
<blockquote>
<p>TRUNCATE TABLE语句从表中删除所有行，而无需对其进行扫描。这就是为什么它比DELETE语句快的原因。</p>
</blockquote>
<blockquote>
<p>此外，TRUNCATE TABLE语句可以立即回收存储，因此不必执行后续的VACUMM操作，这在大表的情况下很有用。</p>
</blockquote>
<h4 id="从一个表中删除所有数据"><a href="#从一个表中删除所有数据" class="headerlink" title="从一个表中删除所有数据"></a>从一个表中删除所有数据</h4><blockquote>
<p>TRUNCATE TABLE语句的最简单形式如下:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE table_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如，要从invoices表中删除所有行，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE invoices;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>TRUNCATE TABLE语句不仅可以从表中删除所有数据，还可以通过指定RESTART IDENTITY选项来重置关联的序列生成器:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE table_name RESTART IDENTITY;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如，要从invoices表中删除所有行并重置与invoice_no列关联的序列，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE invoices RESTART IDENTITY;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认情况下，TRUNCATE TABLE语句不会重置关联的序列。您可以在语句中显式使用CONTINUE IDENTITY选项来保留序列。但是，这不是必需的。</p>
</blockquote>
<h4 id="从多个表中删除所有数据"><a href="#从多个表中删除所有数据" class="headerlink" title="从多个表中删除所有数据"></a>从多个表中删除所有数据</h4><blockquote>
<p>要一次从多个表中删除所有数据，请用逗号(，)分隔每个表，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE table_name1, table_name2, …</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如，以下语句从invoices和customers表中删除所有数据：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE invoices, customers;</span><br></pre></td></tr></table></figure>
<h4 id="从具有外键引用的表中删除所有数据"><a href="#从具有外键引用的表中删除所有数据" class="headerlink" title="从具有外键引用的表中删除所有数据"></a>从具有外键引用的表中删除所有数据</h4><blockquote>
<p>实际上，要截断的表通常具有来自其他表的外键引用，这些外键引用未在TRUNCATE TABLE语句中列出。默认情况下，TRUNCATE TABLE语句不会从具有外键引用的表中删除任何数据。</p>
</blockquote>
<blockquote>
<p>要从主表和具有对该主表的外键引用的所有表中删除数据，请使用CASCADE选项，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE table_name CASCADE;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如，要从invoices表中删除所有数据并通过invoices外键约束级联到引用该表的任何表，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE invoices CASCADE;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 CASCADE 选项时应格外小心，否则可能会从您不希望删除的表中删除数据。</p>
</blockquote>
<h4 id="TRUNCATE-TABLE和ON-DELETE触发器"><a href="#TRUNCATE-TABLE和ON-DELETE触发器" class="headerlink" title="TRUNCATE TABLE和ON DELETE触发器"></a>TRUNCATE TABLE和ON DELETE触发器</h4><blockquote>
<p>即使TRUNCATE TABLE语句从表中删除了所有数据，它也不会触发与该表关联的任何ON DELETE触发器。</p>
</blockquote>
<blockquote>
<p>要在将TRUNCATE TABLE命令应用于表时触发该触发器，必须为该表定义BEFORE TRUNCATE和/或AFTER TRUNCATE触发器。</p>
</blockquote>
<h4 id="TRUNCATE-TABLE和事务"><a href="#TRUNCATE-TABLE和事务" class="headerlink" title="TRUNCATE TABLE和事务"></a>TRUNCATE TABLE和事务</h4><blockquote>
<p>TRUNCATE TABLE是事务安全的。这意味着，如果将其放置在诸如BEGIN…ROLLBACK之类的事务语句中，则截断操作将被安全地回滚。</p>
</blockquote>
<h3 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h3><blockquote>
<p>临时表，顾名思义，是一个暂时存在的表，在数据库会话期间一直存在。PostgreSQL在会话或事务结束时自动删除临时表。</p>
</blockquote>
<h4 id="创建临时表语法"><a href="#创建临时表语法" class="headerlink" title="创建临时表语法"></a>创建临时表语法</h4><blockquote>
<p>要创建临时表，请使用CREATE TEMPORARY TABLE语句:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TEMPORARY TABLE temp_table(</span><br><span class="line">   ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以使用TEMP而不是TEMPORARY关键字:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TEMP TABLE temp_table(</span><br><span class="line">   ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>临时表仅对创建它的会话可见。换句话说，它对于其他会话仍然不可见。</p>
</blockquote>
<h4 id="临时表示例"><a href="#临时表示例" class="headerlink" title="临时表示例"></a>临时表示例</h4><blockquote>
<p>首先，创建一个名为mytemp的临时表，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; CREATE TEMP TABLE mytemp(c INT);</span><br><span class="line">CREATE TABLE</span><br><span class="line"><span class="built_in">test</span>=&gt; SELECT * FROM mytemp;</span><br><span class="line"> c </span><br><span class="line">---</span><br><span class="line">(0 行记录)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后，启动另一个连接到test数据库的会话，并从mytemp表查询数据：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT * FROM mytemp;</span></span><br><span class="line">错误:  关系 <span class="string">"mytemp"</span> 不存在</span><br><span class="line">LINE 1: SELECT * FROM mytemp</span><br><span class="line">                      ^</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看到，第二个会话看不到mytemp表。只有第一个会话可以访问它。</li>
</ul>
<blockquote>
<p>之后，退出所有会话:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; \q</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后，再次登录数据库服务器并从mytemp表查询数据</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; SELECT * FROM mytemp;</span><br><span class="line">错误:  关系 <span class="string">"mytemp"</span> 不存在</span><br><span class="line">第1行SELECT * FROM mytemp;</span><br></pre></td></tr></table></figure>
<ul>
<li>mytemp表不存在，因为在会话结束时已自动将其删除，因此PostgreSQL发出错误。</li>
</ul>
<h4 id="临时表表名"><a href="#临时表表名" class="headerlink" title="临时表表名"></a>临时表表名</h4><blockquote>
<p>临时表可以与永久表共享相同的名称，即使不建议这样做。当您创建一个与永久表同名的临时表时，除非删除该临时表，否则将无法访问该永久表。</p>
</blockquote>
<blockquote>
<p>首先，创建一个名为test7的表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE test7(id SERIAL PRIMARY KEY, name VARCHAR NOT NULL);</span></span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其次，创建一个具有相同名称的临时表test7</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TEMP TABLE test7(test_id INT);</span></span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在，从test7表中查询数据</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; SELECT * FROM test7;</span><br><span class="line"> test_id </span><br><span class="line">---------</span><br><span class="line">(0 行记录)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PostgreSQL访问临时表客户而不是永久表客户。从现在开始，仅当显式删除临时表客户时，才能在当前会话中访问永久客户表。</p>
</blockquote>
<blockquote>
<p>请注意，PostgreSQL在特殊模式中创建临时表，因此，不得在CREATE TEMP TABLE语句中指定模式。</p>
</blockquote>
<blockquote>
<p>如果在数据库中列出表，则只会看到临时表客户，而不是永久表客户：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; \d test7</span><br><span class="line">           数据表 <span class="string">"pg_temp_4.test7"</span></span><br><span class="line">  栏位   |  类型   | 校对规则 | 可空的 | 预设 </span><br><span class="line">---------+---------+----------+--------+------</span><br><span class="line"> test_id | <span class="built_in">integer</span> |          |        |</span><br></pre></td></tr></table></figure>
<ul>
<li>输出显示test7临时表的模式为pg_temp_4。</li>
</ul>
<h4 id="删除PostgreSQL临时表"><a href="#删除PostgreSQL临时表" class="headerlink" title="删除PostgreSQL临时表"></a>删除PostgreSQL临时表</h4><blockquote>
<p>要删除临时表，请使用DROP TABLE语句。以下语句说明了如何删除临时表:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE temp_table_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>与CREATE TABLE语句不同，DROP TABLE语句没有专门为临时表创建的TEMP或TEMPORARY关键字。</p>
</blockquote>
<blockquote>
<p>例如，以下语句将删除在上面的示例中创建的临时表test7：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; DROP TABLE test7;</span><br><span class="line">DROP TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果再次在数据库中列出表，则永久表客户将显示如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; \d test7</span><br><span class="line">                               数据表 <span class="string">"public.test7"</span></span><br><span class="line"> 栏位 |       类型        | 校对规则 |  可空的  |               预设                </span><br><span class="line">------+-------------------+----------+----------+-----------------------------------</span><br><span class="line"> id   | <span class="built_in">integer</span>           |          | not null | nextval(<span class="string">'test7_id_seq'</span>::regclass)</span><br><span class="line"> name | character varying |          | not null | </span><br><span class="line">索引：</span><br><span class="line">    <span class="string">"test7_pkey"</span> PRIMARY KEY, btree (id)</span><br></pre></td></tr></table></figure>
<h3 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h3><h4 id="复制表语句语法"><a href="#复制表语句语法" class="headerlink" title="复制表语句语法"></a>复制表语句语法</h4><blockquote>
<p>要完全复制一个表，包括表结构和数据，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE new_table AS</span><br><span class="line">TABLE existing_table;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要复制不包含数据的表结构，可将WITH NO DATA子句添加到CREATE TABLE语句中，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE new_table AS</span><br><span class="line">TABLE existing_table</span><br><span class="line">WITH NO DATA;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要从现有表复制包含部分数据的表，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE new_table AS</span><br><span class="line">SELECT</span><br><span class="line">*</span><br><span class="line">FROM</span><br><span class="line">    existing_table</span><br><span class="line">WHERE</span><br><span class="line">    condition;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>WHERE查询子句中的条件定义了现有表的哪些行将被复制到新表。</p>
</blockquote>
<blockquote>
<p>请注意，以上所有语句均复制表结构和数据，但不复制现有表的索引和约束。</p>
</blockquote>
<h4 id="复制表示例"><a href="#复制表示例" class="headerlink" title="复制表示例"></a>复制表示例</h4><blockquote>
<p>创建一个名为contacts的新表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE contacts(</span></span><br><span class="line">    id SERIAL PRIMARY KEY,</span><br><span class="line">    first_name VARCHAR NOT NULL,</span><br><span class="line">    last_name VARCHAR NOT NULL,</span><br><span class="line">    email VARCHAR NOT NULL UNIQUE</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在该表中有两个索引：一个索引用于主键，另一个索引用于UNIQUE约束。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO contacts(first_name, last_name, email)</span></span><br><span class="line">VALUES(<span class="string">'John'</span>,<span class="string">'Doe'</span>,<span class="string">'john@pg.com'</span>),</span><br><span class="line">      (<span class="string">'David'</span>,<span class="string">'William'</span>,<span class="string">'david@pg.com'</span>);</span><br><span class="line">INSERT 0 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将联系人复制到新表（例如，contacts_backup表）中</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE contact_backup</span></span><br><span class="line">AS TABLE contacts;</span><br><span class="line">SELECT 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该语句创建一个名为contact_backup的新表，该表的结构与contacts表相同。 此外，它将数据从联系人表复制到contact_backup表。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT * FROM contact_backup;</span></span><br><span class="line"> id | first_name | last_name |    email</span><br><span class="line">----+------------+-----------+--------------</span><br><span class="line">  1 | John       | Doe       | john@pg.com</span><br><span class="line">  2 | David      | William   | david@pg.com</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>检查表结构</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>-&gt; \d contacts</span><br><span class="line">                                  数据表 <span class="string">"public.contacts"</span></span><br><span class="line">    栏位    |       类型        | 校对规则 |  可空的  |                 预设                 </span><br><span class="line">------------+-------------------+----------+----------+--------------------------------------</span><br><span class="line"> id         | <span class="built_in">integer</span>           |          | not null | nextval(<span class="string">'contacts_id_seq'</span>::regclass)</span><br><span class="line"> first_name | character varying |          | not null | </span><br><span class="line"> last_name  | character varying |          | not null | </span><br><span class="line"> email      | character varying |          | not null | </span><br><span class="line">索引：</span><br><span class="line">    <span class="string">"contacts_pkey"</span> PRIMARY KEY, btree (id)</span><br><span class="line">    <span class="string">"contacts_email_key"</span> UNIQUE CONSTRAINT, btree (email)</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>-&gt; \d contact_backup</span><br><span class="line">              数据表 <span class="string">"public.contact_backup"</span></span><br><span class="line">    栏位    |       类型        | 校对规则 | 可空的 | 预设 </span><br><span class="line">------------+-------------------+----------+--------+------</span><br><span class="line"> id         | <span class="built_in">integer</span>           |          |        | </span><br><span class="line"> first_name | character varying |          |        | </span><br><span class="line"> last_name  | character varying |          |        | </span><br><span class="line"> email      | character varying |          |        |</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要将主键和UNIQUE约束添加到contact_backup表中，请使用以下ALTER TABLE语句:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE contact_backup ADD PRIMARY KEY(id);</span></span><br><span class="line">ALTER TABLE contact_backup ADD UNIQUE(email);</span><br><span class="line">ALTER TABLE</span><br><span class="line"></span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>再次查看表结构</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>-&gt; \d contact_backup</span><br><span class="line">               数据表 <span class="string">"public.contact_backup"</span></span><br><span class="line">    栏位    |       类型        | 校对规则 |  可空的  | 预设 </span><br><span class="line">------------+-------------------+----------+----------+------</span><br><span class="line"> id         | <span class="built_in">integer</span>           |          | not null | </span><br><span class="line"> first_name | character varying |          |          | </span><br><span class="line"> last_name  | character varying |          |          | </span><br><span class="line"> email      | character varying |          |          | </span><br><span class="line">索引：</span><br><span class="line">    <span class="string">"contact_backup_pkey"</span> PRIMARY KEY, btree (id)</span><br><span class="line">    <span class="string">"contact_backup_email_key"</span> UNIQUE CONSTRAINT, btree (email)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    
    
    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="zhijiansd.github.io/blog/pg8/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhiJian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhiJian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/pg8/" class="post-title-link" itemprop="zhijiansd.github.io/page/2/index.html">PostgreSQL之数据处理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-20 11:40:25 / 修改时间：12:15:09" itemprop="dateCreated datePublished" datetime="2020-05-20T11:40:25+08:00">2020-05-20</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/postresql/" itemprop="url" rel="index"><span itemprop="name">postresql</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/pg8/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/pg8/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">27k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">44 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><h3 id="INSERT语句"><a href="#INSERT语句" class="headerlink" title="INSERT语句"></a>INSERT语句</h3><blockquote>
<p>创建新表时，它没有任何数据。您经常要做的第一件事是在表中插入新行。PostgreSQL提供了INSERT语句，使您可以一次将一个或多个行插入到一个表中。</p>
</blockquote>
<h4 id="INSERT语法"><a href="#INSERT语法" class="headerlink" title="INSERT语法"></a>INSERT语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table(column1, column2, …)</span><br><span class="line">VALUES</span><br><span class="line">   (value1, value2, …);</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，指定要在INSERT INTO子句之后插入新行的表的名称，后跟一个逗号分隔的列列表。</li>
</ul>
<ul>
<li>其次，在VALUES子句后列出一个逗号分隔的值列表。值列表必须与表名称后指定的列列表的顺序相同。</li>
</ul>
<blockquote>
<p>要一次将多个行添加到一个表中，请使用以下语法:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table (column1, column2, …)</span><br><span class="line">VALUES</span><br><span class="line">   (value1, value2, …),</span><br><span class="line">   (value1, value2, …) ,...;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只需要在第一个列表后添加其他逗号分隔值列表，列表中的每个值都用逗号（，）分隔。</p>
</blockquote>
<blockquote>
<p>要插入来自另一个表的数据，请使用INSERT INTO SELECT语句，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table(column1,column2,...)</span><br><span class="line">SELECT column1,column2,...</span><br><span class="line">FROM another_table</span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>WHERE子句用于过滤允许将another_table中的部分数据插入表中的行。</p>
</blockquote>
<h4 id="创建样表"><a href="#创建样表" class="headerlink" title="创建样表"></a>创建样表</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE link (</span></span><br><span class="line">   ID serial PRIMARY KEY,</span><br><span class="line">   url VARCHAR (255) NOT NULL,</span><br><span class="line">   name VARCHAR (255) NOT NULL,</span><br><span class="line">   description VARCHAR (255),</span><br><span class="line">   rel VARCHAR (50)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<h4 id="INSERT插入单行"><a href="#INSERT插入单行" class="headerlink" title="INSERT插入单行"></a>INSERT插入单行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO link (url, name)</span></span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'http://www.postgresql.com'</span>,<span class="string">'PostgreSQL'</span>);</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要插入字符数据，必须将其括在单引号（’）中，例如’PostgreSQL’。对于数字数据类型，只需使用纯数字（例如1、2、3）即可。</p>
</blockquote>
<blockquote>
<p>如果在INSERT语句中省略任何接受NULL值的列，则该列将采用其默认值。如果未为该列设置默认值，则该列将采用NULL值。</p>
</blockquote>
<blockquote>
<p>PostgreSQL会自动为serial列提供一个值，因此不能也不应该在串行列中插入一个值。</p>
</blockquote>
<blockquote>
<p>使用SELECT语句来验证插入的行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   link;</span><br><span class="line"> id |            url            |    name    | description | rel</span><br><span class="line">----+---------------------------+------------+-------------+------</span><br><span class="line">  1 | http://www.postgresql.com | PostgreSQL |             |</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要插入包含单引号字符的字符串（例如O’Reilly Media），则必须使用单引号（’）转义字符，如以下查询所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO link (url, name)</span></span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'http://www.oreilly.com'</span>,<span class="string">'O'</span><span class="string">'Reilly Media'</span>);</span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   link;</span><br><span class="line"> id |            url            |      name      | description | rel</span><br><span class="line">----+---------------------------+----------------+-------------+------</span><br><span class="line">  1 | http://www.postgresql.com | PostgreSQL     |             |</span><br><span class="line">  2 | http://www.oreilly.com    | O<span class="string">'Reilly Media |             |</span></span><br><span class="line"><span class="string">(2 rows)</span></span><br></pre></td></tr></table></figure>
<h4 id="INSERT插入多行"><a href="#INSERT插入多行" class="headerlink" title="INSERT插入多行"></a>INSERT插入多行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO link (url, name)</span></span><br><span class="line">VALUES</span><br><span class="line"> (<span class="string">'http://www.google.com'</span>,<span class="string">'Google'</span>),</span><br><span class="line"> (<span class="string">'http://www.yahoo.com'</span>,<span class="string">'Yahoo'</span>),</span><br><span class="line"> (<span class="string">'http://www.bing.com'</span>,<span class="string">'Bing'</span>);</span><br><span class="line">INSERT 0 3</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   link;</span><br><span class="line"> id |            url            |      name      | description | rel</span><br><span class="line">----+---------------------------+----------------+-------------+------</span><br><span class="line">  1 | http://www.postgresql.com | PostgreSQL     |             |</span><br><span class="line">  2 | http://www.oreilly.com    | O<span class="string">'Reilly Media |             |</span></span><br><span class="line"><span class="string">  3 | http://www.google.com     | Google         |             |</span></span><br><span class="line"><span class="string">  4 | http://www.yahoo.com      | Yahoo          |             |</span></span><br><span class="line"><span class="string">  5 | http://www.bing.com       | Bing           |             |</span></span><br><span class="line"><span class="string">(5 rows)</span></span><br></pre></td></tr></table></figure>
<h4 id="INSERT插入日期"><a href="#INSERT插入日期" class="headerlink" title="INSERT插入日期"></a>INSERT插入日期</h4><blockquote>
<p>在链接表中添加一个名为last_update的新列，并将其默认值设置为CURRENT_DATE。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE link ADD COLUMN last_update DATE;</span></span><br><span class="line"> </span><br><span class="line">ALTER TABLE link ALTER COLUMN last_update</span><br><span class="line">SET DEFAULT CURRENT_DATE;</span><br><span class="line">ALTER TABLE</span><br><span class="line"></span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在link表中插入具有指定日期的新行，日期格式为YYYY-MM-DD。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO link (url, name, last_update)</span></span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'http://www.facebook.com'</span>,<span class="string">'Facebook'</span>,<span class="string">'2013-06-01'</span>);</span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   link;</span><br><span class="line"> id |            url            |      name      | description | rel  | last_update</span><br><span class="line">----+---------------------------+----------------+-------------+------+-------------</span><br><span class="line">  1 | http://www.postgresql.com | PostgreSQL     |             |      |</span><br><span class="line">  2 | http://www.oreilly.com    | O<span class="string">'Reilly Media |             |      |</span></span><br><span class="line"><span class="string">  3 | http://www.google.com     | Google         |             |      |</span></span><br><span class="line"><span class="string">  4 | http://www.yahoo.com      | Yahoo          |             |      |</span></span><br><span class="line"><span class="string">  5 | http://www.bing.com       | Bing           |             |      |</span></span><br><span class="line"><span class="string">  6 | http://www.facebook.com   | Facebook       |             |      | 2013-06-01</span></span><br><span class="line"><span class="string">(6 rows)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>还可以使用DEFAULT关键字为date列或具有默认值的任何列设置默认值。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO link (url, name, last_update)</span></span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'https://www.tumblr.com/'</span>,<span class="string">'Tumblr'</span>,DEFAULT);</span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   link;</span><br><span class="line"> id |            url            |      name      | description | rel  | last_update</span><br><span class="line">----+---------------------------+----------------+-------------+------+-------------</span><br><span class="line">  1 | http://www.postgresql.com | PostgreSQL     |             |      |</span><br><span class="line">  2 | http://www.oreilly.com    | O<span class="string">'Reilly Media |             |      |</span></span><br><span class="line"><span class="string">  3 | http://www.google.com     | Google         |             |      |</span></span><br><span class="line"><span class="string">  4 | http://www.yahoo.com      | Yahoo          |             |      |</span></span><br><span class="line"><span class="string">  5 | http://www.bing.com       | Bing           |             |      |</span></span><br><span class="line"><span class="string">  6 | http://www.facebook.com   | Facebook       |             |      | 2013-06-01</span></span><br><span class="line"><span class="string">  7 | https://www.tumblr.com/   | Tumblr         |             |      | 2019-11-25</span></span><br><span class="line"><span class="string">(7 rows)</span></span><br></pre></td></tr></table></figure>
<h4 id="INSERT插入来自另一个表的数据"><a href="#INSERT插入来自另一个表的数据" class="headerlink" title="INSERT插入来自另一个表的数据"></a>INSERT插入来自另一个表的数据</h4><blockquote>
<p>首先，创建另一个表link_tmp，该link表具有与表相同的结构:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE link_tmp (LIKE link);</span></span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其次，从链接表中插入日期列的值不为NULL的行:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO link_tmp </span></span><br><span class="line">SELECT</span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   link</span><br><span class="line">WHERE</span><br><span class="line">   last_update IS NOT NULL;</span><br><span class="line">INSERT 0 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三，通过查询link_tmp表中的数据来验证插入操作:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   link_tmp;</span><br><span class="line"> id |           url           |   name   | description | rel  | last_update</span><br><span class="line">----+-------------------------+----------+-------------+------+-------------</span><br><span class="line">  6 | http://www.facebook.com | Facebook |             |      | 2013-06-01</span><br><span class="line">  7 | https://www.tumblr.com/ | Tumblr   |             |      | 2019-11-25</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h4 id="获取最后的插入ID"><a href="#获取最后的插入ID" class="headerlink" title="获取最后的插入ID"></a>获取最后的插入ID</h4><blockquote>
<p>要在插入新行后从表中获取最后一个插入ID，请在INSERT语句中使用RETURNING子句。这是PostgreSQL的SQL扩展。</p>
</blockquote>
<blockquote>
<p>以下语句在link表中插入新行，并返回最后一个插入ID:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO link (url, NAME, last_update)</span></span><br><span class="line">VALUES(<span class="string">'http://www.postgresql.org'</span>,<span class="string">'PostgreSQL'</span>,DEFAULT) </span><br><span class="line">RETURNING id;</span><br><span class="line"> id</span><br><span class="line">----</span><br><span class="line">  8</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   link;</span><br><span class="line"> id |            url            |      name      | description | rel  | last_update</span><br><span class="line">----+---------------------------+----------------+-------------+------+-------------</span><br><span class="line">  1 | http://www.postgresql.com | PostgreSQL     |             |      |</span><br><span class="line">  2 | http://www.oreilly.com    | O<span class="string">'Reilly Media |             |      |</span></span><br><span class="line"><span class="string">  3 | http://www.google.com     | Google         |             |      |</span></span><br><span class="line"><span class="string">  4 | http://www.yahoo.com      | Yahoo          |             |      |</span></span><br><span class="line"><span class="string">  5 | http://www.bing.com       | Bing           |             |      |</span></span><br><span class="line"><span class="string">  6 | http://www.facebook.com   | Facebook       |             |      | 2013-06-01</span></span><br><span class="line"><span class="string">  7 | https://www.tumblr.com/   | Tumblr         |             |      | 2019-11-25</span></span><br><span class="line"><span class="string">  8 | http://www.postgresql.org | PostgreSQL     |             |      | 2019-11-25</span></span><br><span class="line"><span class="string">(8 rows)</span></span><br></pre></td></tr></table></figure>
<h3 id="UPDATE语句"><a href="#UPDATE语句" class="headerlink" title="UPDATE语句"></a>UPDATE语句</h3><h4 id="UPDATE语法"><a href="#UPDATE语法" class="headerlink" title="UPDATE语法"></a>UPDATE语法</h4><blockquote>
<p>使用UPDATE语句来更新表中的现有数据。UPDATE语句的语法如下:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table</span><br><span class="line">SET column1 = value1,</span><br><span class="line">    column2 = value2 ,...</span><br><span class="line">WHERE</span><br><span class="line">   condition;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，在UPDATE子句后指定要在其中更新数据的表名。</li>
</ul>
<ul>
<li>其次，在SET子句中列出要更改其值的列。如果要更新多列中的值，请使用逗号（，）分隔每对列和值。 不在列表中的列保留其原始值。</li>
</ul>
<ul>
<li>第三，确定要在WHERE子句条件下更新的行。如果省略WHERE子句，则表中的所有行都会更新。</li>
</ul>
<h4 id="UPDATE更新单列"><a href="#UPDATE更新单列" class="headerlink" title="UPDATE更新单列"></a>UPDATE更新单列</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE link</span></span><br><span class="line">SET last_update = DEFAULT</span><br><span class="line">WHERE</span><br><span class="line">   id = 6;</span><br><span class="line">UPDATE 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   link</span><br><span class="line">WHERE</span><br><span class="line">   ID = 6;</span><br><span class="line"> id |           url           |   name   | description | rel  | last_update</span><br><span class="line">----+-------------------------+----------+-------------+------+-------------</span><br><span class="line">  6 | http://www.facebook.com | Facebook |             |      | 2019-11-26</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="UPDATE部分更新表"><a href="#UPDATE部分更新表" class="headerlink" title="UPDATE部分更新表"></a>UPDATE部分更新表</h4><blockquote>
<p>将last_update列的NULL值更改为当前日期</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE link</span></span><br><span class="line">SET last_update = DEFAULT</span><br><span class="line">WHERE</span><br><span class="line">   last_update IS NULL;</span><br><span class="line">UPDATE 5</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   link;</span><br><span class="line"> id |            url            |      name      | description | rel  | last_update</span><br><span class="line">----+---------------------------+----------------+-------------+------+-------------</span><br><span class="line">  7 | https://www.tumblr.com/   | Tumblr         |             |      | 2019-11-25</span><br><span class="line">  8 | http://www.postgresql.org | PostgreSQL     |             |      | 2019-11-25</span><br><span class="line">  1 | http://www.postgresql.com | PostgreSQL     |             |      | 2019-11-26</span><br><span class="line">  2 | http://www.oreilly.com    | O<span class="string">'Reilly Media |             |      | 2019-11-26</span></span><br><span class="line"><span class="string">  3 | http://www.google.com     | Google         |             |      | 2019-11-26</span></span><br><span class="line"><span class="string">  4 | http://www.yahoo.com      | Yahoo          |             |      | 2019-11-26</span></span><br><span class="line"><span class="string">  5 | http://www.bing.com       | Bing           |             |      | 2019-11-26</span></span><br><span class="line"><span class="string">  6 | http://www.facebook.com   | Facebook       |             |      | 2019-11-26</span></span><br><span class="line"><span class="string">(8 rows)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>WHERE子句仅更新last_update列中值为NULL的行。使用DEFAULT关键字是因为last_update列接受当前日期作为默认值。</p>
</blockquote>
<h4 id="UPDATE更新表中的所有行"><a href="#UPDATE更新表中的所有行" class="headerlink" title="UPDATE更新表中的所有行"></a>UPDATE更新表中的所有行</h4><blockquote>
<p>要将链接表中所有行的relcolumn值更新为nofollow，请在UPDATE语句中省略WHERE子句，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE link</span></span><br><span class="line">SET rel = <span class="string">'nofollow'</span>;</span><br><span class="line">UPDATE 8</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line"> * </span><br><span class="line">FROM</span><br><span class="line"> link;</span><br><span class="line"> id |            url            |      name      | description |   rel    | last_update</span><br><span class="line">----+---------------------------+----------------+-------------+----------+-------------</span><br><span class="line">  7 | https://www.tumblr.com/   | Tumblr         |             | nofollow | 2019-11-25</span><br><span class="line">  8 | http://www.postgresql.org | PostgreSQL     |             | nofollow | 2019-11-25</span><br><span class="line">  1 | http://www.postgresql.com | PostgreSQL     |             | nofollow | 2019-11-26</span><br><span class="line">  2 | http://www.oreilly.com    | O<span class="string">'Reilly Media |             | nofollow | 2019-11-26</span></span><br><span class="line"><span class="string">  3 | http://www.google.com     | Google         |             | nofollow | 2019-11-26</span></span><br><span class="line"><span class="string">  4 | http://www.yahoo.com      | Yahoo          |             | nofollow | 2019-11-26</span></span><br><span class="line"><span class="string">  5 | http://www.bing.com       | Bing           |             | nofollow | 2019-11-26</span></span><br><span class="line"><span class="string">  6 | http://www.facebook.com   | Facebook       |             | nofollow | 2019-11-26</span></span><br><span class="line"><span class="string">(8 rows)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>还可以更新同一表中另一列的列数据。以下语句将名称列的值复制到链接表的描述列中：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE link</span></span><br><span class="line">SET description = name;</span><br><span class="line">UPDATE 8</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line"> * </span><br><span class="line">FROM</span><br><span class="line"> link;</span><br><span class="line"> id |            url            |      name      |  description   |   rel    | last_update</span><br><span class="line">----+---------------------------+----------------+----------------+----------+-------------</span><br><span class="line">  7 | https://www.tumblr.com/   | Tumblr         | Tumblr         | nofollow | 2019-11-25</span><br><span class="line">  8 | http://www.postgresql.org | PostgreSQL     | PostgreSQL     | nofollow | 2019-11-25</span><br><span class="line">  1 | http://www.postgresql.com | PostgreSQL     | PostgreSQL     | nofollow | 2019-11-26</span><br><span class="line">  2 | http://www.oreilly.com    | O<span class="string">'Reilly Media | O'</span>Reilly Media | nofollow | 2019-11-26</span><br><span class="line">  3 | http://www.google.com     | Google         | Google         | nofollow | 2019-11-26</span><br><span class="line">  4 | http://www.yahoo.com      | Yahoo          | Yahoo          | nofollow | 2019-11-26</span><br><span class="line">  5 | http://www.bing.com       | Bing           | Bing           | nofollow | 2019-11-26</span><br><span class="line">  6 | http://www.facebook.com   | Facebook       | Facebook       | nofollow | 2019-11-26</span><br><span class="line">(8 rows)</span><br></pre></td></tr></table></figure>
<h4 id="UPDATE更新联接表"><a href="#UPDATE更新联接表" class="headerlink" title="UPDATE更新联接表"></a>UPDATE更新联接表</h4><blockquote>
<p>查看link_tmp表，它的结构与link表相同</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line"> * </span><br><span class="line">FROM</span><br><span class="line"> link_tmp;</span><br><span class="line"> id |           url           |   name   | description | rel  | last_update</span><br><span class="line">----+-------------------------+----------+-------------+------+-------------</span><br><span class="line">  6 | http://www.facebook.com | Facebook |             |      | 2013-06-01</span><br><span class="line">  7 | https://www.tumblr.com/ | Tumblr   |             |      | 2019-11-25</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下语句为link_tmp表中的列更新来自link表的值:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE link_tmp</span></span><br><span class="line">SET rel = link.rel,</span><br><span class="line"> description = link.description,</span><br><span class="line"> last_update = link.last_update</span><br><span class="line">FROM</span><br><span class="line">   link</span><br><span class="line">WHERE</span><br><span class="line">   link_tmp.id = link.id;</span><br><span class="line">UPDATE 2</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line"> * </span><br><span class="line">FROM</span><br><span class="line"> link_tmp;</span><br><span class="line"> id |           url           |   name   | description |   rel    | last_update</span><br><span class="line">----+-------------------------+----------+-------------+----------+-------------</span><br><span class="line">  6 | http://www.facebook.com | Facebook | Facebook    | nofollow | 2019-11-26</span><br><span class="line">  7 | https://www.tumblr.com/ | Tumblr   | Tumblr      | nofollow | 2019-11-25</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，这里在UPDATE语句中使用了FROM子句来指定涉及更新的第二个表（link）。</p>
</blockquote>
<blockquote>
<p>这种UPDATE语句有时称为UPDATE JOIN或UPDATE INNER JOIN，因为UPDATE语句中涉及两个或多个表。连接条件在WHERE子句中指定。</p>
</blockquote>
<h4 id="PostgreSQL-UPDATE与RETURNING子句"><a href="#PostgreSQL-UPDATE与RETURNING子句" class="headerlink" title="PostgreSQL UPDATE与RETURNING子句"></a>PostgreSQL UPDATE与RETURNING子句</h4><blockquote>
<p>UPDATE语句默认返回受影响的行数。PostgreSQL UPDATE语句还使用RETURNING子句返回更新的条目。这是PostgreSQL对SQL标准的扩展。</p>
</blockquote>
<blockquote>
<p>以下语句更新链接表中ID为1的行并返回更新的条目:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE link</span></span><br><span class="line">SET description = <span class="string">'Learn PostgreSQL'</span>,</span><br><span class="line"> rel = <span class="string">'follow'</span></span><br><span class="line">WHERE</span><br><span class="line">   ID = 1 </span><br><span class="line">RETURNING id,</span><br><span class="line">   description,</span><br><span class="line">   rel;</span><br><span class="line"> id |   description    |  rel</span><br><span class="line">----+------------------+--------</span><br><span class="line">  1 | Learn PostgreSQL | follow</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">UPDATE 1</span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   link</span><br><span class="line">WHERE</span><br><span class="line">   ID = 1;</span><br><span class="line"> id |            url            |    name    |   description    |  rel   | last_update</span><br><span class="line">----+---------------------------+------------+------------------+--------+-------------</span><br><span class="line">  1 | http://www.postgresql.com | PostgreSQL | Learn PostgreSQL | follow | 2019-11-26</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h3 id="UPDATE-JOIN"><a href="#UPDATE-JOIN" class="headerlink" title="UPDATE JOIN"></a>UPDATE JOIN</h3><blockquote>
<p>有时，您需要根据另一个表中的值更新表的数据。在这种情况下，您可以使用PostgreSQL UPDATE连接语法，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE A</span><br><span class="line">SET A.c1 = expresion</span><br><span class="line">FROM B</span><br><span class="line">WHERE A.c2 = B.c2;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果表A和B中的每一行在列c2中具有匹配的值，则这种形式的UPDATE语句将更新表A中的列值c1。</li>
</ul>
<blockquote>
<p>要联接到UPDATE语句中的另一个表，请在FROM子句中指定联接的表，并在WHERE子句中提供联接条件。FROM子句必须紧接在SET子句之后出现。 </p>
</blockquote>
<h4 id="创建示例表"><a href="#创建示例表" class="headerlink" title="创建示例表"></a>创建示例表</h4><blockquote>
<p>首先，创建一个名为product_segment的新表，该表存储诸如豪华，奢侈品和大众等产品细分。product_segment表具有折扣列，该列存储基于特定细分的折扣百分比。例如，豪华商品的折扣为5％，而奢侈品和大众商品的折扣分别为6％和10％。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE product_segment (</span></span><br><span class="line">    ID SERIAL PRIMARY KEY,</span><br><span class="line">    segment VARCHAR NOT NULL,</span><br><span class="line">    discount NUMERIC (4, 2)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">INSERT INTO product_segment (segment, discount)</span><br><span class="line">VALUES</span><br><span class="line">    (<span class="string">'Grand Luxury'</span>, 0.05),</span><br><span class="line">    (<span class="string">'Luxury'</span>, 0.06),</span><br><span class="line">    (<span class="string">'Mass'</span>, 0.1);</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line">INSERT 0 3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其次，创建另一个名为product的表，用于存储产品数据。产品表的外键列segment_id链接到segment表的ID。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE product(</span></span><br><span class="line">    id serial primary key,</span><br><span class="line">    name varchar not null,</span><br><span class="line">    price numeric(10,2),</span><br><span class="line">    net_price numeric(10,2),</span><br><span class="line">    segment_id int not null,</span><br><span class="line">    foreign key(segment_id) references product_segment(id)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">INSERT INTO product (name, price, segment_id) </span><br><span class="line">VALUES (<span class="string">'diam'</span>, 804.89, 1),</span><br><span class="line">    (<span class="string">'vestibulum aliquet'</span>, 228.55, 3),</span><br><span class="line">    (<span class="string">'lacinia erat'</span>, 366.45, 2),</span><br><span class="line">    (<span class="string">'scelerisque quam turpis'</span>, 145.33, 3),</span><br><span class="line">    (<span class="string">'justo lacinia'</span>, 551.77, 2),</span><br><span class="line">    (<span class="string">'ultrices mattis odio'</span>, 261.58, 3),</span><br><span class="line">    (<span class="string">'hendrerit'</span>, 519.62, 2),</span><br><span class="line">    (<span class="string">'in hac habitasse'</span>, 843.31, 1),</span><br><span class="line">    (<span class="string">'orci eget orci'</span>, 254.18, 3),</span><br><span class="line">    (<span class="string">'pellentesque'</span>, 427.78, 2),</span><br><span class="line">    (<span class="string">'sit amet nunc'</span>, 936.29, 1),</span><br><span class="line">    (<span class="string">'sed vestibulum'</span>, 910.34, 1),</span><br><span class="line">    (<span class="string">'turpis eget'</span>, 208.33, 3),</span><br><span class="line">    (<span class="string">'cursus vestibulum'</span>, 985.45, 1),</span><br><span class="line">    (<span class="string">'orci nullam'</span>, 841.26, 1),</span><br><span class="line">    (<span class="string">'est quam pharetra'</span>, 896.38, 1),</span><br><span class="line">    (<span class="string">'posuere'</span>, 575.74, 2),</span><br><span class="line">    (<span class="string">'ligula'</span>, 530.64, 2),</span><br><span class="line">    (<span class="string">'convallis'</span>, 892.43, 1),</span><br><span class="line">    (<span class="string">'nulla elit ac'</span>, 161.71, 3);</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line">INSERT 0 20</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三，假设需要根据产品细分的折扣计算每个产品的净价。为此，可以按以下方式应用UPDATE连接语句:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE product</span></span><br><span class="line">SET net_price = price - price * discount</span><br><span class="line">FROM</span><br><span class="line">product_segment</span><br><span class="line">WHERE</span><br><span class="line">product.segment_id = product_segment.id;</span><br><span class="line">UPDATE 20</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该语句将product表连接到product_segment表。如果两个表中都有匹配项，它将从product_segment表中获得折扣，根据以下公式计算净价，并更新net_price列:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net_price = price - price * discount;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用以下SELECT语句检查product表的数据:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    product;</span><br><span class="line"> id |          name           | price  | net_price | segment_id</span><br><span class="line">----+-------------------------+--------+-----------+------------</span><br><span class="line">  1 | diam                    | 804.89 |    764.65 |          1</span><br><span class="line">  2 | vestibulum aliquet      | 228.55 |    205.70 |          3</span><br><span class="line">  3 | lacinia erat            | 366.45 |    344.46 |          2</span><br><span class="line">  4 | scelerisque quam turpis | 145.33 |    130.80 |          3</span><br><span class="line">  5 | justo lacinia           | 551.77 |    518.66 |          2</span><br><span class="line">  6 | ultrices mattis odio    | 261.58 |    235.42 |          3</span><br><span class="line">  7 | hendrerit               | 519.62 |    488.44 |          2</span><br><span class="line">  8 | <span class="keyword">in</span> hac habitasse        | 843.31 |    801.14 |          1</span><br><span class="line">  9 | orci eget orci          | 254.18 |    228.76 |          3</span><br><span class="line"> 10 | pellentesque            | 427.78 |    402.11 |          2</span><br><span class="line"> 11 | sit amet nunc           | 936.29 |    889.48 |          1</span><br><span class="line"> 12 | sed vestibulum          | 910.34 |    864.82 |          1</span><br><span class="line"> 13 | turpis eget             | 208.33 |    187.50 |          3</span><br><span class="line"> 14 | cursus vestibulum       | 985.45 |    936.18 |          1</span><br><span class="line"> 15 | orci nullam             | 841.26 |    799.20 |          1</span><br><span class="line"> 16 | est quam pharetra       | 896.38 |    851.56 |          1</span><br><span class="line"> 17 | posuere                 | 575.74 |    541.20 |          2</span><br><span class="line"> 18 | ligula                  | 530.64 |    498.80 |          2</span><br><span class="line"> 19 | convallis               | 892.43 |    847.81 |          1</span><br><span class="line"> 20 | nulla elit ac           | 161.71 |    145.54 |          3</span><br><span class="line">(20 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>net_price列已更新为折扣后的价钱。</p>
</blockquote>
<h3 id="DELETE语句"><a href="#DELETE语句" class="headerlink" title="DELETE语句"></a>DELETE语句</h3><h4 id="DELETE语法"><a href="#DELETE语法" class="headerlink" title="DELETE语法"></a>DELETE语法</h4><blockquote>
<p>使用DELETE语句从表中删除数据。DELETE语法语法如下:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table</span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，在DELETE FROM子句中指定要从中删除数据的表。</li>
</ul>
<ul>
<li>其次，使用WHERE子句中的条件指定要删除的行。WHERE子句是可选的。但是，如果省略它，则DELETE语句将删除表中的所有行。DELETE语句返回已删除的行数。它可能与WHERE子句中的条件指定的行数不同，因为该表可能包含一个BEFORE DELETE触发器，该触发器在删除之前会执行其他操作。如果未删除任何行，则DELETE语句返回零。</li>
</ul>
<blockquote>
<p>如果要检查引用另一个表中一个或多个列的条件，请使用USING子句，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table</span><br><span class="line">USING another_table</span><br><span class="line">WHERE table.id = another_table.id AND …</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果不想使用USING子句，则可以使用以下语句中所示的子查询:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table</span><br><span class="line">WHERE table.id = (SELECT id FROM another_table);</span><br></pre></td></tr></table></figure>
<h4 id="DELETE-with-WHERE子句示例"><a href="#DELETE-with-WHERE子句示例" class="headerlink" title="DELETE with WHERE子句示例"></a>DELETE with WHERE子句示例</h4><blockquote>
<p>查看表内容</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   link;</span><br><span class="line"> id |            url            |      name      |   description    |   rel    | last_update</span><br><span class="line">----+---------------------------+----------------+------------------+----------+-------------</span><br><span class="line">  7 | https://www.tumblr.com/   | Tumblr         | Tumblr           | nofollow | 2019-11-25</span><br><span class="line">  8 | http://www.postgresql.org | PostgreSQL     | PostgreSQL       | nofollow | 2019-11-25</span><br><span class="line">  2 | http://www.oreilly.com    | O<span class="string">'Reilly Media | O'</span>Reilly Media   | nofollow | 2019-11-26</span><br><span class="line">  3 | http://www.google.com     | Google         | Google           | nofollow | 2019-11-26</span><br><span class="line">  4 | http://www.yahoo.com      | Yahoo          | Yahoo            | nofollow | 2019-11-26</span><br><span class="line">  5 | http://www.bing.com       | Bing           | Bing             | nofollow | 2019-11-26</span><br><span class="line">  6 | http://www.facebook.com   | Facebook       | Facebook         | nofollow | 2019-11-26</span><br><span class="line">  1 | http://www.postgresql.com | PostgreSQL     | Learn PostgreSQL | follow   | 2019-11-26</span><br><span class="line">(8 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下语句删除id列中值为8的行:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DELETE FROM link</span></span><br><span class="line">WHERE id = 8;</span><br><span class="line">DELETE 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该语句返回一个表示已删除一行的内容。</p>
</blockquote>
<blockquote>
<p>注意，如果链接表没有任何ID为8的行，则DELETE语句不执行任何操作并返回零（0）。</p>
</blockquote>
<h4 id="DELETE-USING语句示例"><a href="#DELETE-USING语句示例" class="headerlink" title="DELETE USING语句示例"></a>DELETE USING语句示例</h4><blockquote>
<p>假设要从link表中删除所有和link_tmp表具有相同id列值的行。首先，检查link_tmp表数据:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    link_tmp;</span><br><span class="line"> id |           url           |   name   | description |   rel    | last_update</span><br><span class="line">----+-------------------------+----------+-------------+----------+-------------</span><br><span class="line">  6 | http://www.facebook.com | Facebook | Facebook    | nofollow | 2019-11-26</span><br><span class="line">  7 | https://www.tumblr.com/ | Tumblr   | Tumblr      | nofollow | 2019-11-25</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其次，将下面的DELETE语句与USING子句一起使用，以删除link表中相应行:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DELETE FROM link </span></span><br><span class="line">USING link_tmp</span><br><span class="line">WHERE</span><br><span class="line">    link.id = link_tmp.id;</span><br><span class="line">DELETE 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>之后，查询link表以验证删除操作</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    link;</span><br><span class="line"> id |            url            |      name      |   description    |   rel    | last_update</span><br><span class="line">----+---------------------------+----------------+------------------+----------+-------------</span><br><span class="line">  2 | http://www.oreilly.com    | O<span class="string">'Reilly Media | O'</span>Reilly Media   | nofollow | 2019-11-26</span><br><span class="line">  3 | http://www.google.com     | Google         | Google           | nofollow | 2019-11-26</span><br><span class="line">  4 | http://www.yahoo.com      | Yahoo          | Yahoo            | nofollow | 2019-11-26</span><br><span class="line">  5 | http://www.bing.com       | Bing           | Bing             | nofollow | 2019-11-26</span><br><span class="line">  1 | http://www.postgresql.com | PostgreSQL     | Learn PostgreSQL | follow   | 2019-11-26</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure>
<h4 id="从表中删除所有行"><a href="#从表中删除所有行" class="headerlink" title="从表中删除所有行"></a>从表中删除所有行</h4><blockquote>
<p>从link表中删除所有行，请在DELETE语句中省略WHERE子句，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DELETE FROM link;</span></span><br><span class="line">DELETE 5</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要删除link_tmp表中的所有行并返回删除的行，请在DELETE语句中使用RETURNING子句，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DELETE FROM link_tmp </span></span><br><span class="line">RETURNING *;</span><br><span class="line"> id |           url           |   name   | description |   rel    | last_update</span><br><span class="line">----+-------------------------+----------+-------------+----------+-------------</span><br><span class="line">  6 | http://www.facebook.com | Facebook | Facebook    | nofollow | 2019-11-26</span><br><span class="line">  7 | https://www.tumblr.com/ | Tumblr   | Tumblr      | nofollow | 2019-11-25</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">DELETE 2</span><br></pre></td></tr></table></figure>
<h3 id="upsert功能"><a href="#upsert功能" class="headerlink" title="upsert功能"></a>upsert功能</h3><blockquote>
<p>在关系数据库中，术语upsert称为合并。这个想法是，当您在表中插入新行时，PostgreSQL将更新该行（如果已存在），否则，PostgreSQL将插入新行。这就是为什么我们称动作为upsert（更新或插入）的原因。</p>
</blockquote>
<blockquote>
<p>要在PostgreSQL中使用upsert功能，请使用INSERT ON CONFLICT语句，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table_name(column_list) VALUES(value_list)</span><br><span class="line">ON CONFLICT target action;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PostgreSQL将ON CONFLICT target action子句添加到INSERT语句中以支持upsert功能。</p>
</blockquote>
<blockquote>
<p>target可以是:</p>
<ul>
<li>(column_name)  —   列名</li>
</ul>
<ul>
<li>ON CONSTRAINT constraint_name  —  其中约束名称可以是UNIQUE约束的名称</li>
</ul>
<ul>
<li>WHERE predicate  —  带谓词的WHERE子句</li>
</ul>
</blockquote>
<blockquote>
<p>action可以是:</p>
<ul>
<li>DO NOTHING   —   表示如果表中已经存在该行，则不执行任何操作。</li>
</ul>
<ul>
<li>DO UPDATE SET column_1 = value_1, .. WHERE condition  —   更新表中的某些字段。</li>
</ul>
</blockquote>
<h3 id="创建样表-1"><a href="#创建样表-1" class="headerlink" title="创建样表"></a>创建样表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE test6 (</span></span><br><span class="line">   test_id serial PRIMARY KEY,</span><br><span class="line">   name VARCHAR UNIQUE,</span><br><span class="line">   email VARCHAR NOT NULL,</span><br><span class="line">   active bool NOT NULL DEFAULT TRUE</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该表由四列组成:test_id，name，email和active。名称列具有关联的唯一约束，以确保其唯一性。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; \d test6</span><br><span class="line">                                   数据表 <span class="string">"public.test6"</span></span><br><span class="line">  栏位   |       类型        | 校对规则 |  可空的  |                  预设                  </span><br><span class="line">---------+-------------------+----------+----------+----------------------------------------</span><br><span class="line"> test_id | <span class="built_in">integer</span>           |          | not null | nextval(<span class="string">'test6_test_id_seq'</span>::regclass)</span><br><span class="line"> name    | character varying |          |          | </span><br><span class="line"> email   | character varying |          | not null | </span><br><span class="line"> active  | boolean           |          | not null | <span class="literal">true</span></span><br><span class="line">索引：</span><br><span class="line">    <span class="string">"test6_pkey"</span> PRIMARY KEY, btree (test_id)</span><br><span class="line">    <span class="string">"test6_name_key"</span> UNIQUE CONSTRAINT, btree (name)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>插入数据</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test6 (NAME, email)</span></span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'IBM'</span>, <span class="string">'contact@ibm.com'</span>),</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'Microsoft'</span>,</span><br><span class="line">      <span class="string">'contact@microsoft.com'</span></span><br><span class="line">   ),</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'Intel'</span>,</span><br><span class="line">      <span class="string">'contact@intel.com'</span></span><br><span class="line">   );</span><br><span class="line">INSERT 0 3</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT * FROM test6;</span></span><br><span class="line"> test_id |   name    |         email         | active</span><br><span class="line">---------+-----------+-----------------------+--------</span><br><span class="line">       1 | IBM       | contact@ibm.com       | t</span><br><span class="line">       2 | Microsoft | contact@microsoft.com | t</span><br><span class="line">       3 | Intel     | contact@intel.com     | t</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<h3 id="PostgreSQL-upsert示例1"><a href="#PostgreSQL-upsert示例1" class="headerlink" title="PostgreSQL upsert示例1"></a>PostgreSQL upsert示例1</h3><blockquote>
<p>假设Microsoft将联系人电子邮件从<a href="mailto:contact@microsoft.com" target="_blank" rel="noopener">contact@microsoft.com</a>更改为<a href="mailto:hotline@microft.com" target="_blank" rel="noopener">hotline@microft.com</a>，我们可以使用UPDATE语句对其进行更新。但是，为了演示upsert功能，我们使用以下INSERT ON CONFLICT语句:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test6 (NAME, email)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'Microsoft'</span>,</span><br><span class="line">      <span class="string">'hotline@microsoft.com'</span></span><br><span class="line">   ) </span><br><span class="line">ON CONFLICT ON CONSTRAINT test6_name_key </span><br><span class="line">DO NOTHING;</span><br><span class="line">INSERT 0 0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该语句指定如果客户表中存在客户名称，则将其忽略（不执行任何操作）。</p>
</blockquote>
<blockquote>
<p>如下语句与上面的语句等效，但是它使用name列而不是唯一约束名称作为INSERT语句的目标:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test6 (name, email)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'Microsoft'</span>,</span><br><span class="line">      <span class="string">'hotline@microsoft.com'</span></span><br><span class="line">   ) </span><br><span class="line">ON CONFLICT (name) </span><br><span class="line">DO NOTHING;</span><br><span class="line">INSERT 0 0</span><br></pre></td></tr></table></figure>
<h3 id="PostgreSQL-upsert示例2"><a href="#PostgreSQL-upsert示例2" class="headerlink" title="PostgreSQL upsert示例2"></a>PostgreSQL upsert示例2</h3><blockquote>
<p>假设要在插入已经存在的客户时将新电子邮件与旧电子邮件连接起来，在这种情况下，将UPDATE子句用作INSERT语句的操作，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test6 (name, email)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'Microsoft'</span>,</span><br><span class="line">      <span class="string">'hotline@microsoft.com'</span></span><br><span class="line">   ) </span><br><span class="line">ON CONFLICT (name) </span><br><span class="line">DO</span><br><span class="line">      UPDATE</span><br><span class="line">     SET email = EXCLUDED.email || <span class="string">';'</span> || test6.email;</span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT * FROM test6;</span></span><br><span class="line"> test_id |   name    |                    email                    | active</span><br><span class="line">---------+-----------+---------------------------------------------+--------</span><br><span class="line">       1 | IBM       | contact@ibm.com                             | t</span><br><span class="line">       3 | Intel     | contact@intel.com                           | t</span><br><span class="line">       2 | Microsoft | hotline@microsoft.com;contact@microsoft.com | t</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><blockquote>
<p>数据库事务是一个工作单元，可能包含一个或多个操作。</p>
</blockquote>
<blockquote>
<p>PostgreSQL中的事务是原子的，一致的，隔离的和持久的。这些属性通常称为ACID:</p>
<ul>
<li>原子性保证了事务以全有或全无的方式完成。</li>
</ul>
<ul>
<li>一致性确保对写入数据库的数据所做的更改必须有效并且遵循预定义的规则。</li>
</ul>
<ul>
<li>隔离度确定其他事务如何看到事务完整性。</li>
</ul>
<ul>
<li>耐久性确保已提交的事务将被永久存储。</li>
</ul>
</blockquote>
<blockquote>
<p>事务的经典示例是从一个银行帐户转帐到另一个银行帐户。完整事务必须确保从发送者的帐户中减去一定金额，然后将相同的金额添加到接收者的帐户中。</p>
</blockquote>
<h3 id="创建样表-2"><a href="#创建样表-2" class="headerlink" title="创建样表"></a>创建样表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE accounts (</span></span><br><span class="line">    id INT GENERATED BY DEFAULT AS IDENTITY,</span><br><span class="line">    name VARCHAR(100) NOT NULL,</span><br><span class="line">    balance DEC(15,2) NOT NULL,</span><br><span class="line">    PRIMARY KEY(id)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<h3 id="开始事务"><a href="#开始事务" class="headerlink" title="开始事务"></a>开始事务</h3><blockquote>
<p>当执行以下INSERT语句时</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO accounts(name,balance)</span></span><br><span class="line">VALUES(<span class="string">'Bob'</span>,10000);</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这时候PostgreSQL会立即在accounts表中插入新行。在这种情况下，您不知道事务何时开始，也没有机会拦截更改（例如撤消更改）。</p>
</blockquote>
<blockquote>
<p>要开始事务，请使用以下语句:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BEGIN TRANSACTION;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BEGIN WORK;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如，以下语句开始一个新的事务并将一个新帐户插入到accounts表中:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># BEGIN;</span></span><br><span class="line"> </span><br><span class="line">INSERT INTO accounts(name,balance)</span><br><span class="line">VALUES(<span class="string">'Alice'</span>,10000);</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在当前会话中，可以通过查询accounts表来查看更改:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT </span></span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    balance</span><br><span class="line">FROM </span><br><span class="line">    accounts;</span><br><span class="line"> id | name  | balance</span><br><span class="line">----+-------+----------</span><br><span class="line">  1 | Bob   | 10000.00</span><br><span class="line">  2 | Alice | 10000.00</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>开启一个新的会话并执行上面的查询，这里将看不到任何更改。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT </span></span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    balance</span><br><span class="line">FROM </span><br><span class="line">    accounts;</span><br><span class="line"> id | name | balance</span><br><span class="line">----+------+----------</span><br><span class="line">  1 | Bob  | 10000.00</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h3 id="进行事务处理"><a href="#进行事务处理" class="headerlink" title="进行事务处理"></a>进行事务处理</h3><blockquote>
<p>为了使更改对其他会话（或用户）可见，需要使用以下语句来提交事务:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT WORK;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要么</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT TRANSACTION;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者简单地</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行COMMIT语句，将Alice的帐户插入帐户表:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># COMMIT;</span></span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在在任何事务中，都可以通过查询accounts表来查看此更改</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT </span></span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    balance</span><br><span class="line">FROM </span><br><span class="line">    accounts;</span><br><span class="line"> id | name  | balance</span><br><span class="line">----+-------+----------</span><br><span class="line">  1 | Bob   | 10000.00</span><br><span class="line">  2 | Alice | 10000.00</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行该COMMIT语句后，PostgreSQL还保证如果发生崩溃，更改将是持久的。</p>
</blockquote>
<h3 id="PostgreSQL-COMMIT-银行帐户转帐示例1"><a href="#PostgreSQL-COMMIT-银行帐户转帐示例1" class="headerlink" title="PostgreSQL COMMIT:银行帐户转帐示例1"></a>PostgreSQL COMMIT:银行帐户转帐示例1</h3><blockquote>
<p>这里将展示如何从Bob的帐户向Alice的帐户转帐1000元。我们将使用两个会话来查看每个操作的更改。</p>
</blockquote>
<ul>
<li>在第一个会话中，我们开始一个新事务:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># BEGIN;</span></span><br><span class="line">BEGIN</span><br></pre></td></tr></table></figure>
<ul>
<li>从ID为1的Bob的帐户中减去1000元:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE accounts </span></span><br><span class="line">SET balance = balance - 1000</span><br><span class="line">WHERE id = 1;</span><br><span class="line">UPDATE 1</span><br></pre></td></tr></table></figure>
<ul>
<li>在第二个会话中，检查两个帐户的帐户余额：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT </span></span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    balance</span><br><span class="line">FROM </span><br><span class="line">    accounts;</span><br><span class="line"> id | name  | balance</span><br><span class="line">----+-------+----------</span><br><span class="line">  1 | Bob   | 10000.00</span><br><span class="line">  2 | Alice | 10000.00</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如上，该更改在其他会话中不可见。</p>
</blockquote>
<ul>
<li>接下来，我们向Alice的帐户中添加相同的金额（1000元）。当然在更改提交前在其他会话依然看不到此此更改:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE accounts</span></span><br><span class="line">SET balance = balance + 1000</span><br><span class="line">WHERE id = 2; </span><br><span class="line">UPDATE 1</span><br></pre></td></tr></table></figure>
<ul>
<li>提交更改</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># COMMIT;</span></span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure>
<ul>
<li>现在，您可以在任何会话中查看更改了:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT </span></span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    balance</span><br><span class="line">FROM </span><br><span class="line">    accounts;</span><br><span class="line"> id | name  | balance</span><br><span class="line">----+-------+----------</span><br><span class="line">  1 | Bob   |  9000.00</span><br><span class="line">  2 | Alice | 11000.00</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h3 id="回滚事务"><a href="#回滚事务" class="headerlink" title="回滚事务"></a>回滚事务</h3><blockquote>
<p>要回滚或撤消当前事务的更改，请使用以下任何语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK WORK;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK TRANSACTION;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或简而言之</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>
<h3 id="PostgreSQL-COMMIT-银行帐户转帐示例2"><a href="#PostgreSQL-COMMIT-银行帐户转帐示例2" class="headerlink" title="PostgreSQL COMMIT:银行帐户转帐示例2"></a>PostgreSQL COMMIT:银行帐户转帐示例2</h3><blockquote>
<p>假设您要将1500元从Bob的帐户转移到Alice的帐户。但是，您不小心将钱汇到了Jack的帐户而不是Alice的帐户。您想回滚整个事务。</p>
</blockquote>
<ul>
<li>首先，将Jack的帐户添加到accounts表中:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO accounts(name, balance)</span></span><br><span class="line">VALUES(<span class="string">'Jack'</span>,0);</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<ul>
<li>接下来，开启事务处理并从Bob的帐户中减去1500元:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># BEGIN;</span></span><br><span class="line"> </span><br><span class="line">UPDATE accounts </span><br><span class="line">SET balance = balance - 1500</span><br><span class="line">WHERE id = 1;</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">UPDATE 1</span><br></pre></td></tr></table></figure>
<ul>
<li>然后，将相同的金额添加到Alice的帐户中：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE accounts</span></span><br><span class="line">SET balance = balance + 1500</span><br><span class="line">WHERE id = 3; </span><br><span class="line">UPDATE 1</span><br></pre></td></tr></table></figure>
<ul>
<li>但是Alice的ID是2，这是一个错误。要撤消更改，请执行以下ROLLBACK语句:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ROLLBACK;</span></span><br><span class="line">ROLLBACK</span><br></pre></td></tr></table></figure>
<ul>
<li>最后，检查所有帐户的余额:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT </span></span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    balance</span><br><span class="line">FROM </span><br><span class="line">    accounts; </span><br><span class="line"> id | name  | balance</span><br><span class="line">----+-------+----------</span><br><span class="line">  1 | Bob   |  9000.00</span><br><span class="line">  2 | Alice | 11000.00</span><br><span class="line">  3 | Jack  |     0.00</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<h2 id="导入和导出数据"><a href="#导入和导出数据" class="headerlink" title="导入和导出数据"></a>导入和导出数据</h2><h3 id="创建样表-3"><a href="#创建样表-3" class="headerlink" title="创建样表"></a>创建样表</h3><blockquote>
<p>创建一个名为person的新表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE persons</span></span><br><span class="line">(</span><br><span class="line">  id serial NOT NULL,</span><br><span class="line">  first_name character varying(50),</span><br><span class="line">  last_name character varying(50),</span><br><span class="line">  dob date,</span><br><span class="line">  email character varying(255),</span><br><span class="line">  CONSTRAINT persons_pkey PRIMARY KEY (id)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<h3 id="创建CSV数据文件"><a href="#创建CSV数据文件" class="headerlink" title="创建CSV数据文件"></a>创建CSV数据文件</h3><blockquote>
<p>使用Microsoft Excel创建CSV数据文件并上传至PostgreSQL数据库服务器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat persons.csv </span></span><br><span class="line">First Name,Last Name,Date of Birth,Email</span><br><span class="line">Wang,Fei,1999-09-09,wangfei@wangzhijian.cn</span><br><span class="line">Li,Ning,2001-01-01,lining@wangzhijian.cn</span><br></pre></td></tr></table></figure>
<h3 id="将CSV文件导入PostgreSQL表"><a href="#将CSV文件导入PostgreSQL表" class="headerlink" title="将CSV文件导入PostgreSQL表"></a>将CSV文件导入PostgreSQL表</h3><blockquote>
<p>使用COPY语句将CSV文件导入到表中</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; \c <span class="built_in">test</span> postgres</span><br><span class="line">用户 postgres 的口令：</span><br><span class="line">您现在已经连接到数据库 <span class="string">"test"</span>,用户 <span class="string">"postgres"</span>.</span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># GRANT pg_read_server_files TO test;</span></span><br><span class="line">GRANT ROLE</span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># \COPY persons(first_name,last_name,dob,email) </span></span><br><span class="line">FROM <span class="string">'/root/persons.csv'</span> DELIMITER <span class="string">','</span> CSV HEADER;</span><br><span class="line">COPY 2</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT * FROM persons;</span></span><br><span class="line"> id | first_name | last_name |    dob     |         email</span><br><span class="line">----+------------+-----------+------------+------------------------</span><br><span class="line">  1 | Wang       | Fei       | 1999-09-09 | wangfei@wangzhijian.cn</span><br><span class="line">  2 | Li         | Ning      | 2001-01-01 | lining@wangzhijian.cn</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h3 id="将PostgreSQL表导出为CSV文件"><a href="#将PostgreSQL表导出为CSV文件" class="headerlink" title="将PostgreSQL表导出为CSV文件"></a>将PostgreSQL表导出为CSV文件</h3><blockquote>
<p>将表的数据导出到CSV文件的最简单方法是使用COPY语句。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># \COPY test5 TO '/root/test.csv' DELIMITER ',' CSV HEADER;</span></span><br><span class="line">COPY 20</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在某些情况下，您只想将数据从表的某些列导出到CSV文件。为此，您可以在COPY关键字后指定列名和表名。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># \COPY test5(full_name) TO '/root/test.csv' DELIMITER ',' CSV HEADER;</span></span><br><span class="line">COPY 20</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果可以访问远程PostgreSQL数据库服务器，但是没有足够的权限写入其中的文件，则可以使用PostgreSQL内置命令\copy。要使用\copy命令，只需要对本地计算机具有足够的特权，它不需要PostgreSQL超级用户权限。</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    
    
    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="zhijiansd.github.io/blog/pg7/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhiJian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhiJian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/pg7/" class="post-title-link" itemprop="zhijiansd.github.io/page/2/index.html">PostgreSQL之分组集和子查询</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-20 11:34:50 / 修改时间：12:15:37" itemprop="dateCreated datePublished" datetime="2020-05-20T11:34:50+08:00">2020-05-20</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/postresql/" itemprop="url" rel="index"><span itemprop="name">postresql</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/pg7/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/pg7/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">32k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">53 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="GROUPING-SETS-分组集"><a href="#GROUPING-SETS-分组集" class="headerlink" title="GROUPING SETS(分组集)"></a>GROUPING SETS(分组集)</h2><blockquote>
<p>分组集是用于分组的一组列。通常，单个聚合查询定义单个分组集。</p>
</blockquote>
<h3 id="创建样例表"><a href="#创建样例表" class="headerlink" title="创建样例表"></a>创建样例表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE sales (</span></span><br><span class="line">    brand VARCHAR NOT NULL,</span><br><span class="line">    segment VARCHAR NOT NULL,</span><br><span class="line">    quantity INT NOT NULL,</span><br><span class="line">    PRIMARY KEY (brand, segment)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">INSERT INTO sales (brand, segment, quantity)</span><br><span class="line">VALUES</span><br><span class="line">    (<span class="string">'ABC'</span>, <span class="string">'Premium'</span>, 100),</span><br><span class="line">    (<span class="string">'ABC'</span>, <span class="string">'Basic'</span>, 200),</span><br><span class="line">    (<span class="string">'XYZ'</span>, <span class="string">'Premium'</span>, 100),</span><br><span class="line">    (<span class="string">'XYZ'</span>, <span class="string">'Basic'</span>, 300);</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line">INSERT 0 4</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># select * from sales;</span></span><br><span class="line"> brand | segment | quantity</span><br><span class="line">-------+---------+----------</span><br><span class="line"> ABC   | Premium |      100</span><br><span class="line"> ABC   | Basic   |      200</span><br><span class="line"> XYZ   | Premium |      100</span><br><span class="line"> XYZ   | Basic   |      300</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该销售表存储按品牌和细分销售的产品数量。</p>
</blockquote>
<h3 id="GROUPING-SETS分组集示例1"><a href="#GROUPING-SETS分组集示例1" class="headerlink" title="GROUPING SETS分组集示例1"></a>GROUPING SETS分组集示例1</h3><blockquote>
<p>以下查询定义品牌和细分的分组集，它返回按品牌和细分销售的产品数量。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    brand,</span><br><span class="line">    segment,</span><br><span class="line">    SUM (quantity)</span><br><span class="line">FROM</span><br><span class="line">    sales</span><br><span class="line">GROUP BY</span><br><span class="line">    brand,</span><br><span class="line">    segment;</span><br><span class="line"> brand | segment | sum</span><br><span class="line">-------+---------+-----</span><br><span class="line"> XYZ   | Basic   | 300</span><br><span class="line"> ABC   | Premium | 100</span><br><span class="line"> ABC   | Basic   | 200</span><br><span class="line"> XYZ   | Premium | 100</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<h3 id="GROUPING-SETS分组集示例2"><a href="#GROUPING-SETS分组集示例2" class="headerlink" title="GROUPING SETS分组集示例2"></a>GROUPING SETS分组集示例2</h3><blockquote>
<p>查询按品牌出售的产品数量</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    brand,</span><br><span class="line">    SUM (quantity)</span><br><span class="line">FROM</span><br><span class="line">    sales</span><br><span class="line">GROUP BY</span><br><span class="line">    brand;</span><br><span class="line"> brand | sum</span><br><span class="line">-------+-----</span><br><span class="line"> ABC   | 300</span><br><span class="line"> XYZ   | 400</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h3 id="GROUPING-SETS分组集示例3"><a href="#GROUPING-SETS分组集示例3" class="headerlink" title="GROUPING SETS分组集示例3"></a>GROUPING SETS分组集示例3</h3><blockquote>
<p>查询按细分查找销售的产品数量</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    segment,</span><br><span class="line">    SUM (quantity)</span><br><span class="line">FROM</span><br><span class="line">    sales</span><br><span class="line">GROUP BY</span><br><span class="line">    segment;</span><br><span class="line"> segment | sum</span><br><span class="line">---------+-----</span><br><span class="line"> Basic   | 500</span><br><span class="line"> Premium | 200</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h3 id="GROUPING-SETS分组集示例4"><a href="#GROUPING-SETS分组集示例4" class="headerlink" title="GROUPING SETS分组集示例4"></a>GROUPING SETS分组集示例4</h3><blockquote>
<p>查询所有品牌和细分市场出售的产品数量</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    SUM (quantity)</span><br><span class="line">FROM</span><br><span class="line">    sales;</span><br><span class="line"> sum</span><br><span class="line">-----</span><br><span class="line"> 700</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h3 id="GROUPING-SETS分组集示例5"><a href="#GROUPING-SETS分组集示例5" class="headerlink" title="GROUPING SETS分组集示例5"></a>GROUPING SETS分组集示例5</h3><blockquote>
<p>可使用UNION ALL统一以上所有查询，因为UNION ALL要求所有结果集具有相同数量的具有兼容数据类型的列，所以需要通过向每个选择列表中添加NULL来调整查询，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    brand,</span><br><span class="line">    segment,</span><br><span class="line">    SUM (quantity)</span><br><span class="line">FROM</span><br><span class="line">    sales</span><br><span class="line">GROUP BY</span><br><span class="line">    brand,</span><br><span class="line">    segment</span><br><span class="line"> </span><br><span class="line">UNION ALL</span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">    brand,</span><br><span class="line">    NULL,</span><br><span class="line">    SUM (quantity)</span><br><span class="line">FROM</span><br><span class="line">    sales</span><br><span class="line">GROUP BY</span><br><span class="line">    brand</span><br><span class="line"> </span><br><span class="line">UNION ALL</span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">    NULL,</span><br><span class="line">    segment,</span><br><span class="line">    SUM (quantity)</span><br><span class="line">FROM</span><br><span class="line">    sales</span><br><span class="line">GROUP BY</span><br><span class="line">    segment</span><br><span class="line"> </span><br><span class="line">UNION ALL</span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">    NULL,</span><br><span class="line">    NULL,</span><br><span class="line">    SUM (quantity)</span><br><span class="line">FROM</span><br><span class="line">    sales;</span><br><span class="line"> brand | segment | sum</span><br><span class="line">-------+---------+-----</span><br><span class="line"> XYZ   | Basic   | 300</span><br><span class="line"> ABC   | Premium | 100</span><br><span class="line"> ABC   | Basic   | 200</span><br><span class="line"> XYZ   | Premium | 100</span><br><span class="line"> ABC   |         | 300</span><br><span class="line"> XYZ   |         | 400</span><br><span class="line">       | Basic   | 500</span><br><span class="line">       | Premium | 200</span><br><span class="line">       |         | 700</span><br><span class="line">(9 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该查询生成了一个包含所有分组集汇总的单个结果集。</p>
</blockquote>
<h3 id="GROUPING-SETS的语法"><a href="#GROUPING-SETS的语法" class="headerlink" title="GROUPING SETS的语法"></a>GROUPING SETS的语法</h3><blockquote>
<p>GROUPING SETS允许您在同一查询中定义多个分组集。GROUPING SETS的一般语法如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    c1,</span><br><span class="line">    c2,</span><br><span class="line">    aggregate_function(c3)</span><br><span class="line">FROM</span><br><span class="line">    table_name</span><br><span class="line">GROUP BY</span><br><span class="line">    GROUPING SETS (</span><br><span class="line">        (c1, c2),</span><br><span class="line">        (c1),</span><br><span class="line">        (c2),</span><br><span class="line">        ()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用此语法，有四个分组集(c1，c2)，(c1)，(c2)和()。</p>
</blockquote>
<h3 id="GROUPING-SETS分组集示例6"><a href="#GROUPING-SETS分组集示例6" class="headerlink" title="GROUPING SETS分组集示例6"></a>GROUPING SETS分组集示例6</h3><blockquote>
<p>使用GROUPING SETS查询</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    brand,</span><br><span class="line">    segment,</span><br><span class="line">    SUM (quantity)</span><br><span class="line">FROM</span><br><span class="line">    sales</span><br><span class="line">GROUP BY</span><br><span class="line">    GROUPING SETS (</span><br><span class="line">        (brand, segment),</span><br><span class="line">        (brand),</span><br><span class="line">        (segment),</span><br><span class="line">        ()</span><br><span class="line">    );</span><br><span class="line"> brand | segment | sum</span><br><span class="line">-------+---------+-----</span><br><span class="line">       |         | 700</span><br><span class="line"> XYZ   | Basic   | 300</span><br><span class="line"> ABC   | Premium | 100</span><br><span class="line"> ABC   | Basic   | 200</span><br><span class="line"> XYZ   | Premium | 100</span><br><span class="line"> ABC   |         | 300</span><br><span class="line"> XYZ   |         | 400</span><br><span class="line">       | Basic   | 500</span><br><span class="line">       | Premium | 200</span><br><span class="line">(9 rows)</span><br></pre></td></tr></table></figure>
<h3 id="分组功能"><a href="#分组功能" class="headerlink" title="分组功能"></a>分组功能</h3><blockquote>
<p>GROUPING函数接受列的名称，如果该列是当前分组集的成员，则返回位0，否则返回1。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   GROUPING(brand) grouping_brand,</span><br><span class="line">   GROUPING(segment) grouping_segement,</span><br><span class="line">   brand,</span><br><span class="line">   segment,</span><br><span class="line">   SUM (quantity)</span><br><span class="line">FROM</span><br><span class="line">   sales</span><br><span class="line">GROUP BY</span><br><span class="line">   GROUPING SETS (</span><br><span class="line">      (brand, segment),</span><br><span class="line">      (brand),</span><br><span class="line">      (segment),</span><br><span class="line">      ()</span><br><span class="line">   )</span><br><span class="line">ORDER BY</span><br><span class="line">   brand,</span><br><span class="line">   segment;</span><br><span class="line"> grouping_brand | grouping_segement | brand | segment | sum</span><br><span class="line">----------------+-------------------+-------+---------+-----</span><br><span class="line">              0 |                 0 | ABC   | Basic   | 200</span><br><span class="line">              0 |                 0 | ABC   | Premium | 100</span><br><span class="line">              0 |                 1 | ABC   |         | 300</span><br><span class="line">              0 |                 0 | XYZ   | Basic   | 300</span><br><span class="line">              0 |                 0 | XYZ   | Premium | 100</span><br><span class="line">              0 |                 1 | XYZ   |         | 400</span><br><span class="line">              1 |                 0 |       | Basic   | 500</span><br><span class="line">              1 |                 0 |       | Premium | 200</span><br><span class="line">              1 |                 1 |       |         | 700</span><br><span class="line">(9 rows)</span><br></pre></td></tr></table></figure>
<h2 id="CUBE"><a href="#CUBE" class="headerlink" title="CUBE"></a>CUBE</h2><blockquote>
<p>CUBE是GROUP BY子句的子命令。多维数据集允许生成多个分组集。分组集是要分组到的一组列。</p>
</blockquote>
<h3 id="CUBE子句的语法"><a href="#CUBE子句的语法" class="headerlink" title="CUBE子句的语法"></a>CUBE子句的语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    c1,</span><br><span class="line">    c2,</span><br><span class="line">    c3,</span><br><span class="line">    aggregate (c4)</span><br><span class="line">FROM</span><br><span class="line">    table_name</span><br><span class="line">GROUP BY</span><br><span class="line">    CUBE (c1, c2, c3);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用以下语法:</p>
<ul>
<li>首先，在SELECT语句的GROUP BY子句中指定CUBE子句。</li>
</ul>
<ul>
<li>其次，在选择列表中，指定要分析的列（维或维列）和聚合函数表达式。</li>
</ul>
<ul>
<li>第三，在GROUP BY子句中，在CUBE子句的括号内指定维列。</li>
</ul>
</blockquote>
<blockquote>
<p>该查询将基于CUBE中指定的维度列生成所有可能的分组集。多维数据集子句是定义多个分组集的一种简短方法，因此以下内容等效:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CUBE(c1,c2,c3) </span><br><span class="line"> </span><br><span class="line">GROUPING SETS (</span><br><span class="line">    (c1,c2,c3), </span><br><span class="line">    (c1,c2),</span><br><span class="line">    (c1,c3),</span><br><span class="line">    (c2,c3),</span><br><span class="line">    (c1),</span><br><span class="line">    (c2),</span><br><span class="line">    (c3), </span><br><span class="line">    ()</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常，如果CUBE中指定的列数为n，则将有2的N次方个组合。</p>
</blockquote>
<blockquote>
<p>PostgreSQL允许您执行部分多维数据集以减少计算的聚合数量。下面显示了语法:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    c1,</span><br><span class="line">    c2,</span><br><span class="line">    c3,</span><br><span class="line">    aggregate (c4)</span><br><span class="line">FROM</span><br><span class="line">    table_name</span><br><span class="line">GROUP BY</span><br><span class="line">    c1,</span><br><span class="line">    CUBE (c1, c2);</span><br></pre></td></tr></table></figure>
<h3 id="CUBE子句示例1"><a href="#CUBE子句示例1" class="headerlink" title="CUBE子句示例1"></a>CUBE子句示例1</h3><blockquote>
<p>使用CUBE子句来生成多个分组集</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    brand,</span><br><span class="line">    segment,</span><br><span class="line">    SUM (quantity)</span><br><span class="line">FROM</span><br><span class="line">    sales</span><br><span class="line">GROUP BY</span><br><span class="line">    CUBE (brand, segment)</span><br><span class="line">ORDER BY</span><br><span class="line">    brand,</span><br><span class="line">    segment;</span><br><span class="line"> brand | segment | sum</span><br><span class="line">-------+---------+-----</span><br><span class="line"> ABC   | Basic   | 200</span><br><span class="line"> ABC   | Premium | 100</span><br><span class="line"> ABC   |         | 300</span><br><span class="line"> XYZ   | Basic   | 300</span><br><span class="line"> XYZ   | Premium | 100</span><br><span class="line"> XYZ   |         | 400</span><br><span class="line">       | Basic   | 500</span><br><span class="line">       | Premium | 200</span><br><span class="line">       |         | 700</span><br><span class="line">(9 rows)</span><br></pre></td></tr></table></figure>
<h3 id="CUBE子句示例2"><a href="#CUBE子句示例2" class="headerlink" title="CUBE子句示例2"></a>CUBE子句示例2</h3><blockquote>
<p>查询部分多维数据集</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    brand,</span><br><span class="line">    segment,</span><br><span class="line">    SUM (quantity)</span><br><span class="line">FROM</span><br><span class="line">    sales</span><br><span class="line">GROUP BY</span><br><span class="line">    brand,</span><br><span class="line">    CUBE (segment)</span><br><span class="line">ORDER BY</span><br><span class="line">    brand,</span><br><span class="line">    segment;</span><br><span class="line"> brand | segment | sum</span><br><span class="line">-------+---------+-----</span><br><span class="line"> ABC   | Basic   | 200</span><br><span class="line"> ABC   | Premium | 100</span><br><span class="line"> ABC   |         | 300</span><br><span class="line"> XYZ   | Basic   | 300</span><br><span class="line"> XYZ   | Premium | 100</span><br><span class="line"> XYZ   |         | 400</span><br><span class="line">(6 rows)</span><br></pre></td></tr></table></figure>
<h2 id="ROLLUP-汇总"><a href="#ROLLUP-汇总" class="headerlink" title="ROLLUP(汇总)"></a>ROLLUP(汇总)</h2><blockquote>
<p>ROLLUP是GROUP BY子句的子命令，为定义多个分组集提供了捷径。分组集是要分组到的一组列。</p>
</blockquote>
<blockquote>
<p>与CUBE子句不同，ROLLUP不会基于指定的列生成所有可能的分组集。它只是其中的一部分。</p>
</blockquote>
<blockquote>
<p>ROLLUP假定输入列之间为层次结构，并生成考虑该层次结构有意义的所有分组集。这就是为什么经常使用ROLLUP生成报表的小计和总计的原因。</p>
</blockquote>
<blockquote>
<p>例如，多维数据集（c1，c2，c3）进行所有八个可能的分组集:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(c1, c2, c3)</span><br><span class="line">(c1, c2)</span><br><span class="line">(c2, c3)</span><br><span class="line">(c1,c3)</span><br><span class="line">(c1)</span><br><span class="line">(c2)</span><br><span class="line">(c3)</span><br><span class="line">()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是，假设层次结构c1 &gt; c2 &gt; c3，ROLLUP（c1，c2，c3）仅生成四个分组集:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(c1, c2, c3)</span><br><span class="line">(c1, c2)</span><br><span class="line">(c1)</span><br><span class="line">()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ROLLUP的常用用法是年、月、日的层次结构，按年、月和日计算数据汇总。</p>
</blockquote>
<h3 id="ROLLUP的语法"><a href="#ROLLUP的语法" class="headerlink" title="ROLLUP的语法:"></a>ROLLUP的语法:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    c1,</span><br><span class="line">    c2,</span><br><span class="line">    c3,</span><br><span class="line">    aggregate(c4)</span><br><span class="line">FROM</span><br><span class="line">    table_name</span><br><span class="line">GROUP BY</span><br><span class="line">    ROLLUP (c1, c2, c3);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以进行部分汇总以减少生成的小计的数量。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    c1,</span><br><span class="line">    c2,</span><br><span class="line">    c3,</span><br><span class="line">    aggregate(c4)</span><br><span class="line">FROM</span><br><span class="line">    table_name</span><br><span class="line">GROUP BY</span><br><span class="line">    c1, </span><br><span class="line">    ROLLUP (c2, c3);</span><br></pre></td></tr></table></figure>
<h3 id="ROLLUP子句示例1"><a href="#ROLLUP子句示例1" class="headerlink" title="ROLLUP子句示例1"></a>ROLLUP子句示例1</h3><blockquote>
<p>以下查询使用ROLLUP子句找到按品牌（小计）以及所有品牌和细分市场（合计）出售的产品数量。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    brand,</span><br><span class="line">    segment,</span><br><span class="line">    SUM (quantity)</span><br><span class="line">FROM</span><br><span class="line">    sales</span><br><span class="line">GROUP BY</span><br><span class="line">    ROLLUP (brand, segment)</span><br><span class="line">ORDER BY</span><br><span class="line">    brand,</span><br><span class="line">    segment;</span><br><span class="line"> brand | segment | sum</span><br><span class="line">-------+---------+-----</span><br><span class="line"> ABC   | Basic   | 200</span><br><span class="line"> ABC   | Premium | 100</span><br><span class="line"> ABC   |         | 300</span><br><span class="line"> XYZ   | Basic   | 300</span><br><span class="line"> XYZ   | Premium | 100</span><br><span class="line"> XYZ   |         | 400</span><br><span class="line">       |         | 700</span><br><span class="line">(7 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从输出中可以看到，第三行显示了ABC品牌的产品销售数量，第六行显示了XYZ品牌的产品销售数量。最后一行显示总计，该总计显示所有品牌和细分市场售出的产品总数。在此示例中，层次结构为brand &gt; segment。</p>
</blockquote>
<h3 id="ROLLUP子句示例2"><a href="#ROLLUP子句示例2" class="headerlink" title="ROLLUP子句示例2"></a>ROLLUP子句示例2</h3><blockquote>
<p>如果更改品牌和细分的顺序，结果将有所不同，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    segment,</span><br><span class="line">    brand,</span><br><span class="line">    SUM (quantity)</span><br><span class="line">FROM</span><br><span class="line">    sales</span><br><span class="line">GROUP BY</span><br><span class="line">    ROLLUP (segment, brand)</span><br><span class="line">ORDER BY</span><br><span class="line">    segment,</span><br><span class="line">    brand;</span><br><span class="line"> segment | brand | sum</span><br><span class="line">---------+-------+-----</span><br><span class="line"> Basic   | ABC   | 200</span><br><span class="line"> Basic   | XYZ   | 300</span><br><span class="line"> Basic   |       | 500</span><br><span class="line"> Premium | ABC   | 100</span><br><span class="line"> Premium | XYZ   | 100</span><br><span class="line"> Premium |       | 200</span><br><span class="line">         |       | 700</span><br><span class="line">(7 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这种情况下，层次结构是segment &gt; brand。</p>
</blockquote>
<h3 id="ROLLUP子句示例3"><a href="#ROLLUP子句示例3" class="headerlink" title="ROLLUP子句示例3"></a>ROLLUP子句示例3</h3><blockquote>
<p>部分汇总</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    segment,</span><br><span class="line">    brand,</span><br><span class="line">    SUM (quantity)</span><br><span class="line">FROM</span><br><span class="line">    sales</span><br><span class="line">GROUP BY</span><br><span class="line">    segment,</span><br><span class="line">    ROLLUP (brand)</span><br><span class="line">ORDER BY</span><br><span class="line">    segment,</span><br><span class="line">    brand;</span><br><span class="line"> segment | brand | sum</span><br><span class="line">---------+-------+-----</span><br><span class="line"> Basic   | ABC   | 200</span><br><span class="line"> Basic   | XYZ   | 300</span><br><span class="line"> Basic   |       | 500</span><br><span class="line"> Premium | ABC   | 100</span><br><span class="line"> Premium | XYZ   | 100</span><br><span class="line"> Premium |       | 200</span><br><span class="line">(6 rows)</span><br></pre></td></tr></table></figure>
<h3 id="ROLLUP子句示例4"><a href="#ROLLUP子句示例4" class="headerlink" title="ROLLUP子句示例4"></a>ROLLUP子句示例4</h3><blockquote>
<p>以下语句使用ROLLUP查找每天，每月和每年的租金数量:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    EXTRACT (YEAR FROM rental_date) y,</span><br><span class="line">    EXTRACT (MONTH FROM rental_date) M,</span><br><span class="line">    EXTRACT (DAY FROM rental_date) d,</span><br><span class="line">    COUNT (rental_id)</span><br><span class="line">FROM</span><br><span class="line">    rental</span><br><span class="line">GROUP BY</span><br><span class="line">    ROLLUP (</span><br><span class="line">        EXTRACT (YEAR FROM rental_date),</span><br><span class="line">        EXTRACT (MONTH FROM rental_date),</span><br><span class="line">        EXTRACT (DAY FROM rental_date)</span><br><span class="line">    );</span><br><span class="line">  y   |  m   |  d   | count</span><br><span class="line">------+------+------+-------</span><br><span class="line">      |      |      | 16044</span><br><span class="line"> 2005 |    6 |   15 |   348</span><br><span class="line"> 2005 |    6 |   20 |   331</span><br><span class="line"> 2005 |    7 |   11 |   461</span><br><span class="line"> 2005 |    7 |    5 |    27</span><br><span class="line"> 2005 |    5 |   24 |     8</span><br><span class="line"> 2005 |    7 |   29 |   641</span><br><span class="line"> 2005 |    8 |   23 |   598</span><br><span class="line"> 2005 |    7 |    6 |   504</span><br><span class="line"> 2005 |    8 |    1 |   671</span><br><span class="line"> 2005 |    7 |   27 |   649</span><br><span class="line"> 2006 |    2 |   14 |   182</span><br><span class="line"> 2005 |    6 |   21 |   275</span><br><span class="line"> 2005 |    6 |   19 |   348</span><br><span class="line"> 2005 |    6 |   14 |    16</span><br><span class="line"> 2005 |    6 |   16 |   324</span><br><span class="line"> 2005 |    6 |   18 |   344</span><br><span class="line"> 2005 |    5 |   25 |   137</span><br><span class="line"> 2005 |    7 |    8 |   512</span><br><span class="line"> 2005 |    5 |   26 |   174</span><br><span class="line"> 2005 |    5 |   29 |   154</span><br><span class="line"> 2005 |    6 |   17 |   325</span><br><span class="line"> 2005 |    5 |   31 |   163</span><br><span class="line"> 2005 |    7 |    7 |   461</span><br><span class="line"> 2005 |    8 |   21 |   659</span><br><span class="line"> 2005 |    5 |   28 |   196</span><br><span class="line"> 2005 |    5 |   30 |   158</span><br><span class="line"> 2005 |    7 |   26 |    33</span><br><span class="line"> 2005 |    8 |    2 |   643</span><br><span class="line"> 2005 |    7 |   12 |   495</span><br><span class="line"> 2005 |    7 |   30 |   634</span><br><span class="line"> 2005 |    7 |   31 |   679</span><br><span class="line"> 2005 |    8 |   22 |   626</span><br><span class="line"> 2005 |    8 |   17 |   593</span><br><span class="line"> 2005 |    8 |   19 |   628</span><br><span class="line"> 2005 |    8 |   20 |   624</span><br><span class="line"> 2005 |    8 |   18 |   621</span><br><span class="line"> 2005 |    8 |   16 |    23</span><br><span class="line"> 2005 |    7 |    9 |   513</span><br><span class="line"> 2005 |    7 |   10 |   480</span><br><span class="line"> 2005 |    7 |   28 |   620</span><br><span class="line"> 2005 |    5 |   27 |   166</span><br><span class="line"> 2006 |    2 |      |   182</span><br><span class="line"> 2005 |    5 |      |  1156</span><br><span class="line"> 2005 |    8 |      |  5686</span><br><span class="line"> 2005 |    6 |      |  2311</span><br><span class="line"> 2005 |    7 |      |  6709</span><br><span class="line"> 2005 |      |      | 15862</span><br><span class="line"> 2006 |      |      |   182</span><br><span class="line">(49 rows)</span><br></pre></td></tr></table></figure>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><h3 id="子查询示例1"><a href="#子查询示例1" class="headerlink" title="子查询示例1"></a>子查询示例1</h3><blockquote>
<p>假设我们要查找出租率高于平均出租率的电影。我们可以分两步来做:</p>
<ul>
<li>通过使用SELECT语句和平均函数(AVG)查找平均租金。</li>
</ul>
<ul>
<li>在第二条SELECT语句中使用第一个查询的结果来查找所需的电影。</li>
</ul>
</blockquote>
<blockquote>
<p>查询平均租金</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   AVG (rental_rate)</span><br><span class="line">FROM</span><br><span class="line">   film;</span><br><span class="line">        avg</span><br><span class="line">--------------------</span><br><span class="line"> 2.9800000000000000</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>获取出租率高于平均出租率的电影</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   film_id,</span><br><span class="line">   title,</span><br><span class="line">   rental_rate</span><br><span class="line">FROM</span><br><span class="line">   film</span><br><span class="line">WHERE</span><br><span class="line">   rental_rate &gt; 2.98;</span><br><span class="line"> film_id |            title            | rental_rate </span><br><span class="line">---------+-----------------------------+-------------</span><br><span class="line">     133 | Chamber Italian             |        4.99</span><br><span class="line">     384 | Grosse Wonderful            |        4.99</span><br><span class="line">       8 | Airport Pollock             |        4.99</span><br><span class="line">      98 | Bright Encounters           |        4.99</span><br><span class="line">       2 | Ace Goldfinger              |        4.99</span><br><span class="line">       3 | Adaptation Holes            |        2.99</span><br><span class="line">       4 | Affair Prejudice            |        2.99</span><br><span class="line">       5 | African Egg                 |        2.99</span><br><span class="line">       6 | Agent Truman                |        2.99</span><br><span class="line">       7 | Airplane Sierra             |        4.99</span><br><span class="line">       9 | Alabama Devil               |        2.99</span><br><span class="line">      10 | Aladdin Calendar            |        4.99</span><br><span class="line">      13 | Ali Forever                 |        4.99</span><br><span class="line">      15 | Alien Center                |        2.99</span><br><span class="line">      16 | Alley Evolution             |        2.99</span><br><span class="line">      20 | Amelie Hellfighters         |        4.99</span><br><span class="line">      21 | American Circus             |        4.99</span><br><span class="line">      22 | Amistad Midsummer           |        2.99</span><br><span class="line">      24 | Analyze Hoosiers            |        2.99</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<h3 id="子查询示例2"><a href="#子查询示例2" class="headerlink" title="子查询示例2"></a>子查询示例2</h3><blockquote>
<p>子查询是嵌套在另一个查询（例如SELECT，INSERT，DELETE和UPDATE）中的查询。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   film_id,</span><br><span class="line">   title,</span><br><span class="line">   rental_rate</span><br><span class="line">FROM</span><br><span class="line">   film</span><br><span class="line">WHERE</span><br><span class="line">   rental_rate &gt; (</span><br><span class="line">      SELECT</span><br><span class="line">         AVG (rental_rate)</span><br><span class="line">      FROM</span><br><span class="line">         film</span><br><span class="line">   );</span><br><span class="line"> film_id |            title            | rental_rate </span><br><span class="line">---------+-----------------------------+-------------</span><br><span class="line">     133 | Chamber Italian             |        4.99</span><br><span class="line">     384 | Grosse Wonderful            |        4.99</span><br><span class="line">       8 | Airport Pollock             |        4.99</span><br><span class="line">      98 | Bright Encounters           |        4.99</span><br><span class="line">       2 | Ace Goldfinger              |        4.99</span><br><span class="line">       3 | Adaptation Holes            |        2.99</span><br><span class="line">       4 | Affair Prejudice            |        2.99</span><br><span class="line">       5 | African Egg                 |        2.99</span><br><span class="line">       6 | Agent Truman                |        2.99</span><br><span class="line">       7 | Airplane Sierra             |        4.99</span><br><span class="line">       9 | Alabama Devil               |        2.99</span><br><span class="line">      10 | Aladdin Calendar            |        4.99</span><br><span class="line">      13 | Ali Forever                 |        4.99</span><br><span class="line">      15 | Alien Center                |        2.99</span><br><span class="line">      16 | Alley Evolution             |        2.99</span><br><span class="line">      20 | Amelie Hellfighters         |        4.99</span><br><span class="line">      21 | American Circus             |        4.99</span><br><span class="line">      22 | Amistad Midsummer           |        2.99</span><br><span class="line">      24 | Analyze Hoosiers            |        2.99</span><br><span class="line">--More--</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">&gt; 方括号内的查询称为子查询或内部查询。包含子查询的查询称为外部查询。</span><br><span class="line"></span><br><span class="line">&gt; PostgreSQL按照以下顺序执行包含子查询的查询:</span><br><span class="line">+ 首先，执行子查询。</span><br><span class="line">- 其次，获取结果并将其传递给外部查询。</span><br><span class="line">+ 第三，执行外部查询。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 带有IN运算符的子查询</span></span><br><span class="line"></span><br><span class="line">&gt; 子查询可以返回零或更多行。若要使用此子查询，请在WHERE子句中使用IN运算符。</span><br><span class="line"></span><br><span class="line">&gt; 获取日期在2005-05-29和2005-05-30之间的电影</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   inventory.film_id</span><br><span class="line">FROM</span><br><span class="line">   rental</span><br><span class="line">INNER JOIN inventory ON inventory.inventory_id = rental.inventory_id</span><br><span class="line">WHERE</span><br><span class="line">   return_date BETWEEN <span class="string">'2005-05-29'</span></span><br><span class="line">AND <span class="string">'2005-05-30'</span>;</span><br><span class="line"> film_id </span><br><span class="line">---------</span><br><span class="line">      15</span><br><span class="line">      19</span><br><span class="line">      45</span><br><span class="line">      50</span><br><span class="line">      52</span><br><span class="line">      54</span><br><span class="line">      68</span><br><span class="line">      73</span><br><span class="line">      83</span><br><span class="line">      89</span><br><span class="line">     103</span><br><span class="line">     120</span><br><span class="line">     130</span><br><span class="line">     138</span><br><span class="line">     139</span><br><span class="line">     164</span><br><span class="line">     179</span><br><span class="line">     200</span><br><span class="line">     226</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用子查询</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   film_id,</span><br><span class="line">   title</span><br><span class="line">FROM</span><br><span class="line">   film</span><br><span class="line">WHERE</span><br><span class="line">   film_id IN (</span><br><span class="line">      SELECT</span><br><span class="line">         inventory.film_id</span><br><span class="line">      FROM</span><br><span class="line">         rental</span><br><span class="line">      INNER JOIN inventory ON inventory.inventory_id = rental.inventory_id</span><br><span class="line">      WHERE</span><br><span class="line">         return_date BETWEEN <span class="string">'2005-05-29'</span></span><br><span class="line">      AND <span class="string">'2005-05-30'</span></span><br><span class="line">   );</span><br><span class="line"> film_id |         title         </span><br><span class="line">---------+-----------------------</span><br><span class="line">     307 | Fellowship Autumn</span><br><span class="line">     255 | Driving Polish</span><br><span class="line">     388 | Gunfight Moon</span><br><span class="line">     130 | Celebrity Horn</span><br><span class="line">     563 | Massacre Usual</span><br><span class="line">     397 | Hanky October</span><br><span class="line">     898 | Tourist Pelican</span><br><span class="line">     228 | Detective Vision</span><br><span class="line">     347 | Games Bowfinger</span><br><span class="line">    1000 | Zorro Ark</span><br><span class="line">     624 | Nightmare Chill</span><br><span class="line">     179 | Conquerer Nuts</span><br><span class="line">      54 | Banger Pinocchio</span><br><span class="line">     684 | Pizza Jumanji</span><br><span class="line">     267 | Eagles Panky</span><br><span class="line">      68 | Betrayed Rear</span><br><span class="line">     868 | Superfly Trip</span><br><span class="line">     138 | Chariots Conspiracy</span><br><span class="line">     418 | Hobbit Alien</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<h3 id="使用EXISTS运算符的子查询"><a href="#使用EXISTS运算符的子查询" class="headerlink" title="使用EXISTS运算符的子查询"></a>使用EXISTS运算符的子查询</h3><blockquote>
<p>以下表达式说明了如何在EXISTS运算符中使用子查询:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXISTS subquery</span><br></pre></td></tr></table></figure>
<blockquote>
<p>子查询可以是EXISTS运算符的输入。如果子查询返回任何行，则EXISTS运算符返回true。如果子查询不返回任何行，则EXISTS运算符的结果为false。</p>
</blockquote>
<blockquote>
<p>EXISTS运算符只关心子查询返回的行数，而不关心行的内容，因此，EXISTS运算符的通用编码约定如下:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXISTS (SELECT 1 FROM tbl WHERE condition);</span><br></pre></td></tr></table></figure>
<h4 id="EXISTS运算符的示例"><a href="#EXISTS运算符的示例" class="headerlink" title="EXISTS运算符的示例"></a>EXISTS运算符的示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   first_name,</span><br><span class="line">   last_name</span><br><span class="line">FROM</span><br><span class="line">   customer</span><br><span class="line">WHERE</span><br><span class="line">   EXISTS (</span><br><span class="line">      SELECT</span><br><span class="line">         1</span><br><span class="line">      FROM</span><br><span class="line">         payment</span><br><span class="line">      WHERE</span><br><span class="line">         payment.customer_id = customer.customer_id</span><br><span class="line">   );</span><br><span class="line"> first_name  |  last_name   </span><br><span class="line">-------------+--------------</span><br><span class="line"> Jared       | Ely</span><br><span class="line"> Mary        | Smith</span><br><span class="line"> Patricia    | Johnson</span><br><span class="line"> Linda       | Williams</span><br><span class="line"> Barbara     | Jones</span><br><span class="line"> Elizabeth   | Brown</span><br><span class="line"> Jennifer    | Davis</span><br><span class="line"> Maria       | Miller</span><br><span class="line"> Susan       | Wilson</span><br><span class="line"> Margaret    | Moore</span><br><span class="line"> Dorothy     | Taylor</span><br><span class="line"> Lisa        | Anderson</span><br><span class="line"> Nancy       | Thomas</span><br><span class="line"> Karen       | Jackson</span><br><span class="line"> Betty       | White</span><br><span class="line"> Helen       | Harris</span><br><span class="line"> Sandra      | Martin</span><br><span class="line"> Donna       | Thompson</span><br><span class="line"> Carol       | Garcia</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<h2 id="ANY运算符"><a href="#ANY运算符" class="headerlink" title="ANY运算符"></a>ANY运算符</h2><blockquote>
<p>ANY运算符将值与子查询返回的一组值进行比较。</p>
</blockquote>
<h3 id="ANY运算符的语法"><a href="#ANY运算符的语法" class="headerlink" title="ANY运算符的语法"></a>ANY运算符的语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expresion operator ANY(subquery)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用如上语法:</p>
<ul>
<li>子查询必须仅返回一列。</li>
</ul>
<ul>
<li>ANY运算符之前必须是以下比较运算符之一=、&gt;、&gt;=、&lt;、&lt;=和&lt;&gt;，如果子查询的任何值满足条件，则ANY运算符将返回true，否则返回false。</li>
</ul>
</blockquote>
<blockquote>
<p>请注意，SOME是ANY的同义词，这意味着可以在任何SQL语句中将SOME替换为ANY。</p>
</blockquote>
<h3 id="ANY运算符示例1"><a href="#ANY运算符示例1" class="headerlink" title="ANY运算符示例1"></a>ANY运算符示例1</h3><blockquote>
<p>按电影类别分组的电影的最大长度</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    MAX( length )</span><br><span class="line">FROM</span><br><span class="line">    film</span><br><span class="line">INNER JOIN film_category</span><br><span class="line">        USING(film_id)</span><br><span class="line">GROUP BY</span><br><span class="line">    category_id;</span><br><span class="line"> max</span><br><span class="line">-----</span><br><span class="line"> 184</span><br><span class="line"> 185</span><br><span class="line"> 178</span><br><span class="line"> 185</span><br><span class="line"> 181</span><br><span class="line"> 183</span><br><span class="line"> 184</span><br><span class="line"> 185</span><br><span class="line"> 185</span><br><span class="line"> 185</span><br><span class="line"> 185</span><br><span class="line"> 184</span><br><span class="line"> 183</span><br><span class="line"> 185</span><br><span class="line"> 184</span><br><span class="line"> 181</span><br><span class="line">(16 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将查询用作子查询，查找长度大于或等于任何电影类别的最大长度的电影</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT title</span></span><br><span class="line">FROM film</span><br><span class="line">WHERE length &gt;= ANY(</span><br><span class="line">    SELECT MAX( length )</span><br><span class="line">    FROM film</span><br><span class="line">    INNER JOIN film_category USING(film_id)</span><br><span class="line">    GROUP BY  category_id );</span><br><span class="line">         title          </span><br><span class="line">------------------------</span><br><span class="line"> Alley Evolution</span><br><span class="line"> Analyze Hoosiers</span><br><span class="line"> Anonymous Human</span><br><span class="line"> Baked Cleopatra</span><br><span class="line"> Casualties Encino</span><br><span class="line"> Born Spinal</span><br><span class="line"> Catch Amistad</span><br><span class="line"> Cause Date</span><br><span class="line"> Chicago North</span><br><span class="line"> Confidential Interview</span><br><span class="line"> Conspiracy Spirit</span><br><span class="line"> Control Anthem</span><br><span class="line"> Crystal Breaking</span><br><span class="line"> Darn Forrester</span><br><span class="line"> Drop Waterfront</span><br><span class="line"> Express Lonely</span><br><span class="line"> Flight Lies</span><br><span class="line"> Frontier Cabin</span><br><span class="line"> Fury Murder</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于每个电影类别，子查询都会找到最大长度。外部查询会查看所有这些值，并确定哪些电影的长度大于或等于任何电影类别的最大长度。</p>
</blockquote>
<blockquote>
<p>请注意，如果子查询不返回任何行，则整个查询将返回空结果集。</p>
</blockquote>
<h3 id="ANY与IN"><a href="#ANY与IN" class="headerlink" title="ANY与IN"></a>ANY与IN</h3><blockquote>
<p>= ANY等效于IN运算符。</p>
</blockquote>
<h3 id="ANY运算符示例2"><a href="#ANY运算符示例2" class="headerlink" title="ANY运算符示例2"></a>ANY运算符示例2</h3><blockquote>
<p>获取类别为动作或戏剧的电影</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    title,</span><br><span class="line">    category_id</span><br><span class="line">FROM</span><br><span class="line">    film</span><br><span class="line">INNER JOIN film_category</span><br><span class="line">        USING(film_id)</span><br><span class="line">WHERE</span><br><span class="line">    category_id = ANY(</span><br><span class="line">        SELECT</span><br><span class="line">            category_id</span><br><span class="line">        FROM</span><br><span class="line">            category</span><br><span class="line">        WHERE</span><br><span class="line">            NAME = <span class="string">'Action'</span></span><br><span class="line">            OR NAME = <span class="string">'Drama'</span></span><br><span class="line">    );</span><br><span class="line">          title          | category_id </span><br><span class="line">-------------------------+-------------</span><br><span class="line"> Amadeus Holy            |           1</span><br><span class="line"> American Circus         |           1</span><br><span class="line"> Antitrust Tomatoes      |           1</span><br><span class="line"> Apollo Teen             |           7</span><br><span class="line"> Ark Ridgemont           |           1</span><br><span class="line"> Barefoot Manchurian     |           1</span><br><span class="line"> Beauty Grease           |           7</span><br><span class="line"> Beethoven Exorcist      |           7</span><br><span class="line"> Berets Agent            |           1</span><br><span class="line"> Blade Polish            |           7</span><br><span class="line"> Bride Intrigue          |           1</span><br><span class="line"> Bright Encounters       |           7</span><br><span class="line"> Bull Shawshank          |           1</span><br><span class="line"> Bunch Minds             |           7</span><br><span class="line"> Caddyshack Jedi         |           1</span><br><span class="line"> Campus Remember         |           1</span><br><span class="line"> Casualties Encino       |           1</span><br><span class="line"> Celebrity Horn          |           1</span><br><span class="line"> Chill Luck              |           7</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下语句使用产生相同结果的IN运算符</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    title,</span><br><span class="line">    category_id</span><br><span class="line">FROM</span><br><span class="line">    film</span><br><span class="line">INNER JOIN film_category</span><br><span class="line">        USING(film_id)</span><br><span class="line">WHERE</span><br><span class="line">    category_id IN(</span><br><span class="line">        SELECT</span><br><span class="line">            category_id</span><br><span class="line">        FROM</span><br><span class="line">            category</span><br><span class="line">        WHERE</span><br><span class="line">            NAME = <span class="string">'Action'</span></span><br><span class="line">            OR NAME = <span class="string">'Drama'</span></span><br><span class="line">    );</span><br><span class="line">          title          | category_id </span><br><span class="line">-------------------------+-------------</span><br><span class="line"> Amadeus Holy            |           1</span><br><span class="line"> American Circus         |           1</span><br><span class="line"> Antitrust Tomatoes      |           1</span><br><span class="line"> Apollo Teen             |           7</span><br><span class="line"> Ark Ridgemont           |           1</span><br><span class="line"> Barefoot Manchurian     |           1</span><br><span class="line"> Beauty Grease           |           7</span><br><span class="line"> Beethoven Exorcist      |           7</span><br><span class="line"> Berets Agent            |           1</span><br><span class="line"> Blade Polish            |           7</span><br><span class="line"> Bride Intrigue          |           1</span><br><span class="line"> Bright Encounters       |           7</span><br><span class="line"> Bull Shawshank          |           1</span><br><span class="line"> Bunch Minds             |           7</span><br><span class="line"> Caddyshack Jedi         |           1</span><br><span class="line"> Campus Remember         |           1</span><br><span class="line"> Casualties Encino       |           1</span><br><span class="line"> Celebrity Horn          |           1</span><br><span class="line"> Chill Luck              |           7</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，&lt;&gt; ANY运算符不同于NOT IN。下面的表达式:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &lt;&gt; ANY (a,b,c)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>相当于</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &lt;&gt; a OR &lt;&gt; b OR x &lt;&gt; c</span><br></pre></td></tr></table></figure>
<h2 id="ALL运算符"><a href="#ALL运算符" class="headerlink" title="ALL运算符"></a>ALL运算符</h2><blockquote>
<p>ALL运算符允许通过将值与子查询返回的值列表进行比较来查询数据。</p>
</blockquote>
<h3 id="ALL运算符的语法"><a href="#ALL运算符的语法" class="headerlink" title="ALL运算符的语法"></a>ALL运算符的语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comparison_operator ALL (subquery)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用如上语法:</p>
<ul>
<li>ALL运算符的前面必须是比较运算符，例如等于（=），不等于（！=），大于（&gt;），大于或等于（&gt; =），小于（&lt;）以及小于或 等于（&lt;=）。</li>
</ul>
<ul>
<li>ALL运算符后必须跟一个子查询，该子查询也必须用括号括起来。</li>
</ul>
</blockquote>
<blockquote>
<p>假设子查询返回一些行，则ALL运算符的工作方式如下:</p>
<ul>
<li>column_name &gt; ALL（子查询），如果值大于子查询返回的最大值，则表达式的计算结果为true。</li>
</ul>
<ul>
<li>column_name &gt;= ALL（子查询）如果值大于或等于子查询返回的最大值，则表达式的计算结果为true。</li>
</ul>
<ul>
<li>column_name &lt; ALL（子查询）如果值小于子查询返回的最小值，则表达式的计算结果为true。</li>
</ul>
<ul>
<li>column_name &lt;= ALL（子查询）如果值小于或等于子查询返回的最小值，则表达式的计算结果为true。</li>
</ul>
<ul>
<li>column_name = ALL（子查询）如果值等于子查询返回的任何值，则表达式的计算结果为true。</li>
</ul>
<ul>
<li>column_name != ALL（子查询）如果值不等于子查询返回的任何值，则表达式的计算结果为true。<br>如果子查询不返回任何行，则ALL运算符始终求值为true。</li>
</ul>
</blockquote>
<h3 id="ALL运算符示例"><a href="#ALL运算符示例" class="headerlink" title="ALL运算符示例"></a>ALL运算符示例</h3><blockquote>
<p>查询按电影等级分组的所有电影的平均长度</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    rating,ROUND(AVG(length), 2) avg_length</span><br><span class="line">FROM</span><br><span class="line">    film</span><br><span class="line">GROUP BY</span><br><span class="line">    rating</span><br><span class="line">ORDER BY</span><br><span class="line">    avg_length DESC;</span><br><span class="line"> rating | avg_length</span><br><span class="line">--------+------------</span><br><span class="line"> PG-13  |     120.44</span><br><span class="line"> R      |     118.66</span><br><span class="line"> NC-17  |     113.23</span><br><span class="line"> PG     |     112.01</span><br><span class="line"> G      |     111.05</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用ALL和大于运算符(&gt;)查找所有长度大于上述平均长度列表的电影</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    film_id,</span><br><span class="line">    title,</span><br><span class="line">    rating,</span><br><span class="line">    length</span><br><span class="line">FROM</span><br><span class="line">    film</span><br><span class="line">WHERE</span><br><span class="line">    length &gt; ALL (</span><br><span class="line">            SELECT</span><br><span class="line">                ROUND(AVG (length),2)</span><br><span class="line">            FROM</span><br><span class="line">                film</span><br><span class="line">            GROUP BY</span><br><span class="line">                rating</span><br><span class="line">    )</span><br><span class="line">ORDER BY</span><br><span class="line">    length;</span><br><span class="line"> film_id |            title            | rating | length </span><br><span class="line">---------+-----------------------------+--------+--------</span><br><span class="line">     207 | Dangerous Uptown            | PG     |    121</span><br><span class="line">      86 | Boogie Amelie               | R      |    121</span><br><span class="line">     403 | Harry Idaho                 | PG-13  |    121</span><br><span class="line">      93 | Brannigan Sunrise           | PG     |    121</span><br><span class="line">     704 | Pure Runner                 | NC-17  |    121</span><br><span class="line">      37 | Arizona Bang                | PG     |    121</span><br><span class="line">     658 | Paris Weekend               | PG-13  |    121</span><br><span class="line">     490 | Jumanji Blade               | G      |    121</span><br><span class="line">      68 | Betrayed Rear               | NC-17  |    122</span><br><span class="line">     218 | Deceiver Betrayed           | NC-17  |    122</span><br><span class="line">     239 | Dogma Family                | G      |    122</span><br><span class="line">     452 | Illusion Amelie             | R      |    122</span><br><span class="line">     175 | Confused Candles            | PG-13  |    122</span><br><span class="line">     297 | Extraordinary Conquerer     | G      |    122</span><br><span class="line">     142 | Chicken Hellfighters        | PG     |    122</span><br><span class="line">     576 | Mighty Luck                 | PG     |    122</span><br><span class="line">     934 | Vanilla Day                 | NC-17  |    122</span><br><span class="line">      58 | Beach Heartbreakers         | G      |    122</span><br><span class="line">     436 | Hours Rage                  | NC-17  |    122</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从输出中可以清楚地看到，查询将返回所有长度大于子查询返回的平均长度列表中最大值的影片。</p>
</blockquote>
<h2 id="EXISTS运算符"><a href="#EXISTS运算符" class="headerlink" title="EXISTS运算符"></a>EXISTS运算符</h2><blockquote>
<p>EXISTS运算符用于测试子查询中是否存在行。</p>
</blockquote>
<h3 id="EXISTS运算符的语法"><a href="#EXISTS运算符的语法" class="headerlink" title="EXISTS运算符的语法"></a>EXISTS运算符的语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXISTS (subquery)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>EXISTS通常与相关子查询一起使用。EXISTS接受作为子查询的参数。</p>
</blockquote>
<blockquote>
<p>如果子查询返回至少一行，则EXISTS的结果为true。如果子查询不返回任何行，则EXISTS的结果为false。</p>
</blockquote>
<blockquote>
<p>EXISTS的结果取决于子查询是否返回任何行，而不取决于行的内容。因此，出现在子查询的SELECT子句上的列并不重要。</p>
</blockquote>
<blockquote>
<p>因此，常见的编码约定是以以下形式编写EXISTS:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">    column_1 </span><br><span class="line">FROM </span><br><span class="line">    table_1</span><br><span class="line">    WHERE </span><br><span class="line">    EXISTS( SELECT </span><br><span class="line">                1 </span><br><span class="line">            FROM </span><br><span class="line">                table_2 </span><br><span class="line">            WHERE </span><br><span class="line">                column_2 = table_1.column_1);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，如果子查询返回NULL，则EXISTS的结果为true。</p>
</blockquote>
<h3 id="EXISTS运算符示例"><a href="#EXISTS运算符示例" class="headerlink" title="EXISTS运算符示例"></a>EXISTS运算符示例</h3><blockquote>
<p>查找至少付款金额大于11的客户</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT first_name,</span></span><br><span class="line">       last_name</span><br><span class="line">FROM customer c</span><br><span class="line">WHERE EXISTS</span><br><span class="line">    (SELECT 1</span><br><span class="line">     FROM payment p</span><br><span class="line">     WHERE p.customer_id = c.customer_id</span><br><span class="line">       AND amount &gt; 11 )</span><br><span class="line">ORDER BY first_name,</span><br><span class="line">         last_name;</span><br><span class="line"> first_name | last_name</span><br><span class="line">------------+-----------</span><br><span class="line"> Karen      | Jackson</span><br><span class="line"> Kent       | Arsenault</span><br><span class="line"> Nicholas   | Barfield</span><br><span class="line"> Rosemary   | Schmidt</span><br><span class="line"> Tanya      | Gilbert</span><br><span class="line"> Terrance   | Roush</span><br><span class="line"> Vanessa    | Sims</span><br><span class="line"> Victoria   | Gibson</span><br><span class="line">(8 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此示例中，对于客户表中的每个客户，子查询将检查付款表以查找该客户是否至少进行了一次付款（p.customer_id = c.customer_id）并且金额大于11（amount &gt; 11）。</p>
</blockquote>
<h3 id="NOT-EXISTS运算符示例"><a href="#NOT-EXISTS运算符示例" class="headerlink" title="NOT EXISTS运算符示例"></a>NOT EXISTS运算符示例</h3><blockquote>
<p>NOT EXISTS与EXISTS相反，这意味着如果子查询不返回任何行，则NOT EXISTS返回true。如果子查询返回任何行，则NOT EXISTS返回false。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT first_name,</span></span><br><span class="line">       last_name</span><br><span class="line">FROM customer c</span><br><span class="line">WHERE NOT EXISTS</span><br><span class="line">    (SELECT 1</span><br><span class="line">     FROM payment p</span><br><span class="line">     WHERE p.customer_id = c.customer_id</span><br><span class="line">       AND amount &gt; 11 )</span><br><span class="line">ORDER BY first_name,</span><br><span class="line">         last_name;</span><br><span class="line"> first_name  |  last_name   </span><br><span class="line">-------------+--------------</span><br><span class="line"> Aaron       | Selby</span><br><span class="line"> Adam        | Gooch</span><br><span class="line"> Adrian      | Clary</span><br><span class="line"> Agnes       | Bishop</span><br><span class="line"> Alan        | Kahn</span><br><span class="line"> Albert      | Crouse</span><br><span class="line"> Alberto     | Henning</span><br><span class="line"> Alex        | Gresham</span><br><span class="line"> Alexander   | Fennell</span><br><span class="line"> Alfred      | Casillas</span><br><span class="line"> Alfredo     | Mcadams</span><br><span class="line"> Alice       | Stewart</span><br><span class="line"> Alicia      | Mills</span><br><span class="line"> Allan       | Cornish</span><br><span class="line"> Allen       | Butterfield</span><br><span class="line"> Allison     | Stanley</span><br><span class="line"> Alma        | Austin</span><br><span class="line"> Alvin       | Deloach</span><br><span class="line"> Amanda      | Carter</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<h3 id="EXISTS-和-NULL示例"><a href="#EXISTS-和-NULL示例" class="headerlink" title="EXISTS 和 NULL示例"></a>EXISTS 和 NULL示例</h3><blockquote>
<p>如果子查询返回NULL，则EXISTS返回true。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   first_name,</span><br><span class="line">   last_name</span><br><span class="line">FROM</span><br><span class="line">   customer</span><br><span class="line">WHERE</span><br><span class="line">   EXISTS( SELECT NULL )</span><br><span class="line">ORDER BY</span><br><span class="line">   first_name,</span><br><span class="line">   last_name;</span><br><span class="line"> first_name  |  last_name   </span><br><span class="line">-------------+--------------</span><br><span class="line"> Aaron       | Selby</span><br><span class="line"> Adam        | Gooch</span><br><span class="line"> Adrian      | Clary</span><br><span class="line"> Agnes       | Bishop</span><br><span class="line"> Alan        | Kahn</span><br><span class="line"> Albert      | Crouse</span><br><span class="line"> Alberto     | Henning</span><br><span class="line"> Alex        | Gresham</span><br><span class="line"> Alexander   | Fennell</span><br><span class="line"> Alfred      | Casillas</span><br><span class="line"> Alfredo     | Mcadams</span><br><span class="line"> Alice       | Stewart</span><br><span class="line"> Alicia      | Mills</span><br><span class="line"> Allan       | Cornish</span><br><span class="line"> Allen       | Butterfield</span><br><span class="line"> Allison     | Stanley</span><br><span class="line"> Alma        | Austin</span><br><span class="line"> Alvin       | Deloach</span><br><span class="line"> Amanda      | Carter</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此示例中，子查询返回NULL，因此，该查询返回了customer表中的所有行。</p>
</blockquote>
<h2 id="CTE-公用表表达式"><a href="#CTE-公用表表达式" class="headerlink" title="CTE(公用表表达式)"></a>CTE(公用表表达式)</h2><blockquote>
<p>公用表表达式是一个临时结果集，您可以在另一个SQL语句（包括SELECT，INSERT，UPDATE或DELETE）中进行引用。</p>
</blockquote>
<blockquote>
<p>公用表表达式是临时的，因为它们仅在查询执行期间存在。</p>
</blockquote>
<h3 id="创建CTE的语法"><a href="#创建CTE的语法" class="headerlink" title="创建CTE的语法"></a>创建CTE的语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WITH cte_name (column_list) AS (</span><br><span class="line">    CTE_query_definition </span><br><span class="line">)</span><br><span class="line">statement;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用如上语法:</p>
<ul>
<li>首先，指定CTE的名称，后跟一个可选的列列表。</li>
</ul>
<ul>
<li>其次，在WITH子句的主体内，指定一个返回结果集的查询。如果您未在CTE名称后明确指定列列表，则CTE_query_definition的选择列表将成为CTE的列列表。</li>
</ul>
<ul>
<li>第三，像语句中的表或视图一样使用CTE，它可以是SELECT，INSERT，UPDATE或DELETE。</li>
</ul>
</blockquote>
<blockquote>
<p>常用表表达式或CTE通常用于简化PostgreSQL中的复杂联接和子查询。</p>
</blockquote>
<h3 id="CTE示例1"><a href="#CTE示例1" class="headerlink" title="CTE示例1"></a>CTE示例1</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># WITH cte_film AS (</span></span><br><span class="line">    SELECT </span><br><span class="line">        film_id, </span><br><span class="line">        title,</span><br><span class="line">        (CASE </span><br><span class="line">            WHEN length &lt; 30 THEN <span class="string">'Short'</span></span><br><span class="line">            WHEN length &gt;= 30 AND length &lt; 90 THEN <span class="string">'Medium'</span></span><br><span class="line">            WHEN length &gt; 90 THEN <span class="string">'Long'</span></span><br><span class="line">        END) length    </span><br><span class="line">    FROM</span><br><span class="line">        film</span><br><span class="line">)</span><br><span class="line">SELECT</span><br><span class="line">    film_id,</span><br><span class="line">    title,</span><br><span class="line">    length</span><br><span class="line">FROM </span><br><span class="line">    cte_film</span><br><span class="line">WHERE</span><br><span class="line">    length = <span class="string">'Long'</span></span><br><span class="line">ORDER BY </span><br><span class="line">    title; </span><br><span class="line"> film_id |            title            | length </span><br><span class="line">---------+-----------------------------+--------</span><br><span class="line">       4 | Affair Prejudice            | Long</span><br><span class="line">       5 | African Egg                 | Long</span><br><span class="line">       6 | Agent Truman                | Long</span><br><span class="line">       9 | Alabama Devil               | Long</span><br><span class="line">      11 | Alamo Videotape             | Long</span><br><span class="line">      12 | Alaska Phantom              | Long</span><br><span class="line">      14 | Alice Fantasia              | Long</span><br><span class="line">      13 | Ali Forever                 | Long</span><br><span class="line">      16 | Alley Evolution             | Long</span><br><span class="line">      19 | Amadeus Holy                | Long</span><br><span class="line">      21 | American Circus             | Long</span><br><span class="line">      23 | Anaconda Confessions        | Long</span><br><span class="line">      24 | Analyze Hoosiers            | Long</span><br><span class="line">      27 | Anonymous Human             | Long</span><br><span class="line">      28 | Anthem Luke                 | Long</span><br><span class="line">      29 | Antitrust Tomatoes          | Long</span><br><span class="line">      31 | Apache Divine               | Long</span><br><span class="line">      32 | Apocalypse Flamingos        | Long</span><br><span class="line">      33 | Apollo Teen                 | Long</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此示例中，我们首先使用WITH子句定义了一个公用表表达式cte_film，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">WITH cte_film AS (</span><br><span class="line">    SELECT </span><br><span class="line">        film_id, </span><br><span class="line">        title,</span><br><span class="line">        (CASE </span><br><span class="line">            WHEN length &lt; 30 </span><br><span class="line">                THEN <span class="string">'Short'</span></span><br><span class="line">            WHEN length &gt;= 30 AND length &lt; 90 </span><br><span class="line">                THEN <span class="string">'Medium'</span></span><br><span class="line">            WHEN length &gt; 90 </span><br><span class="line">                THEN <span class="string">'Long'</span></span><br><span class="line">        END) length    </span><br><span class="line">    FROM</span><br><span class="line">        film</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>公用表表达式包含两个部分:</p>
<ul>
<li>第一部分定义CTE的名称，即cte_film。</li>
</ul>
<ul>
<li>第二部分定义一个SELECT语句，该语句用行填充表达式。</li>
</ul>
<ul>
<li>然后，在SELECT语句中使用cte_film CTE仅返回长度为“Long”的电影。</li>
</ul>
</blockquote>
<h3 id="CTE示例2"><a href="#CTE示例2" class="headerlink" title="CTE示例2"></a>CTE示例2</h3><blockquote>
<p>将CTE与rental、staff表联接</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># WITH cte_rental AS (</span></span><br><span class="line">    SELECT staff_id,</span><br><span class="line">        COUNT(rental_id) rental_count</span><br><span class="line">    FROM   rental</span><br><span class="line">    GROUP  BY staff_id</span><br><span class="line">)</span><br><span class="line">SELECT s.staff_id,</span><br><span class="line">    first_name,</span><br><span class="line">    last_name,</span><br><span class="line">    rental_count</span><br><span class="line">FROM staff s</span><br><span class="line">    INNER JOIN cte_rental USING (staff_id); </span><br><span class="line"> staff_id | first_name | last_name | rental_count</span><br><span class="line">----------+------------+-----------+--------------</span><br><span class="line">        1 | Mike       | Hillyer   |         8040</span><br><span class="line">        2 | Jon        | Stephens  |         8004</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此示例中:</p>
<ul>
<li>首先，CTE返回一个结果集，其中包含员工ID和租金数量。</li>
</ul>
<ul>
<li>然后，使用staff_id列将人员表与CTE相连。</li>
</ul>
</blockquote>
<h3 id="CTE示例3"><a href="#CTE示例3" class="headerlink" title="CTE示例3"></a>CTE示例3</h3><blockquote>
<p>将CTE与RANK()窗口函数一起使用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># WITH cte_film AS  (</span></span><br><span class="line">    SELECT film_id,</span><br><span class="line">        title,</span><br><span class="line">        rating,</span><br><span class="line">        length,</span><br><span class="line">        RANK() OVER (</span><br><span class="line">            PARTITION BY rating</span><br><span class="line">            ORDER BY length DESC) </span><br><span class="line">        length_rank</span><br><span class="line">    FROM </span><br><span class="line">        film</span><br><span class="line">)</span><br><span class="line">SELECT *</span><br><span class="line">FROM cte_film</span><br><span class="line">WHERE length_rank = 1;</span><br><span class="line"> film_id |       title        | rating | length | length_rank</span><br><span class="line">---------+--------------------+--------+--------+-------------</span><br><span class="line">     182 | Control Anthem     | G      |    185 |           1</span><br><span class="line">     212 | Darn Forrester     | G      |    185 |           1</span><br><span class="line">     609 | Muscle Bright      | G      |    185 |           1</span><br><span class="line">     991 | Worst Banger       | PG     |    185 |           1</span><br><span class="line">     141 | Chicago North      | PG-13  |    185 |           1</span><br><span class="line">     349 | Gangs Pride        | PG-13  |    185 |           1</span><br><span class="line">     690 | Pond Seattle       | PG-13  |    185 |           1</span><br><span class="line">     817 | Soldiers Evolution | R      |    185 |           1</span><br><span class="line">     426 | Home Pity          | R      |    185 |           1</span><br><span class="line">     872 | Sweet Brotherhood  | R      |    185 |           1</span><br><span class="line">     821 | Sorority Queen     | NC-17  |    184 |           1</span><br><span class="line">     499 | King Evolution     | NC-17  |    184 |           1</span><br><span class="line">     820 | Sons Interview     | NC-17  |    184 |           1</span><br><span class="line">     198 | Crystal Breaking   | NC-17  |    184 |           1</span><br><span class="line">(14 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此示例中:</p>
<ul>
<li>首先，我们定义了一个CTE，该CTE会根据每个电影评分的长度返回电影排名。</li>
</ul>
<ul>
<li>其次，我们只选择长度排名为一的电影。</li>
</ul>
</blockquote>
<h2 id="使用CTE进行递归查询"><a href="#使用CTE进行递归查询" class="headerlink" title="使用CTE进行递归查询"></a>使用CTE进行递归查询</h2><blockquote>
<p>PostgreSQL提供了WITH语句，使您可以构造用于查询的辅助语句。这些语句通常称为通用表表达式或CTE。CTE类似于仅在查询执行期间存在的临时表。</p>
</blockquote>
<blockquote>
<p>递归查询是引用递归CTE的查询。递归查询在许多情况下非常有用，例如用于查询层次结构数据（例如组织结构，物料清单等）。</p>
</blockquote>
<h3 id="递归CTE的语法"><a href="#递归CTE的语法" class="headerlink" title="递归CTE的语法"></a>递归CTE的语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WITH RECURSIVE cte_name(</span><br><span class="line">    CTE_query_definition -- non-recursive term</span><br><span class="line">    UNION [ALL]</span><br><span class="line">    CTE_query definion  -- recursive term</span><br><span class="line">) SELECT * FROM cte_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>递归CTE具有三个要素:</p>
<ul>
<li>非递归术语:非递归术语是CTE查询定义，形成CTE结构的基本结果集。</li>
</ul>
<ul>
<li>递归术语:递归术语是使用UNION或UNION ALL运算符将一个或多个CTE查询定义与非递归术语结合在一起。 递归术语引用CTE名称本身。</li>
</ul>
<ul>
<li>终止检查:如果上一次迭代没有返回任何行，则递归停止。</li>
</ul>
</blockquote>
<blockquote>
<p>PostgreSQL按以下顺序执行递归CTE:</p>
<ul>
<li>执行非递归项以创建基本结果集（R0）。</li>
</ul>
<ul>
<li>以Ri作为输入执行递归项，以返回结果集Ri + 1作为输出。</li>
</ul>
<ul>
<li>重复步骤2，直到返回空集。 （终止检查）</li>
</ul>
<ul>
<li>返回最终结果集，该结果集是结果集R0，R1，…，Rn的UNION或UNION ALL。</li>
</ul>
</blockquote>
<h3 id="递归查询示例"><a href="#递归查询示例" class="headerlink" title="递归查询示例"></a>递归查询示例</h3><blockquote>
<p>创建一个新表来演示PostgreSQL递归查询。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE test5 (</span></span><br><span class="line">   employee_id serial PRIMARY KEY,</span><br><span class="line">   full_name VARCHAR NOT NULL,</span><br><span class="line">   manager_id INT</span><br><span class="line">);</span><br><span class="line">INSERT INTO test5 (</span><br><span class="line">   employee_id,</span><br><span class="line">   full_name,</span><br><span class="line">   manager_id</span><br><span class="line">)</span><br><span class="line">VALUES</span><br><span class="line">   (1, <span class="string">'Michael North'</span>, NULL),</span><br><span class="line">   (2, <span class="string">'Megan Berry'</span>, 1),</span><br><span class="line">   (3, <span class="string">'Sarah Berry'</span>, 1),</span><br><span class="line">   (4, <span class="string">'Zoe Black'</span>, 1),</span><br><span class="line">   (5, <span class="string">'Tim James'</span>, 1),</span><br><span class="line">   (6, <span class="string">'Bella Tucker'</span>, 2),</span><br><span class="line">   (7, <span class="string">'Ryan Metcalfe'</span>, 2),</span><br><span class="line">   (8, <span class="string">'Max Mills'</span>, 2),</span><br><span class="line">   (9, <span class="string">'Benjamin Glover'</span>, 2),</span><br><span class="line">   (10, <span class="string">'Carolyn Henderson'</span>, 3),</span><br><span class="line">   (11, <span class="string">'Nicola Kelly'</span>, 3),</span><br><span class="line">   (12, <span class="string">'Alexandra Climo'</span>, 3),</span><br><span class="line">   (13, <span class="string">'Dominic King'</span>, 3),</span><br><span class="line">   (14, <span class="string">'Leonard Gray'</span>, 4),</span><br><span class="line">   (15, <span class="string">'Eric Rampling'</span>, 4),</span><br><span class="line">   (16, <span class="string">'Piers Paige'</span>, 7),</span><br><span class="line">   (17, <span class="string">'Ryan Henderson'</span>, 7),</span><br><span class="line">   (18, <span class="string">'Frank Tucker'</span>, 8),</span><br><span class="line">   (19, <span class="string">'Nathan Ferguson'</span>, 8),</span><br><span class="line">   (20, <span class="string">'Kevin Rampling'</span>, 8);</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line">INSERT 0 20</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该表由三列组成:employee_id, manager_id和full name。manager_id列指定员工的经理ID。</p>
</blockquote>
<blockquote>
<p>查询ID为2的经理的所有下属</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># WITH RECURSIVE subordinates AS (</span></span><br><span class="line">   SELECT</span><br><span class="line">      employee_id,</span><br><span class="line">      manager_id,</span><br><span class="line">      full_name</span><br><span class="line">   FROM</span><br><span class="line">      test5</span><br><span class="line">   WHERE</span><br><span class="line">      employee_id = 2</span><br><span class="line">   UNION</span><br><span class="line">      SELECT</span><br><span class="line">         t.employee_id,</span><br><span class="line">         t.manager_id,</span><br><span class="line">         t.full_name</span><br><span class="line">      FROM</span><br><span class="line">         test5 t</span><br><span class="line">      INNER JOIN subordinates s ON s.employee_id = t.manager_id</span><br><span class="line">) SELECT</span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   subordinates;</span><br><span class="line"> employee_id | manager_id |    full_name</span><br><span class="line">-------------+------------+-----------------</span><br><span class="line">           2 |          1 | Megan Berry</span><br><span class="line">           6 |          2 | Bella Tucker</span><br><span class="line">           7 |          2 | Ryan Metcalfe</span><br><span class="line">           8 |          2 | Max Mills</span><br><span class="line">           9 |          2 | Benjamin Glover</span><br><span class="line">          16 |          7 | Piers Paige</span><br><span class="line">          17 |          7 | Ryan Henderson</span><br><span class="line">          18 |          8 | Frank Tucker</span><br><span class="line">          19 |          8 | Nathan Ferguson</span><br><span class="line">          20 |          8 | Kevin Rampling</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>
<ul>
<li>递归CTE，subordinates，定义一个非递归项和一个递归项。</li>
</ul>
<ul>
<li>非递归项返回ID为2的雇员的基本结果集R0。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">employee_id | manager_id |  full_name</span><br><span class="line">-------------+------------+-------------</span><br><span class="line">           2 |          1 | Megan Berry</span><br></pre></td></tr></table></figure>
<blockquote>
<p>递归项返回雇员ID 2的直接下属。这是雇员表和下属CTE之间联接的结果。递归项的第一次迭代将返回以下结果集：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> employee_id | manager_id |    full_name</span><br><span class="line">-------------+------------+-----------------</span><br><span class="line">           6 |          2 | Bella Tucker</span><br><span class="line">           7 |          2 | Ryan Metcalfe</span><br><span class="line">           8 |          2 | Max Mills</span><br><span class="line">           9 |          2 | Benjamin Glover</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PostgreSQL重复执行递归项。递归成员的第二次迭代将上面步骤中的结果集用作输入值，并返回以下结果集:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> employee_id | manager_id |    full_name</span><br><span class="line">-------------+------------+-----------------</span><br><span class="line">          16 |          7 | Piers Paige</span><br><span class="line">          17 |          7 | Ryan Henderson</span><br><span class="line">          18 |          8 | Frank Tucker</span><br><span class="line">          19 |          8 | Nathan Ferguson</span><br><span class="line">          20 |          8 | Kevin Rampling</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三次迭代返回空结果集，因为没有员工向ID为16、17、18、19和20的员工报告。</p>
</blockquote>
<blockquote>
<p>PostgreSQL返回最终结果集，该最终结果集是由非递归和递归项生成的第一次和第二次迭代中所有结果集的并集。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> employee_id | manager_id |    full_name</span><br><span class="line">-------------+------------+-----------------</span><br><span class="line">           2 |          1 | Megan Berry</span><br><span class="line">           6 |          2 | Bella Tucker</span><br><span class="line">           7 |          2 | Ryan Metcalfe</span><br><span class="line">           8 |          2 | Max Mills</span><br><span class="line">           9 |          2 | Benjamin Glover</span><br><span class="line">          16 |          7 | Piers Paige</span><br><span class="line">          17 |          7 | Ryan Henderson</span><br><span class="line">          18 |          8 | Frank Tucker</span><br><span class="line">          19 |          8 | Nathan Ferguson</span><br><span class="line">          20 |          8 | Kevin Rampling</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>
<h2 id="PostgreSQL-CTE的优势"><a href="#PostgreSQL-CTE的优势" class="headerlink" title="PostgreSQL CTE的优势"></a>PostgreSQL CTE的优势</h2><blockquote>
<p>以下是使用公用表表达式或CTE的一些优点:</p>
<ul>
<li>提高复杂查询的可读性。可使用CTE以更有条理和可读性的方式组织复杂的查询。</li>
</ul>
<ul>
<li>能够创建递归查询。递归查询是引用自己的查询。当您要查询层次结构数据（例如组织结构图或物料清单）时，递归查询会派上用场。</li>
<li>与窗口功能结合使用。您可以将CTE与窗口函数结合使用来创建初始结果集，并使用另一个select语句进一步处理该结果集。</li>
</ul>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    
    
    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="zhijiansd.github.io/blog/pg6/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhiJian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhiJian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/pg6/" class="post-title-link" itemprop="zhijiansd.github.io/page/2/index.html">PostgreSQL之分组与集合</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-20 11:27:41 / 修改时间：11:35:21" itemprop="dateCreated datePublished" datetime="2020-05-20T11:27:41+08:00">2020-05-20</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/postresql/" itemprop="url" rel="index"><span itemprop="name">postresql</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/pg6/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/pg6/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">12k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">20 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="GROUP-BY子句"><a href="#GROUP-BY子句" class="headerlink" title="GROUP BY子句"></a>GROUP BY子句</h2><blockquote>
<p>GROUP BY子句将SELECT语句返回的行分成几组。对于每个组，可以应用聚合函数，例如SUM()来计算项的总和，或者使用COUNT()来获取组中的项数。</p>
</blockquote>
<h3 id="GROUP-BY子句的语法"><a href="#GROUP-BY子句的语法" class="headerlink" title="GROUP BY子句的语法"></a>GROUP BY子句的语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_1, aggregate_function(column_2)</span><br><span class="line">FROM tbl_name</span><br><span class="line">GROUP BY column_1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>GROUP BY子句必须出现在FROM或WHERE子句之后。GROUP BY子句后面是一列或以逗号分隔的列的列表。除了表列之外，还可以将表达式与GROUP BY子句一起使用。</p>
</blockquote>
<h3 id="GROUP-BY子句示例1"><a href="#GROUP-BY子句示例1" class="headerlink" title="GROUP BY子句示例1"></a>GROUP BY子句示例1</h3><blockquote>
<p>在没有聚合函数的情况下使用GROUP BY查询从payment付款表中获取数据，并将结果按客户ID分组。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   customer_id</span><br><span class="line">FROM</span><br><span class="line">   payment</span><br><span class="line">GROUP BY</span><br><span class="line">   customer_id;</span><br><span class="line"> customer_id </span><br><span class="line">-------------</span><br><span class="line">         184</span><br><span class="line">          87</span><br><span class="line">         477</span><br><span class="line">         273</span><br><span class="line">         550</span><br><span class="line">          51</span><br><span class="line">         394</span><br><span class="line">         272</span><br><span class="line">          70</span><br><span class="line">         190</span><br><span class="line">         350</span><br><span class="line">         539</span><br><span class="line">         554</span><br><span class="line">         278</span><br><span class="line">         424</span><br><span class="line">         406</span><br><span class="line">         176</span><br><span class="line">         576</span><br><span class="line">         309</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这种情况下，GROUP BY的行为类似于DISTINCT子句，该子句从结果集中删除重复的行。</p>
</blockquote>
<h3 id="GROUP-BY子句示例2"><a href="#GROUP-BY子句示例2" class="headerlink" title="GROUP BY子句示例2"></a>GROUP BY子句示例2</h3><blockquote>
<p>GROUP BY子句与SUM()聚合函数一起使用获取客户已支付多少钱，使用GROUP BY子句将payments表分为几组；对于每个组，使用SUM()函数来计算总金额。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   customer_id,</span><br><span class="line">   SUM (amount)</span><br><span class="line">FROM</span><br><span class="line">   payment</span><br><span class="line">GROUP BY</span><br><span class="line">   customer_id;</span><br><span class="line"> customer_id |  sum   </span><br><span class="line">-------------+--------</span><br><span class="line">         184 |  80.80</span><br><span class="line">          87 | 137.72</span><br><span class="line">         477 | 106.79</span><br><span class="line">         273 | 130.72</span><br><span class="line">         550 | 151.69</span><br><span class="line">          51 | 123.70</span><br><span class="line">         394 |  77.80</span><br><span class="line">         272 |  65.87</span><br><span class="line">          70 |  75.83</span><br><span class="line">         190 | 102.75</span><br><span class="line">         350 |  63.79</span><br><span class="line">         539 |  84.80</span><br><span class="line">         554 |  95.80</span><br><span class="line">         278 |  71.79</span><br><span class="line">         424 | 109.71</span><br><span class="line">         406 | 121.69</span><br><span class="line">         176 | 151.68</span><br><span class="line">         576 | 135.68</span><br><span class="line">         309 | 113.75</span><br><span class="line">--More--</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">&gt; GROUP BY子句按客户ID对结果集进行排序，并累加属于同一客户的金额。每当customer_id更改时，它都会将行添加到返回的结果集中。</span><br><span class="line"></span><br><span class="line"><span class="comment">### GROUP BY子句示例3</span></span><br><span class="line">&gt; 将ORDER BY子句与GROUP BY子句一起使用以对组进行排序</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   customer_id,</span><br><span class="line">   SUM (amount)</span><br><span class="line">FROM</span><br><span class="line">   payment</span><br><span class="line">GROUP BY</span><br><span class="line">   customer_id</span><br><span class="line">ORDER BY</span><br><span class="line">   SUM (amount) DESC;</span><br><span class="line"> customer_id |  sum   </span><br><span class="line">-------------+--------</span><br><span class="line">         148 | 211.55</span><br><span class="line">         526 | 208.58</span><br><span class="line">         178 | 194.61</span><br><span class="line">         137 | 191.62</span><br><span class="line">         144 | 189.60</span><br><span class="line">         459 | 183.63</span><br><span class="line">         181 | 167.67</span><br><span class="line">         410 | 167.62</span><br><span class="line">         236 | 166.61</span><br><span class="line">         403 | 162.67</span><br><span class="line">         522 | 161.68</span><br><span class="line">         469 | 158.65</span><br><span class="line">         470 | 157.69</span><br><span class="line">         373 | 156.66</span><br><span class="line">         259 | 154.70</span><br><span class="line">         468 | 154.66</span><br><span class="line">         462 | 152.69</span><br><span class="line">         372 | 152.68</span><br><span class="line">         187 | 151.73</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<h3 id="GROUP-BY子句示例4"><a href="#GROUP-BY子句示例4" class="headerlink" title="GROUP BY子句示例4"></a>GROUP BY子句示例4</h3><blockquote>
<p>GROUP BY子句与COUNT()函数一起使用计算每个员工正在处理的交易数量，可以根据员工ID对付款表进行分组，并使用COUNT()函数获取交易数量。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   staff_id,</span><br><span class="line">   COUNT (payment_id)</span><br><span class="line">FROM</span><br><span class="line">   payment</span><br><span class="line">GROUP BY</span><br><span class="line">   staff_id;</span><br><span class="line"> staff_id | count</span><br><span class="line">----------+-------</span><br><span class="line">        1 |  7292</span><br><span class="line">        2 |  7304</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该GROUP BY子句按人员ID对结果集进行排序。它保持行的总数，并且每当职员id更改时，它将行添加到返回的结果集中。</p>
</blockquote>
<blockquote>
<p>要过滤组，请使用HAVING 子句。</p>
</blockquote>
<h2 id="HAVING子句"><a href="#HAVING子句" class="headerlink" title="HAVING子句"></a>HAVING子句</h2><blockquote>
<p>将HAVING子句与GROUP BY子句结合使用，以过滤不满足指定条件的组行。</p>
</blockquote>
<h3 id="HAVING子句的典型语法"><a href="#HAVING子句的典型语法" class="headerlink" title="HAVING子句的典型语法"></a>HAVING子句的典型语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">   column_1,</span><br><span class="line">   aggregate_function (column_2)</span><br><span class="line">FROM</span><br><span class="line">   tbl_name</span><br><span class="line">GROUP BY</span><br><span class="line">   column_1</span><br><span class="line">HAVING</span><br><span class="line">   condition;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>HAVING子句为GROUP BY在该GROUP BY子句应用后由该子句创建的组行设置条件，而WHERE子句为在该GROUP BY子句应用之前为单个行设置条件。这是HAVING和WHERE子句之间的主要区别。</p>
</blockquote>
<blockquote>
<p>在PostgreSQL中，可以使用不带GROUP BY子句的HAVING子句。在这种情况下，HAVING子句会将查询变成单个组。另外，SELECT列表和HAVING子句只能引用聚合函数中的列。如果HAVING子句中的条件为true，则此类查询返回单行；如果为false，则返回零行。</p>
</blockquote>
<h3 id="HAVING子句示例1"><a href="#HAVING子句示例1" class="headerlink" title="HAVING子句示例1"></a>HAVING子句示例1</h3><blockquote>
<p>使用GROUP BY子句获取每个客户的总金额</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   customer_id,</span><br><span class="line">   SUM (amount)</span><br><span class="line">FROM</span><br><span class="line">   payment</span><br><span class="line">GROUP BY</span><br><span class="line">   customer_id;</span><br><span class="line"> customer_id |  sum   </span><br><span class="line">-------------+--------</span><br><span class="line">         184 |  80.80</span><br><span class="line">          87 | 137.72</span><br><span class="line">         477 | 106.79</span><br><span class="line">         273 | 130.72</span><br><span class="line">         550 | 151.69</span><br><span class="line">          51 | 123.70</span><br><span class="line">         394 |  77.80</span><br><span class="line">         272 |  65.87</span><br><span class="line">          70 |  75.83</span><br><span class="line">         190 | 102.75</span><br><span class="line">         350 |  63.79</span><br><span class="line">         539 |  84.80</span><br><span class="line">         554 |  95.80</span><br><span class="line">         278 |  71.79</span><br><span class="line">         424 | 109.71</span><br><span class="line">         406 | 121.69</span><br><span class="line">         176 | 151.68</span><br><span class="line">         576 | 135.68</span><br><span class="line">         309 | 113.75</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用带有SUM函数的HAVING子句来选择花费超过200的客户</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   customer_id,</span><br><span class="line">   SUM (amount)</span><br><span class="line">FROM</span><br><span class="line">   payment</span><br><span class="line">GROUP BY</span><br><span class="line">   customer_id</span><br><span class="line">HAVING</span><br><span class="line">   SUM (amount) &gt; 200;</span><br><span class="line"> customer_id |  sum</span><br><span class="line">-------------+--------</span><br><span class="line">         526 | 208.58</span><br><span class="line">         148 | 211.55</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h3 id="HAVING子句示例2"><a href="#HAVING子句示例2" class="headerlink" title="HAVING子句示例2"></a>HAVING子句示例2</h3><blockquote>
<p>使用带有COUNT函数的HAVING子句查询每个商店的客户数量</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   store_id,</span><br><span class="line">   COUNT (customer_id)</span><br><span class="line">FROM</span><br><span class="line">   customer</span><br><span class="line">GROUP BY</span><br><span class="line">   store_id;</span><br><span class="line"> store_id | count</span><br><span class="line">----------+-------</span><br><span class="line">        1 |   326</span><br><span class="line">        2 |   273</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用带有COUNT函数的HAVING子句选择拥有300个以上客户的商店</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   store_id,</span><br><span class="line">   COUNT (customer_id)</span><br><span class="line">FROM</span><br><span class="line">   customer</span><br><span class="line">GROUP BY</span><br><span class="line">   store_id</span><br><span class="line">HAVING</span><br><span class="line">   COUNT (customer_id) &gt; 300;</span><br><span class="line"> store_id | count</span><br><span class="line">----------+-------</span><br><span class="line">        1 |   326</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h2 id="UNION运算符"><a href="#UNION运算符" class="headerlink" title="UNION运算符"></a>UNION运算符</h2><h3 id="UNION运算符的语法"><a href="#UNION运算符的语法" class="headerlink" title="UNION运算符的语法"></a>UNION运算符的语法</h3><blockquote>
<p>UNION运算符将两个或多个SELECT语句的结果集组合为一个结果集。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">   column_1,</span><br><span class="line">   column_2</span><br><span class="line">FROM</span><br><span class="line">   tbl_name_1</span><br><span class="line">UNION</span><br><span class="line">SELECT</span><br><span class="line">   column_1,</span><br><span class="line">   column_2</span><br><span class="line">FROM</span><br><span class="line">   tbl_name_2;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下是适用于查询的规则:</p>
<ul>
<li>两个查询必须返回相同数量的列。</li>
</ul>
<ul>
<li>查询中的相应列必须具有兼容的数据类型。</li>
</ul>
</blockquote>
<blockquote>
<p>除非使用UNION ALL，否则UNION运算符将删除所有重复的行。</p>
</blockquote>
<blockquote>
<p>UNION运算符可以将第一个查询中的行放在第二个查询的结果集中的行之前，之后或之间。 要按指定列对组合结果集中的行进行排序，请使用ORDER BY子句。</p>
</blockquote>
<h3 id="创建样例表"><a href="#创建样例表" class="headerlink" title="创建样例表"></a>创建样例表</h3><ul>
<li>y2018q1：存储2018年第一季度的销售数据。</li>
</ul>
<ul>
<li>y2018q2：存储2018年第二季度的销售数据。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE y2018q1 (</span></span><br><span class="line">    name VARCHAR PRIMARY KEY,</span><br><span class="line">    amount NUMERIC (8,2) NOT NULL</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">CREATE TABLE y2018q2 (</span><br><span class="line">    name VARCHAR PRIMARY KEY,</span><br><span class="line">    amount NUMERIC (8,2) NOT NULL</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">INSERT INTO y2018q1 (name,amount)</span><br><span class="line">VALUES</span><br><span class="line">    (<span class="string">'Mike'</span>,150000.25),</span><br><span class="line">    (<span class="string">'Jon'</span>,132000.25),</span><br><span class="line">    (<span class="string">'Mary'</span>,100000);</span><br><span class="line"> </span><br><span class="line">INSERT INTO y2018q2 (name,amount)</span><br><span class="line">VALUES</span><br><span class="line">    (<span class="string">'Mike'</span>,120000.25),</span><br><span class="line">    (<span class="string">'Jon'</span>,142000.25),</span><br><span class="line">    (<span class="string">'Mary'</span>,100000);</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line">INSERT 0 3</span><br><span class="line"></span><br><span class="line">INSERT 0 3</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># select * from y2018q1;</span></span><br><span class="line"> name |  amount</span><br><span class="line">------+-----------</span><br><span class="line"> Mike | 150000.25</span><br><span class="line"> Jon  | 132000.25</span><br><span class="line"> Mary | 100000.00</span><br><span class="line">(3 rows)</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># select * from y2018q2;</span></span><br><span class="line"> name |  amount</span><br><span class="line">------+-----------</span><br><span class="line"> Mike | 120000.25</span><br><span class="line"> Jon  | 142000.25</span><br><span class="line"> Mary | 100000.00</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<h3 id="UNION运算符示例1"><a href="#UNION运算符示例1" class="headerlink" title="UNION运算符示例1"></a>UNION运算符示例1</h3><blockquote>
<p>合并两张表中的数据</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT *</span></span><br><span class="line">FROM</span><br><span class="line">   y2018q1</span><br><span class="line">UNION</span><br><span class="line">SELECT *</span><br><span class="line">FROM</span><br><span class="line">   y2018q2;</span><br><span class="line"> name |  amount</span><br><span class="line">------+-----------</span><br><span class="line"> Mary | 100000.00</span><br><span class="line"> Jon  | 132000.25</span><br><span class="line"> Jon  | 142000.25</span><br><span class="line"> Mike | 120000.25</span><br><span class="line"> Mike | 150000.25</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里删除了重复的行。</p>
</blockquote>
<h3 id="UNION运算符示例2"><a href="#UNION运算符示例2" class="headerlink" title="UNION运算符示例2"></a>UNION运算符示例2</h3><blockquote>
<p>使用UNION ALL获取所有包含重复项的行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT *</span></span><br><span class="line">FROM</span><br><span class="line">   y2018q1</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT *</span><br><span class="line">FROM</span><br><span class="line">   y2018q2;</span><br><span class="line"> name |  amount</span><br><span class="line">------+-----------</span><br><span class="line"> Mike | 150000.25</span><br><span class="line"> Jon  | 132000.25</span><br><span class="line"> Mary | 100000.00</span><br><span class="line"> Mike | 120000.25</span><br><span class="line"> Jon  | 142000.25</span><br><span class="line"> Mary | 100000.00</span><br><span class="line">(6 rows)</span><br></pre></td></tr></table></figure>
<h3 id="UNION运算符示例3"><a href="#UNION运算符示例3" class="headerlink" title="UNION运算符示例3"></a>UNION运算符示例3</h3><blockquote>
<p>使用ORDER BY子句对UNION运算符返回的合并结果进行排序</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT *</span></span><br><span class="line">FROM</span><br><span class="line">   y2018q1</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT *</span><br><span class="line">FROM</span><br><span class="line">   y2018q2</span><br><span class="line">ORDER BY </span><br><span class="line"> name ASC,</span><br><span class="line"> amount DESC;</span><br><span class="line"> name |  amount</span><br><span class="line">------+-----------</span><br><span class="line"> Jon  | 142000.25</span><br><span class="line"> Jon  | 132000.25</span><br><span class="line"> Mary | 100000.00</span><br><span class="line"> Mary | 100000.00</span><br><span class="line"> Mike | 150000.25</span><br><span class="line"> Mike | 120000.25</span><br><span class="line">(6 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果将ORDER BY子句放在每个查询的末尾，则组合的结果集将不会按预期排序。因为当UNION运算符组合每个查询的排序结果集时，它不能保证最终结果集中的行顺序。</p>
</blockquote>
<h2 id="INTERSECT运算符"><a href="#INTERSECT运算符" class="headerlink" title="INTERSECT运算符"></a>INTERSECT运算符</h2><blockquote>
<p>INTERSECT运算符将两个或多个SELECT语句的结果集组合为一个结果集。INTERSECT运算符返回两个结果集中都可用或两个查询都返回的任何行。</p>
</blockquote>
<h3 id="INTERSECT运算符的语法"><a href="#INTERSECT运算符的语法" class="headerlink" title="INTERSECT运算符的语法"></a>INTERSECT运算符的语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">   column_list</span><br><span class="line">FROM</span><br><span class="line">   A</span><br><span class="line">INTERSECT</span><br><span class="line">SELECT</span><br><span class="line">   column_list</span><br><span class="line">FROM</span><br><span class="line">   B;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要使用INTERSECT运算符，SELECT语句中出现的列必须遵循以下规则:</p>
<ul>
<li>SELECT子句中的列数及其顺序必须相同。</li>
</ul>
<ul>
<li>列的数据类型必须兼容。</li>
</ul>
</blockquote>
<h3 id="创建示例表"><a href="#创建示例表" class="headerlink" title="创建示例表"></a>创建示例表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE employees (</span></span><br><span class="line">   employee_id serial PRIMARY KEY,</span><br><span class="line">   employee_name VARCHAR (255) NOT NULL</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">CREATE TABLE keys (</span><br><span class="line">   employee_id INT PRIMARY KEY,</span><br><span class="line">   effective_date DATE NOT NULL,</span><br><span class="line">   FOREIGN KEY (employee_id) REFERENCES employees (employee_id)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">CREATE TABLE hipos (</span><br><span class="line">   employee_id INT PRIMARY KEY,</span><br><span class="line">   effective_date DATE NOT NULL,</span><br><span class="line">   FOREIGN KEY (employee_id) REFERENCES employees (employee_id)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>employees表存储员工主数据，keys表存储关键员工，hipos表存储高潜力和高影响力的员工。</p>
</blockquote>
<h3 id="插入示例数据"><a href="#插入示例数据" class="headerlink" title="插入示例数据"></a>插入示例数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO employees (employee_name)</span></span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'Joyce Edwards'</span>),</span><br><span class="line">   (<span class="string">'Diane Collins'</span>),</span><br><span class="line">   (<span class="string">'Alice Stewart'</span>),</span><br><span class="line">   (<span class="string">'Julie Sanchez'</span>),</span><br><span class="line">   (<span class="string">'Heather Morris'</span>),</span><br><span class="line">   (<span class="string">'Teresa Rogers'</span>),</span><br><span class="line">   (<span class="string">'Doris Reed'</span>),</span><br><span class="line">   (<span class="string">'Gloria Cook'</span>),</span><br><span class="line">   (<span class="string">'Evelyn Morgan'</span>),</span><br><span class="line">   (<span class="string">'Jean Bell'</span>);</span><br><span class="line"> </span><br><span class="line">INSERT INTO keys</span><br><span class="line">VALUES</span><br><span class="line">   (1, <span class="string">'2000-02-01'</span>),</span><br><span class="line">   (2, <span class="string">'2001-06-01'</span>),</span><br><span class="line">   (5, <span class="string">'2002-01-01'</span>),</span><br><span class="line">   (7, <span class="string">'2005-06-01'</span>);</span><br><span class="line"> </span><br><span class="line">INSERT INTO hipos</span><br><span class="line">VALUES</span><br><span class="line">   (9, <span class="string">'2000-01-01'</span>),</span><br><span class="line">   (2, <span class="string">'2002-06-01'</span>),</span><br><span class="line">   (5, <span class="string">'2006-06-01'</span>),</span><br><span class="line">   (10, <span class="string">'2005-06-01'</span>);</span><br><span class="line">INSERT 0 10</span><br><span class="line"></span><br><span class="line">INSERT 0 4</span><br><span class="line"></span><br><span class="line">INSERT 0 4</span><br></pre></td></tr></table></figure>
<h3 id="INTERSECT运算符示例1"><a href="#INTERSECT运算符示例1" class="headerlink" title="INTERSECT运算符示例1"></a>INTERSECT运算符示例1</h3><blockquote>
<p>获取关键雇员和高潜力、高影响力的员工。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   employee_id</span><br><span class="line">FROM</span><br><span class="line">   keys;</span><br><span class="line"> employee_id</span><br><span class="line">-------------</span><br><span class="line">           1</span><br><span class="line">           2</span><br><span class="line">           5</span><br><span class="line">           7</span><br><span class="line">(4 rows)</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   employee_id</span><br><span class="line">FROM hipos;</span><br><span class="line"> employee_id</span><br><span class="line">-------------</span><br><span class="line">           9</span><br><span class="line">           2</span><br><span class="line">           5</span><br><span class="line">          10</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>获取既是关键雇员，又是高潜力和高影响力的员工。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   employee_id</span><br><span class="line">FROM</span><br><span class="line">   keys</span><br><span class="line">INTERSECT</span><br><span class="line">SELECT</span><br><span class="line">        employee_id</span><br><span class="line">FROM</span><br><span class="line">   hipos;</span><br><span class="line"> employee_id</span><br><span class="line">-------------</span><br><span class="line">           2</span><br><span class="line">           5</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果显示，员工ID 2和ID 5既是关键雇员，又是高潜力和高影响力的员工。</p>
</blockquote>
<h3 id="INTERSECT运算符示例2"><a href="#INTERSECT运算符示例2" class="headerlink" title="INTERSECT运算符示例2"></a>INTERSECT运算符示例2</h3><blockquote>
<p>要对INTERSECT运算符返回的结果集进行排序，可以将ORDER BY子句放在语句的末尾，而不是在每个SELECT语句的末尾。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   employee_id</span><br><span class="line">FROM</span><br><span class="line">   keys</span><br><span class="line">INTERSECT</span><br><span class="line">SELECT</span><br><span class="line">        employee_id</span><br><span class="line">FROM</span><br><span class="line">   hipos</span><br><span class="line">ORDER BY employee_id;</span><br><span class="line"> employee_id</span><br><span class="line">-------------</span><br><span class="line">           2</span><br><span class="line">           5</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h2 id="EXCEPT运算符"><a href="#EXCEPT运算符" class="headerlink" title="EXCEPT运算符"></a>EXCEPT运算符</h2><blockquote>
<p>EXCEPT运算符通过比较两个或多个查询的结果集来返回行。EXCEPT运算符从第一个(左)查询返回不属于第二个(右)查询输出的不同行。</p>
</blockquote>
<h3 id="EXCEPT运算符的语法"><a href="#EXCEPT运算符的语法" class="headerlink" title="EXCEPT运算符的语法"></a>EXCEPT运算符的语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_list</span><br><span class="line">FROM A</span><br><span class="line">WHERE condition_a</span><br><span class="line">EXCEPT </span><br><span class="line">SELECT column_list</span><br><span class="line">FROM B</span><br><span class="line">WHERE condition_b;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要使用EXCEPT运算符组合查询，必须遵守以下规则:</p>
<ul>
<li>在两个查询中，列数及其顺序必须相同。</li>
</ul>
<ul>
<li>各个列的数据类型必须兼容。</li>
</ul>
</blockquote>
<h3 id="EXCEPT运算符示例"><a href="#EXCEPT运算符示例" class="headerlink" title="EXCEPT运算符示例"></a>EXCEPT运算符示例</h3><blockquote>
<p>查询返回电影表中的电影</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   film_id,</span><br><span class="line">   title</span><br><span class="line">FROM</span><br><span class="line">   film</span><br><span class="line">ORDER BY</span><br><span class="line">   title;</span><br><span class="line"> film_id |            title            </span><br><span class="line">---------+-----------------------------</span><br><span class="line">       1 | Academy Dinosaur</span><br><span class="line">       2 | Ace Goldfinger</span><br><span class="line">       3 | Adaptation Holes</span><br><span class="line">       4 | Affair Prejudice</span><br><span class="line">       5 | African Egg</span><br><span class="line">       6 | Agent Truman</span><br><span class="line">       7 | Airplane Sierra</span><br><span class="line">       8 | Airport Pollock</span><br><span class="line">       9 | Alabama Devil</span><br><span class="line">      10 | Aladdin Calendar</span><br><span class="line">      11 | Alamo Videotape</span><br><span class="line">      12 | Alaska Phantom</span><br><span class="line">      14 | Alice Fantasia</span><br><span class="line">      15 | Alien Center</span><br><span class="line">      13 | Ali Forever</span><br><span class="line">      16 | Alley Evolution</span><br><span class="line">      17 | Alone Trip</span><br><span class="line">      18 | Alter Victory</span><br><span class="line">      19 | Amadeus Holy</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查询库存中的电影</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   distinct inventory.film_id,</span><br><span class="line">   title</span><br><span class="line">FROM</span><br><span class="line">   inventory</span><br><span class="line">INNER JOIN film ON film.film_id = inventory.film_id</span><br><span class="line">ORDER BY title;</span><br><span class="line"> film_id |            title            </span><br><span class="line">---------+-----------------------------</span><br><span class="line">       1 | Academy Dinosaur</span><br><span class="line">       2 | Ace Goldfinger</span><br><span class="line">       3 | Adaptation Holes</span><br><span class="line">       4 | Affair Prejudice</span><br><span class="line">       5 | African Egg</span><br><span class="line">       6 | Agent Truman</span><br><span class="line">       7 | Airplane Sierra</span><br><span class="line">       8 | Airport Pollock</span><br><span class="line">       9 | Alabama Devil</span><br><span class="line">      10 | Aladdin Calendar</span><br><span class="line">      11 | Alamo Videotape</span><br><span class="line">      12 | Alaska Phantom</span><br><span class="line">      15 | Alien Center</span><br><span class="line">      13 | Ali Forever</span><br><span class="line">      16 | Alley Evolution</span><br><span class="line">      17 | Alone Trip</span><br><span class="line">      18 | Alter Victory</span><br><span class="line">      19 | Amadeus Holy</span><br><span class="line">      20 | Amelie Hellfighters</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这两个查询都返回一个包含两列的结果集：film_id和title。</p>
</blockquote>
<blockquote>
<p>使用EXCEPT运算符获取不在库存中的电影</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   film_id,</span><br><span class="line">   title</span><br><span class="line">FROM</span><br><span class="line">   film</span><br><span class="line">EXCEPT</span><br><span class="line">   SELECT</span><br><span class="line">      DISTINCT inventory.film_id,</span><br><span class="line">      title</span><br><span class="line">   FROM</span><br><span class="line">      inventory</span><br><span class="line">   INNER JOIN film ON film.film_id = inventory.film_id</span><br><span class="line">ORDER BY title;</span><br><span class="line"> film_id |         title</span><br><span class="line">---------+------------------------</span><br><span class="line">      14 | Alice Fantasia</span><br><span class="line">      33 | Apollo Teen</span><br><span class="line">      36 | Argonauts Town</span><br><span class="line">      38 | Ark Ridgemont</span><br><span class="line">      41 | Arsenic Independence</span><br><span class="line">      87 | Boondock Ballroom</span><br><span class="line">     108 | Butch Panther</span><br><span class="line">     128 | Catch Amistad</span><br><span class="line">     144 | Chinatown Gladiator</span><br><span class="line">     148 | Chocolate Duck</span><br><span class="line">     171 | Commandments Express</span><br><span class="line">     192 | Crossing Divorce</span><br><span class="line">     195 | Crowds Telemark</span><br><span class="line">     198 | Crystal Breaking</span><br><span class="line">     217 | Dazed Punk</span><br><span class="line">     221 | Deliverance Mulholland</span><br><span class="line">     318 | Firehouse Vietnam</span><br><span class="line">     325 | Floats Garden</span><br><span class="line">     332 | Frankenstein Stranger</span><br><span class="line">     359 | Gladiator Westward</span><br><span class="line">     386 | Gump Date</span><br><span class="line">     404 | Hate Handicap</span><br><span class="line">     419 | Hocus Frida</span><br><span class="line">     495 | Kentuckian Giant</span><br><span class="line">     497 | Kill Brotherhood</span><br><span class="line">     607 | Muppet Mile</span><br><span class="line">     642 | Order Betrayed</span><br><span class="line">     669 | Pearl Destiny</span><br><span class="line">     671 | Perdition Fargo</span><br><span class="line">     701 | Psycho Shrunk</span><br><span class="line">     712 | Raiders Antitrust</span><br><span class="line">     713 | Rainbow Shock</span><br><span class="line">     742 | Roof Champion</span><br><span class="line">     801 | Sister Freddy</span><br><span class="line">     802 | Sky Miracle</span><br><span class="line">     860 | Suicides Silence</span><br><span class="line">     874 | Tadpole Park</span><br><span class="line">     909 | Treasure Command</span><br><span class="line">     943 | Villain Desperate</span><br><span class="line">     950 | Volume House</span><br><span class="line">     954 | Wake Jaws</span><br><span class="line">     955 | Walls Artist</span><br><span class="line">(42 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在语句的末尾放置了ORDER BY子句，以按名称对电影进行排序。</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    
    
    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="ZhiJian">
            
              <p class="site-author-name" itemprop="name">ZhiJian</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">43</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">26</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/zhijiansd" title="GitHub &rarr; https://github.com/zhijiansd" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:wangzhijiansd@qq.com" title="E-Mail &rarr; mailto:wangzhijiansd@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/zhitalk" title="weixin &rarr; zhitalk"><i class="fa fa-fw fa-weixin"></i>weixin</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="http://blog.51cto.com/wangzhijian" title="51blog &rarr; http://blog.51cto.com/wangzhijian" rel="noopener" target="_blank"><i class="fa fa-fw fa-pied-piper"></i>51blog</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhiJian</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">732k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">20:20</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.5.0</div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      本站总访问量<span class="busuanzi-value" id="busuanzi_value_site_uv"></span>人次
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      本站总访问量<span class="busuanzi-value" id="busuanzi_value_site_pv"></span>次
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
      
  
  <script type="text/javascript" color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  








  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  
  
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'YDspHswalVwn03xuqlx5EKQF-gzGzoHsz',
        appKey: 'pA3bP9yhf50EIhapICs6ohRC',
        placeholder: '欢迎评论',
        avatar:'mm',
        meta:guest,
        pageSize:'10' || 10,
        visitor: false
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  
  

  

  

  

  

  

  


  
     <script type="text/javascript" color="255,48,48" opacity="0.7" zindex="-2" count="150" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  

</body>
</html>
