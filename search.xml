<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[部署基于 Web 的 Kubernetes 多集群管理平台 -- 360 Wayne]]></title>
    <url>%2F2018%2F12%2F10%2F%E9%83%A8%E7%BD%B2%E5%9F%BA%E4%BA%8E-Web-%E7%9A%84-Kubernetes-%E5%A4%9A%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0-360-Wayne%2F</url>
    <content type="text"><![CDATA[Wayne 是一个通用的、基于 Web 的 Kubernetes 多集群管理平台。通过可视化 Kubernetes 对象模板编辑的方式，降低业务接入成本， 拥有完整的权限管理系统，适应多租户场景，是一款适合企业级集群使用的发布平台。 特性 基于 RBAC（Role based access control）的权限管理：用户通过角色与部门和项目关联，拥有部门角色允许操作部门资源，拥有项目角色允许操作项目资源，更加适合多租户场景。 简化 Kubernetes 对象创建：提供基础 Kubernetes 对象配置文件添加方式，同时支持高级模式直接编辑 Json/Yaml文件创建 Kubernetes 对象。 LDAP/OAuth 2.0/DB 多种登录模式支持：集成企业级 LDAP 登录及 DB 登录模式，同时还可以实现 OAuth2 登录。 支持多集群、多租户：可以同时管理多个 Kubernetes 集群，并针对性添加特定配置，更方便的多集群、多租户管理。 提供完整审计模块：每次操作都会有完整的审计功能，追踪用于操作历史，同时支持用户自定义 webhook。 提供基于 APIKey 的开放接口调用：用户可自主申请相关 APIKey 并管理自己的部门和项目，运维人员也可以申请全局 APIKey 进行特定资源的全局管理。 保留完整的发布历史：用户可以便捷的找到任何一次历史发布，并可轻松进行回滚，以及基于特定历史版本更新 Kubernetes 资源。 具备完善的资源报表：用户可以轻松获取各项目的资源使用占比和历史上线频次（天级）以及其他基础数据的报表和图表。 提供基于严密权限校验的 Web shell：用户可以通过 Web shell 的形式进入发布的 Pod 进行操作，自带完整的权限校验。 提供站内通知系统：方便管理员推送集群、业务通知和故障处理报告等。 架构 部署 Wayne下载相关文件并部署 Wayne 依赖 MySQL 和 RabbitMQ，其中 MySQL 是必须的服务，用户存储系统的各种数据，RabbitMQ 是可选的，主要用户扩展审计功能使用。 这里使用了 ceph 进行数据持久化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# git clone https://github.com/Qihoo360/wayne.git# cd wayne/hack/kubernetes/# vim dependency/mysql-pvc.yamlapiVersion: v1kind: PersistentVolumeClaimmetadata: name: mysql-wayne-pvc namespace: default labels: app: mysql-waynespec: storageClassName: default-rbd accessModes: - ReadWriteOnce resources: requests: storage: "10Gi"# vim dependency/rabbitmq-pvc.yamlapiVersion: v1kind: PersistentVolumeClaimmetadata: name: rabbitmq-wayne-pvc namespace: default labels: app: rabbitmq-waynespec: storageClassName: default-rbd accessModes: - ReadWriteOnce resources: requests: storage: "5Gi" # kubectl apply -f dependency/persistentvolumeclaim/mysql-wayne-pvc createddeployment.extensions/mysql-wayne createdservice/mysql-wayne createdpersistentvolumeclaim/rabbitmq-wayne-pvc createddeployment.extensions/rabbitmq-wayne createdservice/rabbitmq-wayne created# kubectl get podNAME READY STATUS RESTARTS AGEmysql-wayne-75947575d-mc972 1/1 Running 0 107srabbitmq-wayne-7c6dd8f475-l4pqj 1/1 Running 0 106s# kubectl apply -f wayne/configmap/infra-wayne createddeployment.extensions/infra-wayne createddeployment.extensions/infra-wayne-woker createddeployment.extensions/infra-wayne-webhook createdservice/infra-wayne created# kubectl get podNAME READY STATUS RESTARTS AGEinfra-wayne-5d84cf49b4-lggzs 1/1 Running 0 7m44sinfra-wayne-webhook-85dcf87c48-w4tcj 1/1 Running 0 7m44sinfra-wayne-woker-84bff6f8c9-mt7h5 1/1 Running 0 7m44s 现在可以通过 http://yourip:NodePort 访问 Wayne 平台，默认管理员账号 密码admin:admin。 注: 项目启动后还需要配置集群和 Namespace 等信息才可正常使用。 配置集群和 Namespace 进入后台将 .kube/config 复制并粘贴至 Wayne 平台 1# cat .kube/config 12# kubectl create namespace testnamespace/test created 123456graph TD A[管理员] --&gt; B[进入后台] B --&gt; C[集群] B --&gt; D[命名空间] C --&gt; |列表| F[创建集群] D --&gt; |列表| G[创建命名空间] 配置完成,在左侧边栏的 kubernetes 菜单栏可以查看当前集群的相关 node 信息、deployment 信息以及 PV 信息。 应用 Wayne创建项目 返回前台，切换至当前集群的选项卡”创建项目” 创建部署 进入该项目部署页“创建部署”进行部署，之后“创建部署模板”，之后点击“发布”，在弹出的选择框中选择需要部署的机房并“确认”即可部署到kubernetes。 部署成功后，可以选择“重启”、“下线”: 点击上线机房，通过弹出的选择框可以“进入容器”、“查看日志”: 创建负载均衡 点击该项目下左侧边栏的“负载均衡”项，之后“创建负载均衡”，配置“名称”和“机房”并提交。之后“创建负载均衡模板”,之后点击“发布”，在弹出的选择框中选择需要部署的机房并“确认”即可部署到kubernetes。 创建ingress 点击该项目下左侧边栏的“ingress”项，之后“创建ingress”，配置“名称”和“机房”并提交。之后“创建ingress模板”,之后点击“发布”，在弹出的选择框中选择需要部署的机房并“确认”即可部署到kubernetes。 确认部署情况 注: 这里使用了 https 是因为我之前部署了 TLS 认证的 traefik。 更多详情请访问 Wayne 官方 wiki: wayne]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>wayne</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对etcd集群及kubernetes集群进行升级]]></title>
    <url>%2F2018%2F12%2F07%2F%E5%AF%B9etcd%E9%9B%86%E7%BE%A4%E5%8F%8Akubernetes%E9%9B%86%E7%BE%A4%E8%BF%9B%E8%A1%8C%E5%8D%87%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[我的etcd集群和kubernetes集群都是二进制安装的，所以升级主要就是替换二进制文件。 这里我将原版本为3.3.8的etcd集群升级到3.3.10版本，将原版本为v1.11.1的kubernetes集群升级到v1.13.0版本，而我这里的kubernetes集群使用keepalived+haproxy做了双master的高可用、负载均衡，所以并无集群下线之忧。 升级 Etcd 集群升级检查查看集群健康状况12345678# ETCDCTL_API=3 # etcdctl --endpoints=https://192.168.100.181:2379 cluster-healthmember 3a406a85e3de7ef5 is healthy: got healthy result from https://192.168.100.184:2379member 695714eeb38cebbe is healthy: got healthy result from https://192.168.100.181:2379member ab8f0f710ce0bf85 is healthy: got healthy result from https://192.168.100.183:2379member c5cb8024e23348b6 is healthy: got healthy result from https://192.168.100.182:2379member ceb2db537a9ec20d is healthy: got healthy result from https://192.168.100.185:2379cluster is healthy 查看版本12# curl https://192.168.100.181:2379/version&#123;"etcdserver":"3.3.8","etcdcluster":"3.3.0"&#125; 使用快照备份 Etcd 集群 etcd leader拥有最新的应用程序数据，从leader获取快照etcd_server_is_leader 是1即为leader，否则为0。 123456789# curl -sL https://192.168.100.181:2379/metrics | grep etcd_server_is_leader# HELP etcd_server_is_leader Whether or not this member is a leader. 1 if is, 0 otherwise.# TYPE etcd_server_is_leader gaugeetcd_server_is_leader 0# curl -sL https://192.168.100.182:2379/metrics | grep etcd_server_is_leader# HELP etcd_server_is_leader Whether or not this member is a leader. 1 if is, 0 otherwise.# TYPE etcd_server_is_leader gaugeetcd_server_is_leader 1 当然，也可以使用该命令查看谁是leader 123456# etcdctl --endpoints=https://192.168.100.181:2379 member list3a406a85e3de7ef5: name=etcd-184 peerURLs=https://192.168.100.184:2380 clientURLs=https://192.168.100.184:2379 isLeader=false695714eeb38cebbe: name=etcd-181 peerURLs=https://192.168.100.181:2380 clientURLs=https://192.168.100.181:2379 isLeader=falseab8f0f710ce0bf85: name=etcd-183 peerURLs=https://192.168.100.183:2380 clientURLs=https://192.168.100.183:2379 isLeader=falsec5cb8024e23348b6: name=etcd-182 peerURLs=https://192.168.100.182:2380 clientURLs=https://192.168.100.182:2379 isLeader=trueceb2db537a9ec20d: name=etcd-185 peerURLs=https://192.168.100.185:2380 clientURLs=https://192.168.100.185:2379 isLeader=false 使用快照备份集群12345678# ETCDCTL_API=3 etcdctl --endpoints https://192.168.100.182:2379 snapshot save snapshotdbSnapshot saved at snapshotdb# ETCDCTL_API=3 etcdctl --write-out=table snapshot status snapshotdb+----------+----------+------------+------------+| HASH | REVISION | TOTAL KEYS | TOTAL SIZE |+----------+----------+------------+------------+| c09e95e0 | 11794749 | 1226 | 19 MB |+----------+----------+------------+------------+ 下载并解压 Etcd1# tar -zxvf etcd-v3.3.10-linux-amd64.tar.gz 停止一个现有 Etcd 服务器1# systemctl stop etcd 替换 Etcd 二进制文件，使用相同配置重启 Etcd 服务器123456789101112# cp etcd-v3.3.10-linux-amd64/etcd /usr/bin/# cp etcd-v3.3.10-linux-amd64/etcdctl /usr/bin/# systemctl start etcd# systemctl status etcd# etcdctl --endpoints=https://192.168.100.181:2379 cluster-healthmember 3a406a85e3de7ef5 is healthy: got healthy result from https://192.168.100.184:2379member 695714eeb38cebbe is healthy: got healthy result from https://192.168.100.181:2379member ab8f0f710ce0bf85 is healthy: got healthy result from https://192.168.100.183:2379member c5cb8024e23348b6 is healthy: got healthy result from https://192.168.100.182:2379member ceb2db537a9ec20d is healthy: got healthy result from https://192.168.100.185:2379cluster is healthy 对其余成员重复如上步骤 在未升级的成员将记录以下警告，直到升级整个集群 123# systemctl status etcdthe local etcd version 3.3.8 is not up-to-datemember 695714eeb38cebbe has a higher version 3.3.10 查看集群成员健康状况和版本123456789101112131415161718# etcdctl --endpoints=https://192.168.100.181:2379 cluster-healthmember 3a406a85e3de7ef5 is healthy: got healthy result from https://192.168.100.184:2379member 695714eeb38cebbe is healthy: got healthy result from https://192.168.100.181:2379member ab8f0f710ce0bf85 is healthy: got healthy result from https://192.168.100.183:2379member c5cb8024e23348b6 is healthy: got healthy result from https://192.168.100.182:2379member ceb2db537a9ec20d is healthy: got healthy result from https://192.168.100.185:2379cluster is healthy# curl https://192.168.100.181:2379/version&#123;"etcdserver":"3.3.10","etcdcluster":"3.3.0"&#125;# curl https://192.168.100.182:2379/version&#123;"etcdserver":"3.3.10","etcdcluster":"3.3.0"&#125;# curl https://192.168.100.183:2379/version&#123;"etcdserver":"3.3.10","etcdcluster":"3.3.0"&#125;# curl https://192.168.100.184:2379/version&#123;"etcdserver":"3.3.10","etcdcluster":"3.3.0"&#125;# curl https://192.168.100.185:2379/version&#123;"etcdserver":"3.3.10","etcdcluster":"3.3.0"&#125; 升级 Kubernetes 集群查看当前集群版本12345# kubectl get node NAME STATUS ROLES AGE VERSIONnode01 Ready &lt;none&gt; 131d v1.11.1node02 Ready &lt;none&gt; 131d v1.11.1node03 Ready &lt;none&gt; 131d v1.11.1 下载并解压文件12# tar -zxvf kubernetes-server-linux-amd64.tar.gz# cd kubernetes/server/bin 升级 Master 节点停止 Master 节点相关组件123# systemctl stop kube-apiserver# systemctl stop kube-controller-manager# systemctl stop kube-scheduler 替换 Master 节点二进制组件1# cp kube-apiserver kube-controller-manager kube-scheduler kubeadm /usr/bin/ 重新启用 Master 节点12345678# systemctl start kube-apiserver# systemctl status kube-apiserver# systemctl start kube-controller-manager# systemctl status kube-controller-manager# systemctl start kube-scheduler# systemctl status kube-scheduler 在其他 Master 节点重复如上步骤进行升级 升级 Node 节点标记节点为不可调度 设置为不可调度后，新的 pod 不会迁移或者部署在该节点 12345# kubectl cordon node01node/node01 cordoned# kubectl get node | grep node01node01 Ready,SchedulingDisabled &lt;none&gt; 131d v1.11.1 迁移该节点的 Pod 迁移时注意系统瓶颈，当其他节点的CPU、内存或者本地存储资源不足，kubernetes都不会调用pod，pod会处于pending状态，直到重新上线该节点(或者扩容节点资源)，pod才会重新上线。 1234567# kubectl drain --ignore-daemonsets --delete-local-data node01 kubectl drain node01 --ignore-daemonsets --delete-local-datanode/node01 already cordonedWARNING: Ignoring DaemonSet-managed pods: ......; Deleting pods with local storage: ......pod/my-nginx-7ff9b54467-vk572 evicted......node/node01 evicted 注:对于DaemonSet-managed pods需要使用参数–ignore-daemonsets;迁移使用本地存储的pods需要使用参数–delete-local-data(移动到其他节点将清空数据)。 查看节点上是否还存在 Pods(DaemonSet pods忽略)1# kubectl get pod -o wide --all-namespaces | grep node01 查看 Pods 是否已移动到其他节点1# kubectl get pod -o wide --all-namespaces 停用该节点 Kubelet 和 Kube-proxy12# systemctl stop kubelet# systemctl stop kube-proxy 复制并替换相应二进制文件12# scp root@master1:/root/kubernetes/server/bin/kubelet /usr/bin/# scp root@master1:/root/kubernetes/server/bin/kube-proxy /usr/bin/ 启用该 Node 节点1234# systemctl start kubelet# systemctl status kubelet# systemctl start kube-proxy# systemctl status kube-proxy 在 Master 节点上解锁(重新上线)该 Node 节点12345# kubectl uncordon node01node/node01 uncordoned# kubectl get node | grep node01node01 Ready &lt;none&gt; 131d v1.13.0 在其他 Node 节点重复如上步骤以升级 Node 节点 查看系统是否升级成功12345# kubectl get node NAME STATUS ROLES AGE VERSIONnode01 Ready &lt;none&gt; 131d v1.13.0node02 Ready &lt;none&gt; 131d v1.13.0node03 Ready &lt;none&gt; 131d v1.13.0]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>etcd</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Harbor从1.5.1升级和迁移到1.6.2]]></title>
    <url>%2F2018%2F11%2F23%2FHarbor%E4%BB%8E1-5-1%E5%8D%87%E7%BA%A7%E5%92%8C%E8%BF%81%E7%A7%BB%E5%88%B01-6-2%2F</url>
    <content type="text"><![CDATA[这次升级还算比较顺利，以前我从1.2版本升级到1.5版本没有升级成功，镜像全洗白了，所以这次升级我及其谨慎，官方文档看了又看(主要是文档排版太糟糕了)，生怕又给洗白了，当然结果是好的，成功升级。 官方改了三次数据库，从最早使用的MySQL迁移到MariaDB，从1.6.0开始又迁移到了Postgresql 在1.5.1版中我并没有安装运行Notary和Clair这两个组件 升级到1.6.2版后我新部署了Notary，Clair和Helm Chart这3个组件 备份Harbor停止Harbor12# cd harbor# docker-compose down 备份Harbor的当前文件,以便在必要时回滚到当前版本12# cd ..# mv harbor harbor-backup 下载迁移工具12# docker pull goharbor/harbor-migrator:v1.6.0goharbor/harbor-migrator v1.6.0 22775c4e4066 2 months ago 803MB 备份数据1234567# mkdir backup# docker run -it --rm -e DB_USR=root -e DB_PWD=root123 -v /data/database:/var/lib/mysql -v /root/harbor-backup/harbor.cfg:/harbor-migration/harbor-cfg/harbor.cfg -v /root/backup:/harbor-migration/backup goharbor/harbor-migrator:v1.6.0 backup......Backup performed.Success to backup harbor.cfg.# ls backupharbor.cfg registry.sql 命令参考: docker run -it –rm -e DB_USR=root -e DB_PWD={db_pwd} -v ${harbor_db_path}:/var/lib/mysql -v ${harbor_cfg}:/harbor-migration/harbor-cfg/harbor.cfg -v ${backup_path}:/harbor-migration/backup goharbor/harbor-migrator:[tag] backup 升级数据库架构、harbor.cfg并迁移数据 注意：您必须在启动Harbor之前运行Notary和Clair的DB的迁移。注意：在v1.6.0中，您需要执行三个连续步骤才能完全迁移Harbor，Notary和Clair的DB。 1234567891011# docker run -it --rm -e DB_USR=root -e DB_PWD=root123 -v /data/database:/var/lib/mysql -v /root/backup/harbor.cfg:/harbor-migration/harbor-cfg/harbor.cfg goharbor/harbor-migrator:v1.6.0 upPlease backup before upgrade, Enter y to continue updating or n to abort: yTrying to start mysql server...Waiting for MySQL start.........server stoppedThe path of the migrated harbor.cfg is not set, the input file will be overwritten.input version: 1.5.0, migrator chain: ['1.6.0']migrating to version 1.6.0Written new values to /harbor-migration/harbor-cfg/harbor.cfg 命令参考: docker run -it –rm -e DB_USR=root -e DB_PWD={db_pwd} -v ${harbor_db_path}:/var/lib/mysql -v ${harbor_cfg}:/harbor-migration/harbor-cfg/harbor.cfg -v ${backup_path}:/harbor-migration/backup goharbor/harbor-migrator:[tag] backup 将harbor.cfg迁移至新版本的安装目录123456# docker run -it --rm -v /root/backup/harbor.cfg:/harbor-migration/harbor-cfg/harbor.cfg goharbor/harbor-migrator:v1.6.0 --cfg up# grep ^[a-z] backup/harbor.cfg# tar -zxvf harbor-offline-installer-v1.6.2.tgz # cd harbor# mv harbor.cfg harbor.cfg.bak# cp /root/backup/harbor.cfg /root/harbor 命令参考: docker run -it –rm -v ${harbor_cfg}:/harbor-migration/harbor-cfg/harbor.cfg goharbor/harbor-migrator:[tag] –cfg up 安装Harbor载入镜像12# docker load -i harbor.v1.6.2.tar.gz# docker images|grep 1.6.2 安装Notary，Clair和Helm Chart服务1234567# ./install.sh --with-notary --with-clair --with-chartmuseum......✔ ----Harbor has been installed and started successfully.----Now you should be able to visit the admin portal at https://192.168.100.100. For more details, please visit https://github.com/goharbor/harbor . 在安装升级过程中我又重新使用docker-compose命令安装了一次，供参考123456789101112131415161718192021# docker-compose -f ./docker-compose.yml -f ./docker-compose.notary.yml -f ./docker-compose.clair.yml -f ./docker-compose.chartmuseum.yml down -v# vim harbor.cfg# ./prepare --with-notary --with-clair --with-chartmuseum......The configuration files are ready, please use docker-compose to start the service.# docker-compose -f ./docker-compose.yml -f ./docker-compose.notary.yml -f ./docker-compose.clair.yml -f ./docker-compose.chartmuseum.yml up -d# docker-compose -f ./docker-compose.yml -f ./docker-compose.notary.yml -f ./docker-compose.clair.yml -f ./docker-compose.chartmuseum.yml psName Command State Ports -----------------------------------------------------------------------------chartmuseum /docker-entrypoint.sh Up (healthy) 9999/tcp clair /docker-entrypoint.sh Up (healthy) 6060/tcp, 6061/tcp harbor-adminserver /harbor/start.sh Up (healthy) harbor-db /entrypoint.sh postgres Up (healthy) 5432/tcp harbor-jobservice /harbor/start.sh Up harbor-log /bin/sh -c /usr/local/bin/ ... Up (healthy) 127.0.0.1:1514-&gt;10514/tcp harbor-ui /harbor/start.sh Up (healthy) nginx nginx -g daemon off; Up (healthy) 0.0.0.0:443-&gt;443/tcp, 0.0.0.0:4443-&gt;4443/tcp, 0.0.0.0:80-&gt;80/tcpnotary-server /bin/server-start.sh Up notary-signer /bin/signer-start.sh Up redis docker-entrypoint.sh redis ... Up 6379/tcp registry /entrypoint.sh /etc/regist ... Up (healthy) 5000/tcp 如果要同时安装Notary，Clair和Helm Chart服务，则应在docker-compose和prepare命令中包含所有组件. 如上，harbor已经完成升级，可使用浏览器登陆harbor查看是否成功升级. Notary 使用 如果要启用内容信任以确保图像已签名，请在推送或拉取任何图像之前在命令行中设置两个环境变量： 12# export DOCKER_CONTENT_TRUST=1# export DOCKER_CONTENT_TRUST_SERVER=https://192.168.100.100:4443 这里以上传kubernetes-dashboard为例子说明notary的使用. 1234567891011121314151617181920212223# docker push 192.168.100.100/google_containers/kubernetes-dashboard-amd64:v1.10.0The push refers to repository [192.168.100.100/google_containers/kubernetes-dashboard-amd64]5f222ffea122: Pushed v1.10.0: digest: sha256:1d2e1229a918f4bc38b5a3f9f5f11302b3e71f8397b492afac7f273a0008776a size: 529Signing and pushing trust metadataYou are about to create a new root signing key passphrase. This passphrasewill be used to protect the most sensitive key in your signing system. Pleasechoose a long, complex passphrase and be careful to keep the password and thekey file itself secure and backed up. It is highly recommended that you use apassword manager to generate the passphrase and keep it safe. There will be noway to recover this key. You can find the key in your config directory.## 第一次push镜像，系统将要求您输入根密钥密码Enter passphrase for new root key with ID 7ffe68f: Repeat passphrase for new root key with ID 7ffe68f: ## 密码设置弱系统会进行提示Enter passphrase for new repository key with ID e8c208d: Passphrase is too short. Please use a password manager to generate and store a good random passphrase.Enter passphrase for new repository key with ID e8c208d: Repeat passphrase for new repository key with ID e8c208d: Finished initializing "192.168.100.100/google_containers/kubernetes-dashboard-amd64"Successfully signed 192.168.100.100/google_containers/kubernetes-dashboard-amd64:v1.10.0 注1: 根密钥生成于: /root/.docker/trust/private/镜像密码生成于: /root/.docker/trust/tuf/[registry name]/[imagepath]注2: 要使用notary，必须在Harbor中启用HTTPS.注3: 当镜像被签名时，它在UI中显示勾号; 否则，显示交叉符号（X）。注4:如果您省略标签，则跳过内容信任。提示”No tag specified, skipping trust metadata push”，所以即便是 latest 也需要提供镜像 tag 值。 通过Clair进行漏洞扫描Clair依靠漏洞元数据来完成分析过程。第一次初始安装后，Clair将自动开始从不同的漏洞存储库更新元数据数据库。更新过程可能需要一段时间，具体取决于数据大小和网络连接。如果数据库尚未完全填充，则存储库数据网格视图的页脚会显示警告消息。 数据库准备就绪后，整个数据库更新的时间戳将显示在“管理”下“ 配置”部分的“漏洞”选项卡中。这时候就可以进行漏洞扫描了。 注意：只有具有“项目管理员”角色的用户才有权启动分析过程。 分析过程可能显示如下状态： 未扫描：标签从未被扫描过。 排队：扫描任务已安排但尚未执行。 扫描：扫描过程正在进行中。 错误：扫描过程未能完成。 完成：扫描过程已成功完成。 关于漏洞的严重级别: 红色： 高安全漏洞的级别 橙色： 中等级别的漏洞 黄色： 漏洞程度低 灰色： 未知级别的漏洞 绿色： 没有漏洞 由于Harbor是由VMware中国的团队研发并开源的，对中文支持友好，对于使用问题无需过多担心。 附:有关Notary和Docker Content Trust的更多信息，请参阅Docker的文档：https://docs.docker.com/engine/security/trust/content_trust/关于Clair:https://github.com/coreos/clairHarbor用户指南: https://github.com/goharbor/harbor/blob/master/docs/user_guide.md]]></content>
      <categories>
        <category>镜像仓库</category>
      </categories>
      <tags>
        <tag>harbor</tag>
        <tag>docker</tag>
        <tag>registry</tag>
        <tag>notary</tag>
        <tag>clair</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github构建博客]]></title>
    <url>%2F2018%2F11%2F21%2FHexo-Github%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[在开始构建博客前，你需要在Github拥有一个账号,之后新建一个存储库(比如:zhijiansd.github.io),这里我就不再赘述了.接下来,我们需要为GitHub添加SSH key. 配置SSH key在本地创建秘钥,并将该秘钥复制下来12# ssh-keygen -t rsa -C "wangzhijiansd@qq.com"# cat /root/.ssh/id_rsa.pub 登录GitHub进行配置打开Github主页，依次点击Settings -&gt; SSH and GPG keys -&gt; New SSH key设置,自定义好Title,然后将上面复制的秘钥粘贴在Key下.进行测试1# ssh -T git@github.com 如果提示Are you sure you want to continue connecting (yes/no)?,输入yes.看到如下信息说明SSH已配置成功: Hi zhijiansd! You’’ve successfully authenticated, but GitHub does not provide shell access. 配置用户信息12# git config --global user.name "zhijiansd"# git config --global user.email "wangzhijiansd@qq.com" 安装Hexo并下载Next主题123456# yum -y install git nodejs # npm install hexo-cli -g# hexo init blog# cd blog# npm install# git clone https://github.com/theme-next/hexo-theme-next themes/next 更多主题详见Hexo. 配置Hexo更改默认主题为Next1# sed -i "s/landscape/next/g" _config.yml ###更改默认语言为汉语12# grep language _config.yml language: zh-CN 配置Next更改Next主题外观123# grep scheme themes/next/_config.yml|grep Pisces scheme: Pisces# Only fit scheme Pisces 设置菜单1234567# vim themes/next/_config.ymlmenu: home: / || home //首页 #about: /about/ || user //关于 tags: /tags/ || tags //标签 categories: /categories/ || th //分类 archives: /archives/ || archive //归档 创建标签文件夹并添加type1234# hexo new page "tags"# vim source/tags/index.mdtype: "tags"comments: false 创建分类文件夹并添加type1234# hexo new page "categories"# vim source/categories/index.mdtype: "categories"comments: false 创建归档文件夹并添加type1234# hexo new page "archives"# vim source/archives/index.mdtype: archivescomments: false 设置头像123456# mkdir source/images# ls source/images/avatar.jpg# vim themes/next/_config.ymlavatar: url: /images/avatar.jpg 请自行将头像图片上传至source/images/文件夹下 修改文章内链接文本样式1234567891011# vim themes/next/source/css/_common/components/post/post.styl.post-body p a&#123; color: #0593d3; //原始链接颜色 border-bottom: none; border-bottom: 1px solid #0593d3; //底部分割线颜色 &amp;:hover &#123; color: #fc6423; //鼠标经过颜色 border-bottom: none; border-bottom: 1px solid #fc6423; //底部分割线颜色 &#125;&#125; 在文章末尾添加结束语 新建并配置passage-end-tag.swig文件 123456# vim themes/next/layout/_macro/passage-end-tag.swig&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束,感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 在post.swig文件的post-body之后，post-footer之前添加以下代码 123456# vim themes/next/layout/_macro/post.swig &lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125; &lt;/div&gt; 修改主题配置文件_config.yml，在末尾添加:如下: 123# vim themes/next/_config.ymlpassage_end_tag: enabled: true 实现文章统计功能 安装插件 1# npm install hexo-symbols-count-time --save 配置启用hexo配置文件的symbols项 1234567# vim _config.yml# Writingsymbols_count_time: symbols: true time: true total_symbols: true total_time: true 配置启用next主题配置文件的symbols项 1234567# vim themes/next/_config.ymlsymbols_count_time: separated_meta: true item_text_post: true item_text_total: true awl: 2 ##平均单词长度（单词的计数）。默认值:4。CN≈2 EN≈5 wpm: 300 ##每分钟的单词。默认值:275。缓慢≈200 正常≈275 快≈350 设置页面文章的篇数1234567891011# vim themes/next/_config.ymlindex_generator: per_page: 5archive_generator: per_page: 20 yearly: true monthly: truetag_generator: per_page: 10 启用访客量以及文章阅读量统计123# vim themes/next/_config.yml busuanzi_count: enable: true 给文章增加阴影效果12345678# vim themes/next/source/css/_custom/custom.styl.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 添加站内搜索12345# npm install hexo-generator-search --save# npm install hexo-generator-searchdb --save# vim themes/next/_config.yml local_search: enable: true 设置动态背景 配置启用next主题配置文件的canvas_nest项 123# vim themes/next/_config.yml canvas_nest: enable: true 在如下文件的行尾之前添加代码 1234# vim themes/next/layout/_layout.swig &#123;% if theme.canvas_nest %&#125; &lt;script type="text/javascript" color="255,0,255" opacity='0.7' zIndex="-2" count="150" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt; &#123;% endif %&#125; 修改标签样式12# vim themes/next/layout/_macro/post.swig&lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;&lt;i class="fa fa-tag"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; 在文件中搜索 rel=”tag”&gt;#,将 # 换成 ,不过这里的注释会直接显示改后的样式，上面就是更改后的样式，请参考. 生成Hexo1# hexo g 开启预览访问端口123# hexo server -i 192.168.100.122INFO Start processingINFO Hexo is running at http://192.168.100.122:4000 . Press Ctrl+C to stop. 浏览器输入如上IP和端口即可在本地访问该博客 配置部署Hexo博客到GitHub 配置Hexo配置文件 12345# vim _config.ymldeploy: type: git repository: https://github.com/zhijiansd/zhijiansd.github.io branch: master 安装插件 1# npm install hexo-deployer-git --save 将Hexo部署到GitHub，之后浏览器输入zhijiansd.github.io查看 1# hexo d hexo的常用命令如下: 命令 解释 hexo init 初始化 hexo g 生成静态网页 hexo s 启动服务预览 hexo d 部署hexo hexo clean 清除缓存 hexo n 新建文章 hexo publish 草稿 注: NexT中文文档 Hexo中文文档]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
