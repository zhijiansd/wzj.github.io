<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="ZhiJian">
<meta property="og:url" content="zhijiansd.github.io/index.html">
<meta property="og:site_name" content="ZhiJian">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZhiJian">






  <link rel="canonical" href="zhijiansd.github.io/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>ZhiJian</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZhiJian</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="zhijiansd.github.io/blog/pg17/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhiJian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhiJian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/pg17/" class="post-title-link" itemprop="zhijiansd.github.io/index.html">PostgreSQL之函数</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-20 13:30:46 / 修改时间：13:32:10" itemprop="dateCreated datePublished" datetime="2020-05-20T13:30:46+08:00">2020-05-20</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/postresql/" itemprop="url" rel="index"><span itemprop="name">postresql</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/pg17/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/pg17/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">39k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1:05</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CUME-DIST函数"><a href="#CUME-DIST函数" class="headerlink" title="CUME_DIST函数"></a>CUME_DIST函数</h2><h3 id="CUME-DIST-函数语法"><a href="#CUME-DIST-函数语法" class="headerlink" title="CUME_DIST()函数语法"></a>CUME_DIST()函数语法</h3><blockquote>
<p>CUME_DIST()函数返回一组值中某个值的累积分布。换句话说，它返回一个值在一组值中的相对位置。</p>
</blockquote>
<blockquote>
<p>CUME_DIST()函数的语法如下:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CUME_DIST() OVER (</span><br><span class="line">    [PARTITION BY partition_expression, ... ]</span><br><span class="line">    ORDER BY sort_expression [ASC | DESC], ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>PARTITION BY子句:<br>PARTITION BY子句将行分成多个应用了该功能的分区。该是可选的，如果跳过它，则CUME_DIST()函数会将整个结果集视为一个分区。</li>
</ul>
<ul>
<li>ORDER BY子句:<br>ORDER BY子句对应用CUME_DIST()函数的每个分区中的行进行排序。</li>
</ul>
<ul>
<li>返回值：<br>CUME_DIST()一个双精度值，该值大于0且小于或等于1：0 &lt; CUME_DIST() &lt;= 1。该函数针对相同的联系值返回相同的累积分布值。</li>
</ul>
<h3 id="CUME-DIST-函数示例"><a href="#CUME-DIST-函数示例" class="headerlink" title="CUME_DIST()函数示例"></a>CUME_DIST()函数示例</h3><blockquote>
<p>首先，创建一个名为sales_stats的新表，该表存储员工的销售收入：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE sales_stats(</span></span><br><span class="line">    name VARCHAR(100) NOT NULL,</span><br><span class="line">    year SMALLINT NOT NULL CHECK (year &gt; 0),</span><br><span class="line">    amount DECIMAL(10,2) CHECK (amount &gt;= 0),</span><br><span class="line">    PRIMARY KEY (name,year)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第二，在sales_stats表中插入一些行：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO</span></span><br><span class="line">    sales_stats(name, year, amount)</span><br><span class="line">VALUES</span><br><span class="line">    (<span class="string">'Jaylen Brown'</span>,2018,120000),</span><br><span class="line">    (<span class="string">'Jason Tatum'</span>,2018,110000),</span><br><span class="line">    (<span class="string">'Grant Williams'</span>,2018,150000),</span><br><span class="line">    (<span class="string">'Yao Ming'</span>,2018,30000),</span><br><span class="line">    (<span class="string">'Stephen Marbury'</span>,2018,200000),</span><br><span class="line">    (<span class="string">'Jaylen Brown'</span>,2019,150000),</span><br><span class="line">    (<span class="string">'Jason Tatum'</span>,2019,130000),</span><br><span class="line">    (<span class="string">'Grant Williams'</span>,2019,180000),</span><br><span class="line">    (<span class="string">'Yao Ming'</span>,2019,25000),</span><br><span class="line">    (<span class="string">'Stephen Marbury'</span>,2019,270000);</span><br><span class="line">INSERT 0 10</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用CUME_DIST()函数查询2018年每位销售员工的销售额百分比：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    name,</span><br><span class="line">    year,</span><br><span class="line">    amount,</span><br><span class="line">    CUME_DIST() OVER (</span><br><span class="line">        ORDER BY amount</span><br><span class="line">    )</span><br><span class="line">FROM</span><br><span class="line">    sales_stats</span><br><span class="line">WHERE</span><br><span class="line">    year = 2018;</span><br><span class="line">      name       | year |  amount   | cume_dist</span><br><span class="line">-----------------+------+-----------+-----------</span><br><span class="line"> Yao Ming        | 2018 |  30000.00 |       0.2</span><br><span class="line"> Jason Tatum     | 2018 | 110000.00 |       0.4</span><br><span class="line"> Jaylen Brown    | 2018 | 120000.00 |       0.6</span><br><span class="line"> Grant Williams  | 2018 | 150000.00 |       0.8</span><br><span class="line"> Stephen Marbury | 2018 | 200000.00 |         1</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure>
<ul>
<li>从输出中可以清楚地看到，我们可以发现80％的销售员工在2018年的销售额低于或等于15万。</li>
</ul>
<blockquote>
<p>使用CUME_DIST()函数计算2018年和2019年每位销售员工的销售百分比:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    name,</span><br><span class="line">   year,</span><br><span class="line">   amount,</span><br><span class="line">    CUME_DIST() OVER (</span><br><span class="line">      PARTITION BY year</span><br><span class="line">        ORDER BY amount</span><br><span class="line">    )</span><br><span class="line">FROM</span><br><span class="line">    sales_stats;</span><br><span class="line">      name       | year |  amount   | cume_dist</span><br><span class="line">-----------------+------+-----------+-----------</span><br><span class="line"> Yao Ming        | 2018 |  30000.00 |       0.2</span><br><span class="line"> Jason Tatum     | 2018 | 110000.00 |       0.4</span><br><span class="line"> Jaylen Brown    | 2018 | 120000.00 |       0.6</span><br><span class="line"> Grant Williams  | 2018 | 150000.00 |       0.8</span><br><span class="line"> Stephen Marbury | 2018 | 200000.00 |         1</span><br><span class="line"> Yao Ming        | 2019 |  25000.00 |       0.2</span><br><span class="line"> Jason Tatum     | 2019 | 130000.00 |       0.4</span><br><span class="line"> Jaylen Brown    | 2019 | 150000.00 |       0.6</span><br><span class="line"> Grant Williams  | 2019 | 180000.00 |       0.8</span><br><span class="line"> Stephen Marbury | 2019 | 270000.00 |         1</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>
<ul>
<li>PARTITION BY子句按2018年和2019年将行分为两个分区。</li>
</ul>
<ul>
<li>ORDER BY子句将应用CUME_DIST()函数的每个分区中从高到低的每个员工的销售额排序。</li>
</ul>
<h2 id="NTILE函数"><a href="#NTILE函数" class="headerlink" title="NTILE函数"></a>NTILE函数</h2><h3 id="NTILE-函数语法"><a href="#NTILE-函数语法" class="headerlink" title="NTILE()函数语法"></a>NTILE()函数语法</h3><blockquote>
<p>PostgreSQL NTILE()函数将分区中的有序行划分为指定数量的排名组，并使其大小尽可能相等。这些排名的组称为存储桶。</p>
</blockquote>
<blockquote>
<p>NTILE()函数为每个组分配一个从1开始的存储桶号。对于一个组中的每一行，NTILE()函数分配一个代表该行所属的组的存储桶号。</p>
</blockquote>
<blockquote>
<p>NTILE()函数的语法如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NTILE(buckets) OVER (</span><br><span class="line">    [PARTITION BY partition_expression, ... ]</span><br><span class="line">    [ORDER BY sort_expression [ASC | DESC], ...]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>buckets:<br>桶代表排名组的数量。它可以是数字或表达式，每个分区的计算结果为正整数值（大于0）。存储桶不能为空。</li>
</ul>
<ul>
<li>PARTITION BY子句:<br>PARTITION BY子句将行分布到应用了该功能的分区中。该子句是可选的，如果跳过它，该函数会将整个结果集视为一个分区。</li>
</ul>
<ul>
<li>ORDER BY子句:<br>ORDER BY子句对应用该函数的每个分区中的行进行排序。该是可选的，但是，应该始终使用ORDER BY子句来获得预期的结果。请注意，如果存储桶无法将行数整除，则NTILE()函数将返回两个大小的组，其差为1。较大的组始终按照ORDER BY子句指定的顺序排在较小的组之前。</li>
</ul>
<h3 id="NTILE-函数示例"><a href="#NTILE-函数示例" class="headerlink" title="NTILE()函数示例"></a>NTILE()函数示例</h3><blockquote>
<p>使用在CUME_DIST()函数中创建的sales_stats表来演示NTILE()函数:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   year,</span><br><span class="line">   name,</span><br><span class="line">   amount</span><br><span class="line">FROM</span><br><span class="line">   sales_stats</span><br><span class="line">ORDER BY</span><br><span class="line">   year, name;</span><br><span class="line"> year |      name       |  amount</span><br><span class="line">------+-----------------+-----------</span><br><span class="line"> 2018 | Grant Williams  | 150000.00</span><br><span class="line"> 2018 | Jason Tatum     | 110000.00</span><br><span class="line"> 2018 | Jaylen Brown    | 120000.00</span><br><span class="line"> 2018 | Stephen Marbury | 200000.00</span><br><span class="line"> 2018 | Yao Ming        |  30000.00</span><br><span class="line"> 2019 | Grant Williams  | 180000.00</span><br><span class="line"> 2019 | Jason Tatum     | 130000.00</span><br><span class="line"> 2019 | Jaylen Brown    | 150000.00</span><br><span class="line"> 2019 | Stephen Marbury | 270000.00</span><br><span class="line"> 2019 | Yao Ming        |  25000.00</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用NTILE()函数将行分配到3个存储桶中：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   name,</span><br><span class="line">   amount,</span><br><span class="line">   NTILE(3) OVER(</span><br><span class="line">      ORDER BY amount</span><br><span class="line">   )</span><br><span class="line">FROM</span><br><span class="line">   sales_stats</span><br><span class="line">WHERE</span><br><span class="line">   year = 2019;</span><br><span class="line">      name       |  amount   | ntile</span><br><span class="line">-----------------+-----------+-------</span><br><span class="line"> Yao Ming        |  25000.00 |     1</span><br><span class="line"> Jason Tatum     | 130000.00 |     1</span><br><span class="line"> Jaylen Brown    | 150000.00 |     2</span><br><span class="line"> Grant Williams  | 180000.00 |     2</span><br><span class="line"> Stephen Marbury | 270000.00 |     3</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将sales_stats表中的行分为两个分区，每个分区有3个存储桶：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   year,</span><br><span class="line">   name,</span><br><span class="line">   amount,</span><br><span class="line">   NTILE(3) OVER(</span><br><span class="line">      PARTITION BY year</span><br><span class="line">      ORDER BY amount</span><br><span class="line">   )</span><br><span class="line">FROM</span><br><span class="line">   sales_stats;</span><br><span class="line"> year |      name       |  amount   | ntile</span><br><span class="line">------+-----------------+-----------+-------</span><br><span class="line"> 2018 | Yao Ming        |  30000.00 |     1</span><br><span class="line"> 2018 | Jason Tatum     | 110000.00 |     1</span><br><span class="line"> 2018 | Jaylen Brown    | 120000.00 |     2</span><br><span class="line"> 2018 | Grant Williams  | 150000.00 |     2</span><br><span class="line"> 2018 | Stephen Marbury | 200000.00 |     3</span><br><span class="line"> 2019 | Yao Ming        |  25000.00 |     1</span><br><span class="line"> 2019 | Jason Tatum     | 130000.00 |     1</span><br><span class="line"> 2019 | Jaylen Brown    | 150000.00 |     2</span><br><span class="line"> 2019 | Grant Williams  | 180000.00 |     2</span><br><span class="line"> 2019 | Stephen Marbury | 270000.00 |     3</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>
<h2 id="PERCENT-RANK函数"><a href="#PERCENT-RANK函数" class="headerlink" title="PERCENT_RANK函数"></a>PERCENT_RANK函数</h2><h3 id="PERCENT-RANK-函数语法"><a href="#PERCENT-RANK-函数语法" class="headerlink" title="PERCENT_RANK()函数语法"></a>PERCENT_RANK()函数语法</h3><blockquote>
<p>PERCENT_RANK()函数类似于CUME_DIST()函数。PERCENT_RANK()函数计算一组值中某个值的相对位置。</p>
</blockquote>
<blockquote>
<p>PERCENT_RANK()函数的语法：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PERCENT_RANK() OVER (</span><br><span class="line">    [PARTITION BY partition_expression, ... ]</span><br><span class="line">    ORDER BY sort_expression [ASC | DESC], ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>PARTITION BY子句:<br>PARTITION BY子句将行分成多个分区，并对其应用PERCENT_RANK()函数。该子句是可选的，如果省略它，该函数会将整个结果集视为一个分区。</li>
</ul>
<ul>
<li>ORDER BY子句:<br>ORDER BY子句指定函数在每个分区中的行顺序。</li>
</ul>
<ul>
<li>返回值:<br>PERCENT_RANK()函数返回大于0且小于或等于1的结果:0 &lt; PERCENT_RANK() &lt;= 1。第一个值始终为零。</li>
</ul>
<h3 id="PERCENT-RANK-函数示例"><a href="#PERCENT-RANK-函数示例" class="headerlink" title="PERCENT_RANK()函数示例"></a>PERCENT_RANK()函数示例</h3><blockquote>
<p>使用在CUME_DIST()函数中创建的sales_stats表进行演示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   year,</span><br><span class="line">   name,</span><br><span class="line">   amount</span><br><span class="line">FROM</span><br><span class="line">   sales_stats</span><br><span class="line">ORDER BY</span><br><span class="line">   year, name;</span><br><span class="line"> year |      name       |  amount</span><br><span class="line">------+-----------------+-----------</span><br><span class="line"> 2018 | Grant Williams  | 150000.00</span><br><span class="line"> 2018 | Jason Tatum     | 110000.00</span><br><span class="line"> 2018 | Jaylen Brown    | 120000.00</span><br><span class="line"> 2018 | Stephen Marbury | 200000.00</span><br><span class="line"> 2018 | Yao Ming        |  30000.00</span><br><span class="line"> 2019 | Grant Williams  | 180000.00</span><br><span class="line"> 2019 | Jason Tatum     | 130000.00</span><br><span class="line"> 2019 | Jaylen Brown    | 150000.00</span><br><span class="line"> 2019 | Stephen Marbury | 270000.00</span><br><span class="line"> 2019 | Yao Ming        |  25000.00</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用PERCENT_RANK()函数计算2019年每位员工的销售百分比:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    name,</span><br><span class="line">   amount,</span><br><span class="line">    PERCENT_RANK() OVER (</span><br><span class="line">        ORDER BY amount</span><br><span class="line">    )</span><br><span class="line">FROM</span><br><span class="line">    sales_stats</span><br><span class="line">WHERE</span><br><span class="line">    year = 2019;</span><br><span class="line">      name       |  amount   | percent_rank</span><br><span class="line">-----------------+-----------+--------------</span><br><span class="line"> Yao Ming        |  25000.00 |            0</span><br><span class="line"> Jason Tatum     | 130000.00 |         0.25</span><br><span class="line"> Jaylen Brown    | 150000.00 |          0.5</span><br><span class="line"> Grant Williams  | 180000.00 |         0.75</span><br><span class="line"> Stephen Marbury | 270000.00 |            1</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用PERCENT_RANK()函数计算2018年和2019年销售员工的销售额百分比:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    name,</span><br><span class="line">   amount,</span><br><span class="line">    PERCENT_RANK() OVER (</span><br><span class="line">      PARTITION BY year</span><br><span class="line">        ORDER BY amount</span><br><span class="line">    )</span><br><span class="line">FROM</span><br><span class="line">    sales_stats;</span><br><span class="line">      name       |  amount   | percent_rank</span><br><span class="line">-----------------+-----------+--------------</span><br><span class="line"> Yao Ming        |  30000.00 |            0</span><br><span class="line"> Jason Tatum     | 110000.00 |         0.25</span><br><span class="line"> Jaylen Brown    | 120000.00 |          0.5</span><br><span class="line"> Grant Williams  | 150000.00 |         0.75</span><br><span class="line"> Stephen Marbury | 200000.00 |            1</span><br><span class="line"> Yao Ming        |  25000.00 |            0</span><br><span class="line"> Jason Tatum     | 130000.00 |         0.25</span><br><span class="line"> Jaylen Brown    | 150000.00 |          0.5</span><br><span class="line"> Grant Williams  | 180000.00 |         0.75</span><br><span class="line"> Stephen Marbury | 270000.00 |            1</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>
<ul>
<li>PARTITION BY子句将sales_stats表中的行分配到两个分区中，一个分区用于2018，另一个分区用于2019。</li>
</ul>
<ul>
<li>ORDER BY子句按销售额对每个分区中的行进行排序。</li>
</ul>
<ul>
<li>PERCENT_RANK()函数将应用于每个有序分区，以计算百分比等级。</li>
</ul>
<h2 id="LEAD函数"><a href="#LEAD函数" class="headerlink" title="LEAD函数"></a>LEAD函数</h2><h3 id="LEAD-语法"><a href="#LEAD-语法" class="headerlink" title="LEAD()语法"></a>LEAD()语法</h3><blockquote>
<p>PostgreSQL LEAD()函数提供对以指定物理偏移量访问当前行之后的行的访问。这意味着从当前行开始，LEAD()函数可以访问下一行，下一行之后的行等等的数据。</p>
</blockquote>
<blockquote>
<p>LEAD()函数对于将当前行的值与当前行之后的行的值进行比较非常有用。</p>
</blockquote>
<blockquote>
<p>LEAD()函数的语法：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LEAD(expression [,offset [,default_value]])</span><br><span class="line">OVER (</span><br><span class="line">    [PARTITION BY partition_expression, ... ]</span><br><span class="line">    ORDER BY sort_expression [ASC | DESC], ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>expression:<br>根据与当前行的指定偏移量，针对下一行对表达式求值。表达式可以是必须计算为单个值的列、表达式、子查询，而且它不能是window函数。</li>
</ul>
<ul>
<li>offset:<br>偏移量是一个正整数，它指定从当前行转发访问的行数。偏移量可以是表达式、子查询或列。如果不指定偏移量，则默认为1。</li>
</ul>
<ul>
<li>default_value:<br>如果偏移量超出分区范围，则default_value是返回值。如果省略，则default_value默认为NULL。</li>
</ul>
<ul>
<li>PARTITION BY子句:<br>PARTITION BY子句将行划分为应用了LEAD()函数的分区。默认情况下，如果省略PARTITION BY子句，则整个结果集是单个分区。</li>
</ul>
<ul>
<li>ORDER BY子句:<br>ORDER BY子句指定将LEAD()函数应用到的每个分区中的行的排序顺序。</li>
</ul>
<h3 id="LEAD-函数示例"><a href="#LEAD-函数示例" class="headerlink" title="LEAD()函数示例"></a>LEAD()函数示例</h3><blockquote>
<p>首先，创建一个名为sales的新表:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE sales(</span></span><br><span class="line">   year SMALLINT CHECK(year &gt; 0),</span><br><span class="line">   group_id INT NOT NULL,</span><br><span class="line">   amount DECIMAL(10,2) NOT NULL,</span><br><span class="line">   PRIMARY KEY(year,group_id)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其次，在sales表中插入一些行：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO</span></span><br><span class="line">   sales(year, group_id, amount)</span><br><span class="line">VALUES</span><br><span class="line">   (2018,1,1474),</span><br><span class="line">   (2018,2,1787),</span><br><span class="line">   (2018,3,1760),</span><br><span class="line">   (2019,1,1915),</span><br><span class="line">   (2019,2,1911),</span><br><span class="line">   (2019,3,1118),</span><br><span class="line">   (2020,1,1646),</span><br><span class="line">   (2020,2,1975),</span><br><span class="line">   (2020,3,1516);</span><br><span class="line">INSERT 0 9</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三，从sales表中查询数据：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT * FROM sales;</span></span><br><span class="line"> year | group_id | amount</span><br><span class="line">------+----------+---------</span><br><span class="line"> 2018 |        1 | 1474.00</span><br><span class="line"> 2018 |        2 | 1787.00</span><br><span class="line"> 2018 |        3 | 1760.00</span><br><span class="line"> 2019 |        1 | 1915.00</span><br><span class="line"> 2019 |        2 | 1911.00</span><br><span class="line"> 2019 |        3 | 1118.00</span><br><span class="line"> 2020 |        1 | 1646.00</span><br><span class="line"> 2020 |        2 | 1975.00</span><br><span class="line"> 2020 |        3 | 1516.00</span><br><span class="line">(9 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>按年份返回总销售额:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   year,</span><br><span class="line">   SUM(amount)</span><br><span class="line">FROM sales</span><br><span class="line">GROUP BY year</span><br><span class="line">ORDER BY year;</span><br><span class="line"> year |   sum</span><br><span class="line">------+---------</span><br><span class="line"> 2018 | 5021.00</span><br><span class="line"> 2019 | 4944.00</span><br><span class="line"> 2020 | 5137.00</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用LEAD()函数返回当年和下一年的销售额：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># WITH cte AS (</span></span><br><span class="line">   SELECT</span><br><span class="line">      year,</span><br><span class="line">      SUM(amount) amount</span><br><span class="line">   FROM sales</span><br><span class="line">   GROUP BY year</span><br><span class="line">   ORDER BY year</span><br><span class="line">)</span><br><span class="line">SELECT</span><br><span class="line">   year,</span><br><span class="line">   amount,</span><br><span class="line">   LEAD(amount,1) OVER (</span><br><span class="line">      ORDER BY year</span><br><span class="line">   ) next_year_sales</span><br><span class="line">FROM</span><br><span class="line">   cte;</span><br><span class="line"> year | amount  | next_year_sales</span><br><span class="line">------+---------+-----------------</span><br><span class="line"> 2018 | 5021.00 |         4944.00</span><br><span class="line"> 2019 | 4944.00 |         5137.00</span><br><span class="line"> 2020 | 5137.00 |</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，CTE返回按年汇总的销售额。</li>
</ul>
<ul>
<li>然后，外部查询使用LEAD()函数为每一行返回下一年的销售额。</li>
</ul>
<blockquote>
<p>使用两个常用表表达式返回当年与下一年之间的销售差异：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># WITH cte AS (</span></span><br><span class="line">   SELECT</span><br><span class="line">      year,</span><br><span class="line">      SUM(amount) amount</span><br><span class="line">   FROM sales</span><br><span class="line">   GROUP BY year</span><br><span class="line">   ORDER BY year</span><br><span class="line">), cte2 AS (</span><br><span class="line">   SELECT</span><br><span class="line">      year,</span><br><span class="line">      amount,</span><br><span class="line">      LEAD(amount,1) OVER (</span><br><span class="line">         ORDER BY year</span><br><span class="line">      ) next_year_sales</span><br><span class="line">   FROM</span><br><span class="line">      cte</span><br><span class="line">)   </span><br><span class="line">SELECT</span><br><span class="line">   year,</span><br><span class="line">   amount,</span><br><span class="line">   next_year_sales,  </span><br><span class="line">   (next_year_sales - amount) variance</span><br><span class="line">FROM</span><br><span class="line">   cte2;</span><br><span class="line"> year | amount  | next_year_sales | variance</span><br><span class="line">------+---------+-----------------+----------</span><br><span class="line"> 2018 | 5021.00 |         4944.00 |   -77.00</span><br><span class="line"> 2019 | 4944.00 |         5137.00 |   193.00</span><br><span class="line"> 2020 | 5137.00 |                 |</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用该LEAD()函数将每个产品组的当年销售额与下一年的销售额进行比较：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   year,</span><br><span class="line">   amount,</span><br><span class="line">   group_id,</span><br><span class="line">   LEAD(amount,1) OVER (</span><br><span class="line">      PARTITION BY group_id</span><br><span class="line">      ORDER BY year</span><br><span class="line">   ) next_year_sales</span><br><span class="line">FROM</span><br><span class="line">   sales;</span><br><span class="line"> year | amount  | group_id | next_year_sales</span><br><span class="line">------+---------+----------+-----------------</span><br><span class="line"> 2018 | 1474.00 |        1 |         1915.00</span><br><span class="line"> 2019 | 1915.00 |        1 |         1646.00</span><br><span class="line"> 2020 | 1646.00 |        1 |</span><br><span class="line"> 2018 | 1787.00 |        2 |         1911.00</span><br><span class="line"> 2019 | 1911.00 |        2 |         1975.00</span><br><span class="line"> 2020 | 1975.00 |        2 |</span><br><span class="line"> 2018 | 1760.00 |        3 |         1118.00</span><br><span class="line"> 2019 | 1118.00 |        3 |         1516.00</span><br><span class="line"> 2020 | 1516.00 |        3 |</span><br><span class="line">(9 rows)</span><br></pre></td></tr></table></figure>
<ul>
<li>PARTITION BY子句将行分配到由组ID指定的产品组（或分区）中。</li>
</ul>
<ul>
<li>ORDER BY子句按年份升序对每个产品组中的行进行排序。</li>
</ul>
<ul>
<li>LEAD()函数返回每个产品组从当年的下一年的销售额。</li>
</ul>
<h2 id="LAG函数"><a href="#LAG函数" class="headerlink" title="LAG函数"></a>LAG函数</h2><h3 id="LAG-函数语法"><a href="#LAG-函数语法" class="headerlink" title="LAG()函数语法"></a>LAG()函数语法</h3><blockquote>
<p>PostgreSQL LAG()函数提供对以指定物理偏移量访问当前行之前的行的访问。换句话说，从当前行中，LAG()函数可以访问前一行或前一行之前的行的数据，依此类推。</p>
</blockquote>
<blockquote>
<p>LAG())函数对于比较当前行和上一行的值非常有用。</p>
</blockquote>
<blockquote>
<p>LAG()函数的语法：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LAG(expression [,offset [,default_value]])</span><br><span class="line">OVER (</span><br><span class="line">    [PARTITION BY partition_expression, ... ]</span><br><span class="line">    ORDER BY sort_expression [ASC | DESC], ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>expression:<br>将根据当前行之前指定偏移量的行对表达式求值。它可以是列、表达式或子查询。该表达式必须返回单个值，并且不能是window函数。</li>
</ul>
<ul>
<li>offset:<br>偏移量是一个正整数，它指定要从其访问数据的当前行之前的行数。偏移量可以是表达式，子查询或列。如果未指定，则默认为1。</li>
</ul>
<ul>
<li>default_value:<br>如果偏移量超出分区范围，则LAG()函数将返回default_value。如果省略default_value，该函数将返回NULL。</li>
</ul>
<ul>
<li>PARTITION BY子句:<br>PARTITION BY子句将行划分为应用了LAG()函数的分区。默认情况下，如果省略PARTITION BY子句，该函数会将整个结果集视为一个分区。</li>
</ul>
<ul>
<li>ORDER BY子句:<br>ORDER BY子句指定将LAG()函数应用到的每个分区中的行顺序。</li>
</ul>
<h3 id="LAG-函数示例"><a href="#LAG-函数示例" class="headerlink" title="LAG()函数示例"></a>LAG()函数示例</h3><blockquote>
<p>使用LEAD()函数中创建的sales表进行演示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT * FROM sales;</span></span><br><span class="line"> year | group_id | amount</span><br><span class="line">------+----------+---------</span><br><span class="line"> 2018 |        1 | 1474.00</span><br><span class="line"> 2018 |        2 | 1787.00</span><br><span class="line"> 2018 |        3 | 1760.00</span><br><span class="line"> 2019 |        1 | 1915.00</span><br><span class="line"> 2019 |        2 | 1911.00</span><br><span class="line"> 2019 |        3 | 1118.00</span><br><span class="line"> 2020 |        1 | 1646.00</span><br><span class="line"> 2020 |        2 | 1975.00</span><br><span class="line"> 2020 |        3 | 1516.00</span><br><span class="line">(9 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用LAG()函数返回当年和上一年的销售额：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># WITH cte AS (</span></span><br><span class="line">   SELECT</span><br><span class="line">      year,</span><br><span class="line">      SUM(amount) amount</span><br><span class="line">   FROM sales</span><br><span class="line">   GROUP BY year</span><br><span class="line">   ORDER BY year</span><br><span class="line">)</span><br><span class="line">SELECT</span><br><span class="line">   year,</span><br><span class="line">   amount,</span><br><span class="line">   LAG(amount,1) OVER (</span><br><span class="line">      ORDER BY year</span><br><span class="line">   ) previous_year_sales</span><br><span class="line">FROM</span><br><span class="line">   cte;</span><br><span class="line"> year | amount  | previous_year_sales</span><br><span class="line">------+---------+---------------------</span><br><span class="line"> 2018 | 5021.00 |</span><br><span class="line"> 2019 | 4944.00 |             5021.00</span><br><span class="line"> 2020 | 5137.00 |             4944.00</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，CTE返回按年汇总的净销售额。</li>
</ul>
<ul>
<li>然后，外部查询使用LAG()函数返回每一行上一年的销售额。第一行在previous_year_sales列中为NULL，因为第一行没有上一年。</li>
</ul>
<blockquote>
<p>使用两个常用表表达式来返回当年与往年之间的销售差异：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># WITH cte AS (</span></span><br><span class="line">   SELECT</span><br><span class="line">      year,</span><br><span class="line">      SUM(amount) amount</span><br><span class="line">   FROM sales</span><br><span class="line">   GROUP BY year</span><br><span class="line">   ORDER BY year</span><br><span class="line">), cte2 AS (</span><br><span class="line">   SELECT</span><br><span class="line">      year,</span><br><span class="line">      amount,</span><br><span class="line">      LAG(amount,1) OVER (</span><br><span class="line">         ORDER BY year</span><br><span class="line">      ) previous_year_sales</span><br><span class="line">   FROM</span><br><span class="line">      cte</span><br><span class="line">)   </span><br><span class="line">SELECT</span><br><span class="line">   year,</span><br><span class="line">   amount,</span><br><span class="line">   previous_year_sales,  </span><br><span class="line">   (previous_year_sales - amount) variance</span><br><span class="line">FROM</span><br><span class="line">   cte2;</span><br><span class="line"> year | amount  | previous_year_sales | variance</span><br><span class="line">------+---------+---------------------+----------</span><br><span class="line"> 2018 | 5021.00 |                     |</span><br><span class="line"> 2019 | 4944.00 |             5021.00 |    77.00</span><br><span class="line"> 2020 | 5137.00 |             4944.00 |  -193.00</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用LAG()函数将每个产品组的当年销售额与上一年的销售额进行比较：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   year,</span><br><span class="line">   amount,</span><br><span class="line">   group_id,</span><br><span class="line">   LAG(amount,1) OVER (</span><br><span class="line">      PARTITION BY group_id</span><br><span class="line">      ORDER BY year</span><br><span class="line">   ) previous_year_sales</span><br><span class="line">FROM</span><br><span class="line">   sales;</span><br><span class="line"> year | amount  | group_id | previous_year_sales</span><br><span class="line">------+---------+----------+---------------------</span><br><span class="line"> 2018 | 1474.00 |        1 |</span><br><span class="line"> 2019 | 1915.00 |        1 |             1474.00</span><br><span class="line"> 2020 | 1646.00 |        1 |             1915.00</span><br><span class="line"> 2018 | 1787.00 |        2 |</span><br><span class="line"> 2019 | 1911.00 |        2 |             1787.00</span><br><span class="line"> 2020 | 1975.00 |        2 |             1911.00</span><br><span class="line"> 2018 | 1760.00 |        3 |</span><br><span class="line"> 2019 | 1118.00 |        3 |             1760.00</span><br><span class="line"> 2020 | 1516.00 |        3 |             1118.00</span><br><span class="line">(9 rows)</span><br></pre></td></tr></table></figure>
<ul>
<li>PARTITION BY子句将行分配到由组ID指定的产品组（或分区）中。</li>
</ul>
<ul>
<li>ORDER BY子句按年份升序对每个产品组中的行进行排序。</li>
</ul>
<ul>
<li>LAG()功能将应用于每个分区以返回上一年的销售额。</li>
</ul>
<h2 id="Window函数"><a href="#Window函数" class="headerlink" title="Window函数"></a>Window函数</h2><h3 id="创建示例表"><a href="#创建示例表" class="headerlink" title="创建示例表"></a>创建示例表</h3><blockquote>
<p>首先，为演示创建两个名为products和product_groups的表：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE product_groups (</span></span><br><span class="line">   group_id serial PRIMARY KEY,</span><br><span class="line">   group_name VARCHAR (255) NOT NULL</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">CREATE TABLE products (</span><br><span class="line">   product_id serial PRIMARY KEY,</span><br><span class="line">   product_name VARCHAR (255) NOT NULL,</span><br><span class="line">   price DECIMAL (11, 2),</span><br><span class="line">   group_id INT NOT NULL,</span><br><span class="line">   FOREIGN KEY (group_id) REFERENCES product_groups (group_id)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其次，在这些表中插入一些行：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO product_groups (group_name)</span></span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'Smartphone'</span>),</span><br><span class="line">   (<span class="string">'Laptop'</span>),</span><br><span class="line">   (<span class="string">'Tablet'</span>);</span><br><span class="line"> </span><br><span class="line">INSERT INTO products (product_name, group_id,price)</span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'Microsoft Lumia'</span>, 1, 200),</span><br><span class="line">   (<span class="string">'HTC One'</span>, 1, 400),</span><br><span class="line">   (<span class="string">'Nexus'</span>, 1, 500),</span><br><span class="line">   (<span class="string">'iPhone'</span>, 1, 900),</span><br><span class="line">   (<span class="string">'HP Elite'</span>, 2, 1200),</span><br><span class="line">   (<span class="string">'Lenovo Thinkpad'</span>, 2, 700),</span><br><span class="line">   (<span class="string">'Sony VAIO'</span>, 2, 700),</span><br><span class="line">   (<span class="string">'Dell Vostro'</span>, 2, 800),</span><br><span class="line">   (<span class="string">'iPad'</span>, 3, 700),</span><br><span class="line">   (<span class="string">'Kindle Fire'</span>, 3, 150),</span><br><span class="line">   (<span class="string">'Samsung Galaxy Tab'</span>, 3, 200);</span><br><span class="line">INSERT 0 3</span><br><span class="line"></span><br><span class="line">INSERT 0 11</span><br></pre></td></tr></table></figure>
<h3 id="Window函数简介"><a href="#Window函数简介" class="headerlink" title="Window函数简介"></a>Window函数简介</h3><blockquote>
<p>理解窗口函数的最简单方法是从查看聚合函数开始。聚合函数将数据从一组行聚合到一行。</p>
</blockquote>
<blockquote>
<p>使用AVG()聚合函数来计算products表中所有产品的平均价格:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   AVG (price)</span><br><span class="line">FROM</span><br><span class="line">   products;</span><br><span class="line">         avg</span><br><span class="line">----------------------</span><br><span class="line"> 586.3636363636363636</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要将聚合函数应用于行的子集，请使用该GROUP BY子句。以下示例返回每个产品组的平均价格:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   group_name,</span><br><span class="line">   AVG (price)</span><br><span class="line">FROM</span><br><span class="line">   products</span><br><span class="line">INNER JOIN product_groups USING (group_id)</span><br><span class="line">GROUP BY</span><br><span class="line">   group_name;</span><br><span class="line"> group_name |         avg</span><br><span class="line">------------+----------------------</span><br><span class="line"> Smartphone | 500.0000000000000000</span><br><span class="line"> Tablet     | 350.0000000000000000</span><br><span class="line"> Laptop     | 850.0000000000000000</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从输出中可以清楚地看到，在两个示例中，AVG()函数都减少了查询返回的行数。类似于聚合函数，窗口函数对一组行进行操作。但是，它不会减少查询返回的行数。窗口函数从窗口中的行返回值。</p>
</blockquote>
<blockquote>
<p>例如，以下查询返回产品名称、价格、产品组名称以及每个产品组的平均价格:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   product_name,</span><br><span class="line">   price,</span><br><span class="line">   group_name,</span><br><span class="line">   AVG (price) OVER (</span><br><span class="line">      PARTITION BY group_name</span><br><span class="line">   )</span><br><span class="line">FROM</span><br><span class="line">   products</span><br><span class="line">   INNER JOIN</span><br><span class="line">      product_groups USING (group_id);</span><br><span class="line">    product_name    |  price  | group_name |         avg</span><br><span class="line">--------------------+---------+------------+----------------------</span><br><span class="line"> HP Elite           | 1200.00 | Laptop     | 850.0000000000000000</span><br><span class="line"> Lenovo Thinkpad    |  700.00 | Laptop     | 850.0000000000000000</span><br><span class="line"> Sony VAIO          |  700.00 | Laptop     | 850.0000000000000000</span><br><span class="line"> Dell Vostro        |  800.00 | Laptop     | 850.0000000000000000</span><br><span class="line"> Microsoft Lumia    |  200.00 | Smartphone | 500.0000000000000000</span><br><span class="line"> HTC One            |  400.00 | Smartphone | 500.0000000000000000</span><br><span class="line"> Nexus              |  500.00 | Smartphone | 500.0000000000000000</span><br><span class="line"> iPhone             |  900.00 | Smartphone | 500.0000000000000000</span><br><span class="line"> iPad               |  700.00 | Tablet     | 350.0000000000000000</span><br><span class="line"> Kindle Fire        |  150.00 | Tablet     | 350.0000000000000000</span><br><span class="line"> Samsung Galaxy Tab |  200.00 | Tablet     | 350.0000000000000000</span><br><span class="line">(11 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此查询中，该AVG()函数用作窗口函数，对OVER子句指定的一组行进行操作。每行集称为一个窗口。</p>
</blockquote>
<blockquote>
<p>此查询的新语法是以下OVER子句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVG(price) OVER (PARTITION BY group_name)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用这种语法，将PARTITION BY结果集的行分布到组中，并将AVG()函数应用于每个组以返回每个组的平均价格。</p>
</blockquote>
<blockquote>
<p>请注意，窗口函数始终对计算顺序中JOIN、WHERE、GROUP BY和HAVING子句之后以及最终ORDER BY子句之前的结果集执行计算。</p>
</blockquote>
<h3 id="窗口函数语法"><a href="#窗口函数语法" class="headerlink" title="窗口函数语法"></a>窗口函数语法</h3><blockquote>
<p>PostgreSQL对于窗口函数调用具有复杂的语法。下面说明了简化版本：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window_function(arg1, arg2,..) OVER (</span><br><span class="line">   [PARTITION BY partition_expression]</span><br><span class="line">   [ORDER BY sort_expression [ASC | DESC] [NULLS &#123;FIRST | LAST &#125;]</span><br><span class="line">   [frame_clause] )</span><br></pre></td></tr></table></figure>
<ul>
<li>window_function(arg1,arg2,…):<br>window_function是窗口函数的名称。某些窗口函数不接受任何参数。</li>
</ul>
<ul>
<li>PARTITION BY子句:<br>PARTITION BY子句将行划分为应用窗口函数的多个组或分区。 </li>
</ul>
<ul>
<li>ORDER BY子句:<br>ORDER BY子句指定要应用窗口函数的每个分区中的行顺序。其使用NULLS FIRST或NULLS LAST选项来指定可空值应在结果集中位于第一个还是最后一个。默认值为NULLS LAST选项。</li>
</ul>
<ul>
<li>frame_clause：<br>frame_clause定义了当前分区中应用了窗口函数的行的子集。行的此子集称为框架。</li>
</ul>
<blockquote>
<p>如果在查询中使用多个窗口函数：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    wf1() OVER(PARTITION BY c1 ORDER BY c2),</span><br><span class="line">    wf2() OVER(PARTITION BY c1 ORDER BY c2)</span><br><span class="line">FROM table_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以使用WINDOW子句来缩短查询，如以下查询所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">   wf1() OVER w,</span><br><span class="line">   wf2() OVER w,</span><br><span class="line">FROM table_name</span><br><span class="line">WINDOW w AS (PARTITION BY c1 ORDER BY c2);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>即使您在查询中调用一个窗口函数，也可以使用WINDOW子句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT wf1() OVER w</span><br><span class="line">FROM table_name</span><br><span class="line">WINDOW w AS (PARTITION BY c1 ORDER BY c2);</span><br></pre></td></tr></table></figure>
<h3 id="PostgreSQL窗口函数列表"><a href="#PostgreSQL窗口函数列表" class="headerlink" title="PostgreSQL窗口函数列表"></a>PostgreSQL窗口函数列表</h3><blockquote>
<p>请注意，某些聚合函数（例如AVG()、MIN()、MAX()、SUM()和COUNT()）也可以用作窗口函数。</p>
</blockquote>
<pre><code>名称    |      描述
</code></pre><p>————|—————-<br>CUME_DIST    |返回当前行的相对排名。<br>DENSE_RANK    |将当前行在其分区内无间隙地排列。<br>FIRST_VALUE    |返回针对其分区中第一行评估的值。<br>LAG            |返回在分区中当前行之前指定物理偏移行的行中求值的值。<br>LAST_VALUE    |返回针对其分区中最后一行评估的值。<br>LEAD        |返回在分区中当前行之后偏移行的行中求值的值。<br>NTILE        |尽可能均匀地划分分区中的行，并为每行分配一个从1开始到参数值的整数。<br>NTH_VALUE    |返回对有序分区中的第n行求值的值。<br>PERCENT_RANK|返回当前行的相对排名（rank-1）/（总行– 1）<br>RANK        |用空格对当前行进行分区。<br>ROW_NUMBER    |从1开始对其分区中的当前行编号。</p>
<h3 id="ROW-NUMBER-、RANK-和DENSE-RANK-函数"><a href="#ROW-NUMBER-、RANK-和DENSE-RANK-函数" class="headerlink" title="ROW_NUMBER()、RANK()和DENSE_RANK()函数"></a>ROW_NUMBER()、RANK()和DENSE_RANK()函数</h3><blockquote>
<p>ROW_NUMBER()、RANK()和DENSE_RANK()函数根据其在结果集中的顺序为每行分配一个整数。</p>
</blockquote>
<blockquote>
<p>ROW_NUMBER()函数为每个分区中的每一行分配一个顺序号。请参阅以下查询：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   product_name,</span><br><span class="line">   group_name,</span><br><span class="line">   price,</span><br><span class="line">   ROW_NUMBER () OVER (</span><br><span class="line">      PARTITION BY group_name</span><br><span class="line">      ORDER BY</span><br><span class="line">         price</span><br><span class="line">   )</span><br><span class="line">FROM</span><br><span class="line">   products</span><br><span class="line">INNER JOIN product_groups USING (group_id);</span><br><span class="line">    product_name    | group_name |  price  | row_number</span><br><span class="line">--------------------+------------+---------+------------</span><br><span class="line"> Sony VAIO          | Laptop     |  700.00 |          1</span><br><span class="line"> Lenovo Thinkpad    | Laptop     |  700.00 |          2</span><br><span class="line"> Dell Vostro        | Laptop     |  800.00 |          3</span><br><span class="line"> HP Elite           | Laptop     | 1200.00 |          4</span><br><span class="line"> Microsoft Lumia    | Smartphone |  200.00 |          1</span><br><span class="line"> HTC One            | Smartphone |  400.00 |          2</span><br><span class="line"> Nexus              | Smartphone |  500.00 |          3</span><br><span class="line"> iPhone             | Smartphone |  900.00 |          4</span><br><span class="line"> Kindle Fire        | Tablet     |  150.00 |          1</span><br><span class="line"> Samsung Galaxy Tab | Tablet     |  200.00 |          2</span><br><span class="line"> iPad               | Tablet     |  700.00 |          3</span><br><span class="line">(11 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>RANK()函数在有序分区中分配排名。如果行具有相同的值，则RANK()函数将分配相同的排名，而跳过下一个排名。请参阅以下查询：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   product_name,</span><br><span class="line">   group_name,</span><br><span class="line">  price,</span><br><span class="line">   RANK () OVER (</span><br><span class="line">      PARTITION BY group_name</span><br><span class="line">      ORDER BY</span><br><span class="line">         price</span><br><span class="line">   )</span><br><span class="line">FROM</span><br><span class="line">   products</span><br><span class="line">INNER JOIN product_groups USING (group_id);</span><br><span class="line">    product_name    | group_name |  price  | rank</span><br><span class="line">--------------------+------------+---------+------</span><br><span class="line"> Sony VAIO          | Laptop     |  700.00 |    1</span><br><span class="line"> Lenovo Thinkpad    | Laptop     |  700.00 |    1</span><br><span class="line"> Dell Vostro        | Laptop     |  800.00 |    3</span><br><span class="line"> HP Elite           | Laptop     | 1200.00 |    4</span><br><span class="line"> Microsoft Lumia    | Smartphone |  200.00 |    1</span><br><span class="line"> HTC One            | Smartphone |  400.00 |    2</span><br><span class="line"> Nexus              | Smartphone |  500.00 |    3</span><br><span class="line"> iPhone             | Smartphone |  900.00 |    4</span><br><span class="line"> Kindle Fire        | Tablet     |  150.00 |    1</span><br><span class="line"> Samsung Galaxy Tab | Tablet     |  200.00 |    2</span><br><span class="line"> iPad               | Tablet     |  700.00 |    3</span><br><span class="line">(11 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在笔记本电脑产品组中，Dell Vostro和Sony VAIO产品具有相同的价格，因此，它们获得相同的等级1。该组中的下一行是HP Elite，由于跳过了等级2而获得了等级3。</p>
</blockquote>
<blockquote>
<p>与RANK())函数类似，DENSE_RANK()函数为有序分区中的每一行分配一个等级，但是等级之间没有间隙。换句话说，将相同的等级分配给多行，并且不会跳过任何等级。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   product_name,</span><br><span class="line">   group_name,</span><br><span class="line">   price,</span><br><span class="line">   DENSE_RANK () OVER (</span><br><span class="line">      PARTITION BY group_name</span><br><span class="line">      ORDER BY</span><br><span class="line">         price</span><br><span class="line">   )</span><br><span class="line">FROM</span><br><span class="line">   products</span><br><span class="line">INNER JOIN product_groups USING (group_id);</span><br><span class="line">    product_name    | group_name |  price  | dense_rank</span><br><span class="line">--------------------+------------+---------+------------</span><br><span class="line"> Sony VAIO          | Laptop     |  700.00 |          1</span><br><span class="line"> Lenovo Thinkpad    | Laptop     |  700.00 |          1</span><br><span class="line"> Dell Vostro        | Laptop     |  800.00 |          2</span><br><span class="line"> HP Elite           | Laptop     | 1200.00 |          3</span><br><span class="line"> Microsoft Lumia    | Smartphone |  200.00 |          1</span><br><span class="line"> HTC One            | Smartphone |  400.00 |          2</span><br><span class="line"> Nexus              | Smartphone |  500.00 |          3</span><br><span class="line"> iPhone             | Smartphone |  900.00 |          4</span><br><span class="line"> Kindle Fire        | Tablet     |  150.00 |          1</span><br><span class="line"> Samsung Galaxy Tab | Tablet     |  200.00 |          2</span><br><span class="line"> iPad               | Tablet     |  700.00 |          3</span><br><span class="line">(11 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在笔记本电脑产品组中，排名第一的产品两次分配给Dell Vostro和Sony VAIO。下一个等级是分配给HP Elite的2。</p>
</blockquote>
<h3 id="FIRST-VALUE和LAST-VALUE函数"><a href="#FIRST-VALUE和LAST-VALUE函数" class="headerlink" title="FIRST_VALUE和LAST_VALUE函数"></a>FIRST_VALUE和LAST_VALUE函数</h3><blockquote>
<p>FIRST_VALUE()函数返回针对其分区中第一行评估的值，而LAST_VALUE()函数返回针对其分区中最后一行评估的值。</p>
</blockquote>
<blockquote>
<p>以下语句使用FIRST_VALUE()返回每个产品组的最低价格：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   product_name,</span><br><span class="line">   group_name,</span><br><span class="line">   price,</span><br><span class="line">   FIRST_VALUE (price) OVER (</span><br><span class="line">      PARTITION BY group_name</span><br><span class="line">      ORDER BY</span><br><span class="line">         price</span><br><span class="line">   ) AS lowest_price_per_group</span><br><span class="line">FROM</span><br><span class="line">   products</span><br><span class="line">INNER JOIN product_groups USING (group_id);</span><br><span class="line">    product_name    | group_name |  price  | lowest_price_per_group</span><br><span class="line">--------------------+------------+---------+------------------------</span><br><span class="line"> Sony VAIO          | Laptop     |  700.00 |                 700.00</span><br><span class="line"> Lenovo Thinkpad    | Laptop     |  700.00 |                 700.00</span><br><span class="line"> Dell Vostro        | Laptop     |  800.00 |                 700.00</span><br><span class="line"> HP Elite           | Laptop     | 1200.00 |                 700.00</span><br><span class="line"> Microsoft Lumia    | Smartphone |  200.00 |                 200.00</span><br><span class="line"> HTC One            | Smartphone |  400.00 |                 200.00</span><br><span class="line"> Nexus              | Smartphone |  500.00 |                 200.00</span><br><span class="line"> iPhone             | Smartphone |  900.00 |                 200.00</span><br><span class="line"> Kindle Fire        | Tablet     |  150.00 |                 150.00</span><br><span class="line"> Samsung Galaxy Tab | Tablet     |  200.00 |                 150.00</span><br><span class="line"> iPad               | Tablet     |  700.00 |                 150.00</span><br><span class="line">(11 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下语句使用LAST_VALUE()函数返回每个产品组的最高价格:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   product_name,</span><br><span class="line">   group_name,</span><br><span class="line">   price,</span><br><span class="line">   LAST_VALUE (price) OVER (</span><br><span class="line">      PARTITION BY group_name</span><br><span class="line">      ORDER BY</span><br><span class="line">         price RANGE BETWEEN UNBOUNDED PRECEDING</span><br><span class="line">      AND UNBOUNDED FOLLOWING</span><br><span class="line">   ) AS highest_price_per_group</span><br><span class="line">FROM</span><br><span class="line">   products</span><br><span class="line">INNER JOIN product_groups USING (group_id);</span><br><span class="line">    product_name    | group_name |  price  | highest_price_per_group</span><br><span class="line">--------------------+------------+---------+-------------------------</span><br><span class="line"> Sony VAIO          | Laptop     |  700.00 |                 1200.00</span><br><span class="line"> Lenovo Thinkpad    | Laptop     |  700.00 |                 1200.00</span><br><span class="line"> Dell Vostro        | Laptop     |  800.00 |                 1200.00</span><br><span class="line"> HP Elite           | Laptop     | 1200.00 |                 1200.00</span><br><span class="line"> Microsoft Lumia    | Smartphone |  200.00 |                  900.00</span><br><span class="line"> HTC One            | Smartphone |  400.00 |                  900.00</span><br><span class="line"> Nexus              | Smartphone |  500.00 |                  900.00</span><br><span class="line"> iPhone             | Smartphone |  900.00 |                  900.00</span><br><span class="line"> Kindle Fire        | Tablet     |  150.00 |                  700.00</span><br><span class="line"> Samsung Galaxy Tab | Tablet     |  200.00 |                  700.00</span><br><span class="line"> iPad               | Tablet     |  700.00 |                  700.00</span><br><span class="line">(11 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，我们添加了frame子句RANGE BETWUNDEEN UNBOUNDED PRECEDING和UNBOUNDED FOLLOWING，因为默认情况下frame子句是RANGE BETWEENEEN UNBOUNDED PRECEDING和CURRENT ROW。</p>
</blockquote>
<h3 id="LAG和LEAD功能"><a href="#LAG和LEAD功能" class="headerlink" title="LAG和LEAD功能"></a>LAG和LEAD功能</h3><blockquote>
<p>LAG()函数可以访问上一行的数据，而LEAD()函数可以访问下一行的数据。</p>
</blockquote>
<blockquote>
<p>LAG())和LEAD()函数的语法如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AG  (expression [,offset] [,default]) over_clause;</span><br><span class="line">LEAD (expression [,offset] [,default]) over_clause;</span><br></pre></td></tr></table></figure>
<ul>
<li>expression - 用于计算返回值的列或表达式。</li>
</ul>
<ul>
<li>offset – 当前行之前（LAG）/之后（LEAD）的行数。默认为1。</li>
</ul>
<ul>
<li>默认值 – 如果偏移量超出窗口范围，则返回默认值。如果跳过它，则默认值为NULL。</li>
</ul>
<blockquote>
<p>以下语句使用LAG()函数返回上一行的价格，并计算当前行和上一行的价格之间的差:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   product_name,</span><br><span class="line">   group_name,</span><br><span class="line">   price,</span><br><span class="line">   LAG (price, 1) OVER (</span><br><span class="line">      PARTITION BY group_name</span><br><span class="line">      ORDER BY</span><br><span class="line">         price</span><br><span class="line">   ) AS prev_price,</span><br><span class="line">   price - LAG (price, 1) OVER (</span><br><span class="line">      PARTITION BY group_name</span><br><span class="line">      ORDER BY</span><br><span class="line">         price</span><br><span class="line">   ) AS cur_prev_diff</span><br><span class="line">FROM</span><br><span class="line">   products</span><br><span class="line">INNER JOIN product_groups USING (group_id);</span><br><span class="line">    product_name    | group_name |  price  | prev_price | cur_prev_diff</span><br><span class="line">--------------------+------------+---------+------------+---------------</span><br><span class="line"> Sony VAIO          | Laptop     |  700.00 |            |</span><br><span class="line"> Lenovo Thinkpad    | Laptop     |  700.00 |     700.00 |          0.00</span><br><span class="line"> Dell Vostro        | Laptop     |  800.00 |     700.00 |        100.00</span><br><span class="line"> HP Elite           | Laptop     | 1200.00 |     800.00 |        400.00</span><br><span class="line"> Microsoft Lumia    | Smartphone |  200.00 |            |</span><br><span class="line"> HTC One            | Smartphone |  400.00 |     200.00 |        200.00</span><br><span class="line"> Nexus              | Smartphone |  500.00 |     400.00 |        100.00</span><br><span class="line"> iPhone             | Smartphone |  900.00 |     500.00 |        400.00</span><br><span class="line"> Kindle Fire        | Tablet     |  150.00 |            |</span><br><span class="line"> Samsung Galaxy Tab | Tablet     |  200.00 |     150.00 |         50.00</span><br><span class="line"> iPad               | Tablet     |  700.00 |     200.00 |        500.00</span><br><span class="line">(11 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下语句使用LEAD()函数从下一行返回价格，并计算当前行和下一行的价格之间的差:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   product_name,</span><br><span class="line">   group_name,</span><br><span class="line">   price,</span><br><span class="line">   LEAD (price, 1) OVER (</span><br><span class="line">      PARTITION BY group_name</span><br><span class="line">      ORDER BY</span><br><span class="line">         price</span><br><span class="line">   ) AS next_price,</span><br><span class="line">   price - LEAD (price, 1) OVER (</span><br><span class="line">      PARTITION BY group_name</span><br><span class="line">      ORDER BY</span><br><span class="line">         price</span><br><span class="line">   ) AS cur_next_diff</span><br><span class="line">FROM</span><br><span class="line">   products</span><br><span class="line">INNER JOIN product_groups USING (group_id);</span><br><span class="line">    product_name    | group_name |  price  | next_price | cur_next_diff</span><br><span class="line">--------------------+------------+---------+------------+---------------</span><br><span class="line"> Sony VAIO          | Laptop     |  700.00 |     700.00 |          0.00</span><br><span class="line"> Lenovo Thinkpad    | Laptop     |  700.00 |     800.00 |       -100.00</span><br><span class="line"> Dell Vostro        | Laptop     |  800.00 |    1200.00 |       -400.00</span><br><span class="line"> HP Elite           | Laptop     | 1200.00 |            |</span><br><span class="line"> Microsoft Lumia    | Smartphone |  200.00 |     400.00 |       -200.00</span><br><span class="line"> HTC One            | Smartphone |  400.00 |     500.00 |       -100.00</span><br><span class="line"> Nexus              | Smartphone |  500.00 |     900.00 |       -400.00</span><br><span class="line"> iPhone             | Smartphone |  900.00 |            |</span><br><span class="line"> Kindle Fire        | Tablet     |  150.00 |     200.00 |        -50.00</span><br><span class="line"> Samsung Galaxy Tab | Tablet     |  200.00 |     700.00 |       -500.00</span><br><span class="line"> iPad               | Tablet     |  700.00 |            |</span><br><span class="line">(11 rows)</span><br></pre></td></tr></table></figure>
<h2 id="NTH-VALUE函数"><a href="#NTH-VALUE函数" class="headerlink" title="NTH_VALUE函数"></a>NTH_VALUE函数</h2><h3 id="NTH-VALUE-函数语法"><a href="#NTH-VALUE-函数语法" class="headerlink" title="NTH_VALUE()函数语法"></a>NTH_VALUE()函数语法</h3><blockquote>
<p>NTH_VALUE()函数从结果集的有序分区中的第n行返回一个值。</p>
</blockquote>
<blockquote>
<p>NTH_VALUE()函数的语法：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTH_VALUE(expression, offset)</span><br><span class="line">OVER (</span><br><span class="line">    [PARTITION BY partition_expression]</span><br><span class="line">    [ ORDER BY sort_expression [ASC | DESC]</span><br><span class="line">    frame_clause ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>expression:<br>该表达式是NTH_VALUE()函数在其上运行的目标列或表达式。</li>
</ul>
<ul>
<li>offset:<br>偏移量是一个正整数（大于0），该整数确定相对于表达式要计算的窗口中第一行的行号。</li>
</ul>
<ul>
<li>PARTITION BY partition_expression:<br>PARTITION BY子句将结果集的行分布到NTH_VALUE()函数适用的分区中。</li>
</ul>
<ul>
<li>ORDER BY sort_expression:<br>ORDER BY子句对应用该函数的每个分区中的行进行排序。</li>
</ul>
<ul>
<li>frame clause:<br>frame_clause定义当前分区的子集（或帧）。</li>
</ul>
<h3 id="NTH-VALUE-函数示例"><a href="#NTH-VALUE-函数示例" class="headerlink" title="NTH_VALUE()函数示例"></a>NTH_VALUE()函数示例</h3><blockquote>
<p>使用在window函数中创建的products表进行演示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># select * from products;</span></span><br><span class="line"> product_id |    product_name    |  price  | group_id</span><br><span class="line">------------+--------------------+---------+----------</span><br><span class="line">          1 | Microsoft Lumia    |  200.00 |        1</span><br><span class="line">          2 | HTC One            |  400.00 |        1</span><br><span class="line">          3 | Nexus              |  500.00 |        1</span><br><span class="line">          4 | iPhone             |  900.00 |        1</span><br><span class="line">          5 | HP Elite           | 1200.00 |        2</span><br><span class="line">          6 | Lenovo Thinkpad    |  700.00 |        2</span><br><span class="line">          7 | Sony VAIO          |  700.00 |        2</span><br><span class="line">          8 | Dell Vostro        |  800.00 |        2</span><br><span class="line">          9 | iPad               |  700.00 |        3</span><br><span class="line">         10 | Kindle Fire        |  150.00 |        3</span><br><span class="line">         11 | Samsung Galaxy Tab |  200.00 |        3</span><br><span class="line">(11 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用NTH_VALUE()函数返回所有产品以及最昂贵的产品:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    product_id,</span><br><span class="line">    product_name,</span><br><span class="line">    price,</span><br><span class="line">    NTH_VALUE(product_name, 2)</span><br><span class="line">    OVER(</span><br><span class="line">        ORDER BY price DESC</span><br><span class="line">        RANGE BETWEEN</span><br><span class="line">            UNBOUNDED PRECEDING AND</span><br><span class="line">            UNBOUNDED FOLLOWING</span><br><span class="line">    )</span><br><span class="line">FROM</span><br><span class="line">    products;</span><br><span class="line"> product_id |    product_name    |  price  | nth_value</span><br><span class="line">------------+--------------------+---------+-----------</span><br><span class="line">          5 | HP Elite           | 1200.00 | iPhone</span><br><span class="line">          4 | iPhone             |  900.00 | iPhone</span><br><span class="line">          8 | Dell Vostro        |  800.00 | iPhone</span><br><span class="line">          6 | Lenovo Thinkpad    |  700.00 | iPhone</span><br><span class="line">          7 | Sony VAIO          |  700.00 | iPhone</span><br><span class="line">          9 | iPad               |  700.00 | iPhone</span><br><span class="line">          3 | Nexus              |  500.00 | iPhone</span><br><span class="line">          2 | HTC One            |  400.00 | iPhone</span><br><span class="line">         11 | Samsung Galaxy Tab |  200.00 | iPhone</span><br><span class="line">          1 | Microsoft Lumia    |  200.00 | iPhone</span><br><span class="line">         10 | Kindle Fire        |  150.00 | iPhone</span><br><span class="line">(11 rows)</span><br></pre></td></tr></table></figure>
<ul>
<li>ORDER BY子句按价格从高到低对所有产品进行排序</li>
</ul>
<ul>
<li>frame子句定义了从结果集的开始行开始到结束行结束的帧。</li>
</ul>
<ul>
<li>排序和构建后，NTH_VALUE()函数在结果集第二行的product_name列中返回值。</li>
</ul>
<blockquote>
<p>使用NTH_VALUE()函数返回每个产品组中价格第二高的产品:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    product_id,</span><br><span class="line">    product_name,</span><br><span class="line">    price,</span><br><span class="line">    group_id,</span><br><span class="line">    NTH_VALUE(product_name, 2)</span><br><span class="line">    OVER(</span><br><span class="line">        PARTITION BY group_id</span><br><span class="line">        ORDER BY price DESC</span><br><span class="line">        RANGE BETWEEN</span><br><span class="line">            UNBOUNDED PRECEDING AND</span><br><span class="line">            UNBOUNDED FOLLOWING</span><br><span class="line">    )</span><br><span class="line">FROM</span><br><span class="line">    products;</span><br><span class="line"> product_id |    product_name    |  price  | group_id |     nth_value</span><br><span class="line">------------+--------------------+---------+----------+--------------------</span><br><span class="line">          4 | iPhone             |  900.00 |        1 | Nexus</span><br><span class="line">          3 | Nexus              |  500.00 |        1 | Nexus</span><br><span class="line">          2 | HTC One            |  400.00 |        1 | Nexus</span><br><span class="line">          1 | Microsoft Lumia    |  200.00 |        1 | Nexus</span><br><span class="line">          5 | HP Elite           | 1200.00 |        2 | Dell Vostro</span><br><span class="line">          8 | Dell Vostro        |  800.00 |        2 | Dell Vostro</span><br><span class="line">          6 | Lenovo Thinkpad    |  700.00 |        2 | Dell Vostro</span><br><span class="line">          7 | Sony VAIO          |  700.00 |        2 | Dell Vostro</span><br><span class="line">          9 | iPad               |  700.00 |        3 | Samsung Galaxy Tab</span><br><span class="line">         11 | Samsung Galaxy Tab |  200.00 |        3 | Samsung Galaxy Tab</span><br><span class="line">         10 | Kindle Fire        |  150.00 |        3 | Samsung Galaxy Tab</span><br><span class="line">(11 rows)</span><br></pre></td></tr></table></figure>
<ul>
<li>PARTITION BY子句用于将产品分发到由group_id列中的值指定的产品组（或分区）中。</li>
</ul>
<ul>
<li>ORDER BY子句将每个产品组中的产品从高到低排序。</li>
</ul>
<ul>
<li>frame子句将整个分区定义为一个框架。</li>
</ul>
<ul>
<li>NTH_VALUE()函数返回每个产品组第二行的产品名称。</li>
</ul>
<h2 id="LAST-VALUE函数"><a href="#LAST-VALUE函数" class="headerlink" title="LAST_VALUE函数"></a>LAST_VALUE函数</h2><blockquote>
<p>LAST_VALUE()函数返回结果集的有序分区中的最后一个值。</p>
</blockquote>
<blockquote>
<p>LAST_VALUE()函数的语法如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LAST_VALUE ( expression )  </span><br><span class="line">OVER (</span><br><span class="line">    [PARTITION BY partition_expression, ... ]</span><br><span class="line">    ORDER BY sort_expression [ASC | DESC], ...</span><br><span class="line">    [frame_clause]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>expression:<br>表达式可以是根据结果集的有序分区中最后一行的值求值的表达式、列或子查询。表达式必须返回单个值，而且不能是window函数。</li>
</ul>
<ul>
<li>PARTITION BY子句：<br>PARTITION BY子句将结果集的行划分为应用LAST_VALUE()函数的分区。如果省略PARTITION BY子句，则LAST_VALUE()函数会将整个结果集视为单个分区。</li>
</ul>
<ul>
<li>ORDER BY子句:<br>ORDER BY子句指定LAST_VALUE()函数应用到的每个分区中行的排序顺序。</li>
</ul>
<ul>
<li>frame_clause:<br>frame_clause定义了在当前分区中应用了该功能的行的子集。</li>
</ul>
<h3 id="LAST-VALUE-函数示例"><a href="#LAST-VALUE-函数示例" class="headerlink" title="LAST_VALUE()函数示例"></a>LAST_VALUE()函数示例</h3><blockquote>
<p>使用在window函数中创建的products表进行演示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># select * from products;</span></span><br><span class="line"> product_id |    product_name    |  price  | group_id</span><br><span class="line">------------+--------------------+---------+----------</span><br><span class="line">          1 | Microsoft Lumia    |  200.00 |        1</span><br><span class="line">          2 | HTC One            |  400.00 |        1</span><br><span class="line">          3 | Nexus              |  500.00 |        1</span><br><span class="line">          4 | iPhone             |  900.00 |        1</span><br><span class="line">          5 | HP Elite           | 1200.00 |        2</span><br><span class="line">          6 | Lenovo Thinkpad    |  700.00 |        2</span><br><span class="line">          7 | Sony VAIO          |  700.00 |        2</span><br><span class="line">          8 | Dell Vostro        |  800.00 |        2</span><br><span class="line">          9 | iPad               |  700.00 |        3</span><br><span class="line">         10 | Kindle Fire        |  150.00 |        3</span><br><span class="line">         11 | Samsung Galaxy Tab |  200.00 |        3</span><br><span class="line">(11 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用LAST_VALUE()函数返回所有产品以及价格最高的产品：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    product_id,</span><br><span class="line">    product_name,</span><br><span class="line">    price,</span><br><span class="line">    FIRST_VALUE(product_name)</span><br><span class="line">    OVER(</span><br><span class="line">        ORDER BY price</span><br><span class="line">        RANGE BETWEEN</span><br><span class="line">            UNBOUNDED PRECEDING AND</span><br><span class="line">            UNBOUNDED FOLLOWING</span><br><span class="line">    ) highest_price</span><br><span class="line">FROM</span><br><span class="line">    products;</span><br><span class="line"> product_id |    product_name    |  price  | highest_price</span><br><span class="line">------------+--------------------+---------+---------------</span><br><span class="line">         10 | Kindle Fire        |  150.00 | Kindle Fire</span><br><span class="line">          1 | Microsoft Lumia    |  200.00 | Kindle Fire</span><br><span class="line">         11 | Samsung Galaxy Tab |  200.00 | Kindle Fire</span><br><span class="line">          2 | HTC One            |  400.00 | Kindle Fire</span><br><span class="line">          3 | Nexus              |  500.00 | Kindle Fire</span><br><span class="line">          9 | iPad               |  700.00 | Kindle Fire</span><br><span class="line">          6 | Lenovo Thinkpad    |  700.00 | Kindle Fire</span><br><span class="line">          7 | Sony VAIO          |  700.00 | Kindle Fire</span><br><span class="line">          8 | Dell Vostro        |  800.00 | Kindle Fire</span><br><span class="line">          4 | iPhone             |  900.00 | Kindle Fire</span><br><span class="line">          5 | HP Elite           | 1200.00 | Kindle Fire</span><br><span class="line">(11 rows)</span><br></pre></td></tr></table></figure>
<ul>
<li>在FIRST_VALUE()函数中省略了PARTITION BY子句，因此，FIRST_VALUE()函数将整个结果集视为一个分区。</li>
</ul>
<ul>
<li>ORDER BY子句按价格从低到高的顺序对产品进行排序。</li>
</ul>
<ul>
<li>LAST_VALUE()选择了分区或结果集中第一行的产品名称。</li>
</ul>
<blockquote>
<p>使用LAST_VALUE()函数返回所有产品以及每个产品组中最昂贵的产品：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    product_id,</span><br><span class="line">    product_name,</span><br><span class="line">   group_id,</span><br><span class="line">    price,</span><br><span class="line">    LAST_VALUE(product_name)</span><br><span class="line">    OVER(</span><br><span class="line">      PARTITION BY group_id</span><br><span class="line">        ORDER BY price</span><br><span class="line">        RANGE BETWEEN</span><br><span class="line">            UNBOUNDED PRECEDING AND</span><br><span class="line">            UNBOUNDED FOLLOWING</span><br><span class="line">    ) highest_price</span><br><span class="line">FROM</span><br><span class="line">    products;</span><br><span class="line"> product_id |    product_name    | group_id |  price  | highest_price</span><br><span class="line">------------+--------------------+----------+---------+---------------</span><br><span class="line">          1 | Microsoft Lumia    |        1 |  200.00 | iPhone</span><br><span class="line">          2 | HTC One            |        1 |  400.00 | iPhone</span><br><span class="line">          3 | Nexus              |        1 |  500.00 | iPhone</span><br><span class="line">          4 | iPhone             |        1 |  900.00 | iPhone</span><br><span class="line">          6 | Lenovo Thinkpad    |        2 |  700.00 | HP Elite</span><br><span class="line">          7 | Sony VAIO          |        2 |  700.00 | HP Elite</span><br><span class="line">          8 | Dell Vostro        |        2 |  800.00 | HP Elite</span><br><span class="line">          5 | HP Elite           |        2 | 1200.00 | HP Elite</span><br><span class="line">         10 | Kindle Fire        |        3 |  150.00 | iPad</span><br><span class="line">         11 | Samsung Galaxy Tab |        3 |  200.00 | iPad</span><br><span class="line">          9 | iPad               |        3 |  700.00 | iPad</span><br><span class="line">(11 rows)</span><br></pre></td></tr></table></figure>
<ul>
<li>PARTITION BY子句按组ID将行分为由组ID 1、2和3指定的三个分区。</li>
</ul>
<ul>
<li>ORDER BY子句将每个产品组（或分区）中的产品从高到低排序。</li>
</ul>
<ul>
<li>RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING子句定义了从每个分区的第一行开始到最后一行的构成。 LAST_VALUE()函数分别应用于每个分区，并返回每个分区中最后一行的产品名称。</li>
</ul>
<h2 id="FIRST-VALUE函数"><a href="#FIRST-VALUE函数" class="headerlink" title="FIRST_VALUE函数"></a>FIRST_VALUE函数</h2><h3 id="FIRST-VALUE-函数语法"><a href="#FIRST-VALUE-函数语法" class="headerlink" title="FIRST_VALUE()函数语法"></a>FIRST_VALUE()函数语法</h3><blockquote>
<p>FIRST_VALUE()函数返回对结果集的排序分区中的第一行求值的值。</p>
</blockquote>
<blockquote>
<p>FIRST_VALUE()函数的语法：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FIRST_VALUE ( expression )  </span><br><span class="line">OVER (</span><br><span class="line">    [PARTITION BY partition_expression, ... ]</span><br><span class="line">    ORDER BY sort_expression [ASC | DESC], ...</span><br><span class="line">    [rows_range_clause]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>expression:<br>表达式可以是根据结果集排序分区的第一行的值评估的表达式、列或子查询。表达式必须返回单个值，而且它不能是window函数。</li>
</ul>
<p>PARTITION BY子句:<br>PARTITION BY子句将结果集中的行划分为应用FIRST_VALUE()函数的分区。</p>
<p>ORDER BY子句:<br>ORDER BY子句指定FIRST_VALUE()函数应用到的每个分区中行的排序顺序。</p>
<p>rows_range_clause:<br>rows_range_clause通过在分区中定义起点和终点来进一步限制分区中的行。</p>
<h3 id="FIRST-VALUE-函数示例"><a href="#FIRST-VALUE-函数示例" class="headerlink" title="FIRST_VALUE()函数示例"></a>FIRST_VALUE()函数示例</h3><blockquote>
<p>使用在window函数中创建的products表进行演示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># select * from products;</span></span><br><span class="line"> product_id |    product_name    |  price  | group_id</span><br><span class="line">------------+--------------------+---------+----------</span><br><span class="line">          1 | Microsoft Lumia    |  200.00 |        1</span><br><span class="line">          2 | HTC One            |  400.00 |        1</span><br><span class="line">          3 | Nexus              |  500.00 |        1</span><br><span class="line">          4 | iPhone             |  900.00 |        1</span><br><span class="line">          5 | HP Elite           | 1200.00 |        2</span><br><span class="line">          6 | Lenovo Thinkpad    |  700.00 |        2</span><br><span class="line">          7 | Sony VAIO          |  700.00 |        2</span><br><span class="line">          8 | Dell Vostro        |  800.00 |        2</span><br><span class="line">          9 | iPad               |  700.00 |        3</span><br><span class="line">         10 | Kindle Fire        |  150.00 |        3</span><br><span class="line">         11 | Samsung Galaxy Tab |  200.00 |        3</span><br><span class="line">(11 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用FIRST_VALUE()函数返回所有产品以及价格最低的产品：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    product_id,</span><br><span class="line">    product_name,</span><br><span class="line">   group_id,</span><br><span class="line">    price,</span><br><span class="line">    FIRST_VALUE(product_name)</span><br><span class="line">    OVER(</span><br><span class="line">   PARTITION BY group_id</span><br><span class="line">        ORDER BY price</span><br><span class="line">        RANGE BETWEEN</span><br><span class="line">            UNBOUNDED PRECEDING AND</span><br><span class="line">            UNBOUNDED FOLLOWING</span><br><span class="line">    ) highest_price</span><br><span class="line">FROM</span><br><span class="line">    products;</span><br><span class="line"> product_id |    product_name    | group_id |  price  |  highest_price</span><br><span class="line">------------+--------------------+----------+---------+-----------------</span><br><span class="line">          1 | Microsoft Lumia    |        1 |  200.00 | Microsoft Lumia</span><br><span class="line">          2 | HTC One            |        1 |  400.00 | Microsoft Lumia</span><br><span class="line">          3 | Nexus              |        1 |  500.00 | Microsoft Lumia</span><br><span class="line">          4 | iPhone             |        1 |  900.00 | Microsoft Lumia</span><br><span class="line">          6 | Lenovo Thinkpad    |        2 |  700.00 | Lenovo Thinkpad</span><br><span class="line">          7 | Sony VAIO          |        2 |  700.00 | Lenovo Thinkpad</span><br><span class="line">          8 | Dell Vostro        |        2 |  800.00 | Lenovo Thinkpad</span><br><span class="line">          5 | HP Elite           |        2 | 1200.00 | Lenovo Thinkpad</span><br><span class="line">         10 | Kindle Fire        |        3 |  150.00 | Kindle Fire</span><br><span class="line">         11 | Samsung Galaxy Tab |        3 |  200.00 | Kindle Fire</span><br><span class="line">          9 | iPad               |        3 |  700.00 | Kindle Fire</span><br><span class="line">(11 rows)</span><br></pre></td></tr></table></figure>
<ul>
<li>在FIRST_VALUE()函数中省略了PARTITION BY子句，因此，FIRST_VALUE()函数将整个结果集视为一个分区。</li>
</ul>
<ul>
<li>ORDER + 在FIRST_VALUE()函数中省略了PARTITION BY子句，因此，FIRST_VALUE()函数将整个结果集视为一个分区。<br>BY子句按价格从低到高的顺序对产品进行排序。</li>
</ul>
<ul>
<li>FIRST_VALUE()函数将应用于整个结果集，并在第一行的product_name列中选择值。</li>
</ul>
<blockquote>
<p>使用FIRST_VALUE()函数返回按产品组分组的所有产品。对于每个产品组，它以最低的价格返回产品：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    product_id,</span><br><span class="line">    product_name,</span><br><span class="line">   group_id,</span><br><span class="line">    price,</span><br><span class="line">    FIRST_VALUE(product_name)</span><br><span class="line">    OVER(</span><br><span class="line">      PARTITION BY group_id</span><br><span class="line">        ORDER BY price</span><br><span class="line">        RANGE BETWEEN</span><br><span class="line">            UNBOUNDED PRECEDING AND</span><br><span class="line">            UNBOUNDED FOLLOWING</span><br><span class="line">    ) highest_price</span><br><span class="line">FROM</span><br><span class="line">    products;</span><br><span class="line"> product_id |    product_name    | group_id |  price  |  highest_price</span><br><span class="line">------------+--------------------+----------+---------+-----------------</span><br><span class="line">          1 | Microsoft Lumia    |        1 |  200.00 | Microsoft Lumia</span><br><span class="line">          2 | HTC One            |        1 |  400.00 | Microsoft Lumia</span><br><span class="line">          3 | Nexus              |        1 |  500.00 | Microsoft Lumia</span><br><span class="line">          4 | iPhone             |        1 |  900.00 | Microsoft Lumia</span><br><span class="line">          6 | Lenovo Thinkpad    |        2 |  700.00 | Lenovo Thinkpad</span><br><span class="line">          7 | Sony VAIO          |        2 |  700.00 | Lenovo Thinkpad</span><br><span class="line">          8 | Dell Vostro        |        2 |  800.00 | Lenovo Thinkpad</span><br><span class="line">          5 | HP Elite           |        2 | 1200.00 | Lenovo Thinkpad</span><br><span class="line">         10 | Kindle Fire        |        3 |  150.00 | Kindle Fire</span><br><span class="line">         11 | Samsung Galaxy Tab |        3 |  200.00 | Kindle Fire</span><br><span class="line">          9 | iPad               |        3 |  700.00 | Kindle Fire</span><br><span class="line">(11 rows)</span><br></pre></td></tr></table></figure>
<ul>
<li>PARTITION BY子句按产品组分发产品。</li>
</ul>
<ul>
<li>ORDER BY子句按价格从低到高的顺序对每个产品组（分区）中的产品进行排序。</li>
</ul>
<ul>
<li>RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING子句定义了从每个分区的第一行开始到最后一行的构成。 </li>
</ul>
<ul>
<li>FIRST_VALUE()函数分别应用于每个分区。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    
    
    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="zhijiansd.github.io/blog/pg16/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhiJian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhiJian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/pg16/" class="post-title-link" itemprop="zhijiansd.github.io/index.html">PostgreSQL之管理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-20 13:28:16 / 修改时间：13:30:23" itemprop="dateCreated datePublished" datetime="2020-05-20T13:28:16+08:00">2020-05-20</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/postresql/" itemprop="url" rel="index"><span itemprop="name">postresql</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/pg16/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/pg16/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">37k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1:02</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="PostgreSQL管理"><a href="#PostgreSQL管理" class="headerlink" title="PostgreSQL管理"></a>PostgreSQL管理</h2><h3 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h3><blockquote>
<p>PostgreSQL使用角色概念来管理数据库访问权限。角色可以是用户或组，具体取决于您如何设置角色。具有登录权限的角色称为用户。角色可以是称为组的其他角色的成员。</p>
</blockquote>
<h4 id="创建PostgreSQL角色"><a href="#创建PostgreSQL角色" class="headerlink" title="创建PostgreSQL角色"></a>创建PostgreSQL角色</h4><blockquote>
<p>要创建新角色，请使用CREATE ROLE语句，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE ROLE role_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要获取集群中所有可用的角色，请从pg_roles系统目录中查询，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   rolname</span><br><span class="line">FROM</span><br><span class="line">   pg_roles;</span><br><span class="line">          rolname</span><br><span class="line">---------------------------</span><br><span class="line"> pg_monitor</span><br><span class="line"> pg_read_all_settings</span><br><span class="line"> pg_read_all_stats</span><br><span class="line"> pg_stat_scan_tables</span><br><span class="line"> pg_read_server_files</span><br><span class="line"> pg_write_server_files</span><br><span class="line"> pg_execute_server_program</span><br><span class="line"> pg_signal_backend</span><br><span class="line"> <span class="built_in">test</span></span><br><span class="line"> root</span><br><span class="line"> postgres</span><br><span class="line"> hr</span><br><span class="line"> zhi</span><br><span class="line">(13 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果使用psql工具，则可以使用\du命令列出所有现有角色:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; \du</span><br><span class="line">                                        角色列表</span><br><span class="line"> 角色名称 |                    属性                    |            成员属于             </span><br><span class="line">----------+--------------------------------------------+---------------------------------</span><br><span class="line"> hr       | 无法登录                                  +| &#123;&#125;</span><br><span class="line">          | 密码有效直至infinity                       | </span><br><span class="line"> postgres | 超级用户, 建立角色, 建立 DB, 复制, 绕过RLS | &#123;&#125;</span><br><span class="line"> root     |                                            | &#123;&#125;</span><br><span class="line"> <span class="built_in">test</span>     |                                            | &#123;pg_read_server_files,postgres&#125;</span><br><span class="line"> zhi      |                                            | &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="角色属性"><a href="#角色属性" class="headerlink" title="角色属性"></a>角色属性</h4><blockquote>
<p>数据库角色的属性定义了角色的特权，包括登录，超级用户，数据库创建，角色创建，密码等。</p>
</blockquote>
<blockquote>
<p>创建具有登录特权、密码和有效日期的角色：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE ROLE wzj WITH PASSWORD 'pgsql2020' VALID UNTIL '2020-01-01';</span></span><br><span class="line">CREATE ROLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建具有超级用户状态的角色，这意味着该角色可以绕过所有授权检查：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE ROLE bigwzj SUPERUSER;</span></span><br><span class="line">CREATE ROLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，您必须是超级用户才能创建另一个超级用户。</p>
</blockquote>
<blockquote>
<p>如果希望角色具有数据库创建特权，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE ROLE admin CREATEDB;</span></span><br><span class="line">CREATE ROLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用以下语句创建具有创建特权的角色：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE ROLE security CREATEROLE;</span></span><br><span class="line">CREATE ROLE</span><br></pre></td></tr></table></figure>
<h4 id="角色成员"><a href="#角色成员" class="headerlink" title="角色成员"></a>角色成员</h4><blockquote>
<p>将角色作为一个组进行管理比较容易，这样就可以从整个组中授予或撤消特权。在PostgreSQL中，创建一个代表组的角色，然后将组角色的成员资格授予各个用户角色。按照惯例，组角色没有LOGIN特权。</p>
</blockquote>
<blockquote>
<p>要创建组角色，请使用CREATE ROLE语句，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE ROLE group_role;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如，以下语句创建flywzj组角色：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE ROLE flywzj;</span></span><br><span class="line">CREATE ROLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用GRANT语句将用户角色添加到组角色中：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT group_role to user_role;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如，要将用户角色zhi添加到flywzj组角色，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># GRANT flywzj TO zhi;</span></span><br><span class="line">GRANT ROLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要从组角色中删除用户角色，请使用REVOKE语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE group_role FROM user_role;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如，要从flywzj组角色中删除zhi用户角色，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># REVOKE flywzj FROM zhi;</span></span><br><span class="line">REVOKE ROLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，PostgreSQL不允许进行角色嵌套，诸如其中一个角色是另一个角色的成员这样的情况。</p>
</blockquote>
<h4 id="组和用户角色继承"><a href="#组和用户角色继承" class="headerlink" title="组和用户角色继承"></a>组和用户角色继承</h4><blockquote>
<p>用户角色可以通过以下方式使用组角色的特权：</p>
<ul>
<li>首先，用户角色可以使用SET ROLE语句临时成为组角色，这意味着用户角色使用组角色的特权而不是原始特权。此外，在会话中创建的任何数据库对象均由组角色而不是用户角色拥有。</li>
</ul>
<ul>
<li>其次，具有INHERIT属性的用户角色将自动拥有其所属成员的组角色的特权，包括由组角色继承的所有特权。</li>
</ul>
</blockquote>
<blockquote>
<p>请参见以下示例：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE ROLE doe LOGIN INHERIT;</span></span><br><span class="line">CREATE ROLE sales NOINHERIT;</span><br><span class="line">CREATE ROLE marketing NOINHERIT;</span><br><span class="line">GRANT sales to doe;</span><br><span class="line">GRANT marketing to sales;</span><br><span class="line">CREATE ROLE</span><br><span class="line"></span><br><span class="line">CREATE ROLE</span><br><span class="line"></span><br><span class="line">CREATE ROLE</span><br><span class="line"></span><br><span class="line">GRANT ROLE</span><br><span class="line"></span><br><span class="line">GRANT ROLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果以doe身份连接到PostgreSQL，您将拥有doe特权以及授予sales的特权，因为doe用户角色具有INHERIT属性。但是，您没有marketing特权，因为为sales用户角色定义了NOINHERIT属性。</p>
</blockquote>
<blockquote>
<p>执行以下语句后：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SET ROLE sales;</span></span><br><span class="line">SET</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将只拥有授予sales的特权，而没有授予doe的特权。</p>
</blockquote>
<blockquote>
<p>并且执行以下语句后：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SET ROLE marketing;</span></span><br><span class="line">SET</span><br></pre></td></tr></table></figure>
<blockquote>
<p>仅具有授予marketing的特权，而没有授予admin和doe的特权。</p>
</blockquote>
<blockquote>
<p>要恢复原始特权，可以使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># RESET ROLE;</span></span><br><span class="line">RESET</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，只有数据库对象的特权才是可继承的。LOGIN、SUPERUSER、CREATEROLE和CREATEDB是不能作为普通特权继承的特殊角色。</p>
</blockquote>
<h4 id="删除角色"><a href="#删除角色" class="headerlink" title="删除角色"></a>删除角色</h4><blockquote>
<p>可以使用该DROP ROLE语句删除组角色或用户角色:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP ROLE role_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在删除角色之前，必须重新分配或删除其拥有的所有对象并撤消其特权。</p>
</blockquote>
<blockquote>
<p>如果删除组角色，PostgreSQL将自动撤消组中的所有成员资格。该组的用户角色不受影响。</p>
</blockquote>
<h4 id="列出用户"><a href="#列出用户" class="headerlink" title="列出用户"></a>列出用户</h4><blockquote>
<p>要列出PostgreSQL数据库服务器中的所有用户帐户，请使用psql命令\du，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; \du postgres</span><br><span class="line">                             角色列表</span><br><span class="line"> 角色名称 |                    属性                    | 成员属于 </span><br><span class="line">----------+--------------------------------------------+----------</span><br><span class="line"> postgres | 超级用户, 建立角色, 建立 DB, 复制, 绕过RLS | &#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要显示更多信息，可以使用\du +命令：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; \du+ postgres</span><br><span class="line">                                角色列表</span><br><span class="line"> 角色名称 |                    属性                    | 成员属于 | 描述 </span><br><span class="line">----------+--------------------------------------------+----------+------</span><br><span class="line"> postgres | 超级用户, 建立角色, 建立 DB, 复制, 绕过RLS | &#123;&#125;       |</span><br></pre></td></tr></table></figure>
<h3 id="备份和还原数据库"><a href="#备份和还原数据库" class="headerlink" title="备份和还原数据库"></a>备份和还原数据库</h3><blockquote>
<p>备份数据库是数据库管理中最关键的任务之一。在备份数据库之前，应考虑以下几点：</p>
<ul>
<li>全部/部分数据库</li>
</ul>
<ul>
<li>数据和结构，或仅结构</li>
</ul>
<ul>
<li>时间点恢复</li>
</ul>
<ul>
<li>恢复性能<br>PostgreSQL提供pg_dump和pg_dumpall工具来轻松有效地备份数据库。</li>
</ul>
</blockquote>
<h4 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h4><blockquote>
<p>要备份数据库，可以使用pg_dump工具。pg_dump将所有数据库对象的内容转储到单个文件中。</p>
</blockquote>
<blockquote>
<p>执行pg_dump程序，并使用以下选项将test数据库备份到root文件夹并命名为test.tar文件:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pg_dump -U postgres -W -F t test &gt; /root/test.tar</span></span><br></pre></td></tr></table></figure>
<ul>
<li>-U ：指定要连接到PostgreSQL数据库服务器的用户。 </li>
</ul>
<ul>
<li>-W：强制pg_dump在连接到PostgreSQL数据库服务器之前提示输入密码。按下回车键后，pg_dump将提示输入postgres用户的密码。</li>
<li>-F：指定输出文件格式，可以是以下之一：(c：自定义格式文件格式；d：目录格式存档；t：tar以及默认的p：纯文本SQL脚本文件)</li>
</ul>
<h4 id="备份所有数据库"><a href="#备份所有数据库" class="headerlink" title="备份所有数据库"></a>备份所有数据库</h4><blockquote>
<p>要备份所有数据库，可以依次运行上面的单个pg_dump命令，如果要加快备份过程，则可以并行运行:</p>
<ul>
<li>首先，在psql中，使用命令\list列出集群中所有可用的数据库</li>
</ul>
<ul>
<li>其次，使用上面所述的pg_dump程序备份每个单独的数据库。</li>
</ul>
</blockquote>
<blockquote>
<p>除pg_dump程序外，PostgreSQL还提供了pg_dumpall工具，该工具可一次备份所有数据库。但是，由于以下原因，不建议使用此工具：</p>
<ul>
<li>pg_dumpall程序将所有数据库一个接一个地导出到一个脚本文件中，这使您无法执行并行还原。如果以这种方式备份所有数据库，则还原过程将花费更多时间。</li>
</ul>
<ul>
<li>转储所有数据库所需的时间比每个数据库要长，因此您不知道每个数据库的哪个转储与特定时间点有关。</li>
</ul>
</blockquote>
<blockquote>
<p>如果您有充分的理由使用pg_dumpall来备份所有数据库，则使用以下命令：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pg_dumpall -U postgres &gt; /root/all.sql</span><br></pre></td></tr></table></figure>
<h4 id="备份数据库对象"><a href="#备份数据库对象" class="headerlink" title="备份数据库对象"></a>备份数据库对象</h4><blockquote>
<p>有时，只想备份数据库对象，以便只能还原架构。这在测试阶段很有用，您不希望在测试期间填充旧的测试数据。</p>
</blockquote>
<blockquote>
<p>要备份所有数据库中的所有对象，包括角色、表空间、数据库、架构、表、索引、触发器、函数、约束、视图、所有权和特权，请使用以下命令：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pg_dumpall -U postgres --schema-only  &gt; /root/schema.sql</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果只想备份角色，请使用以下命令：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pg_dumpall -U postgres --roles-only  &gt; /root/roles.sql</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要备份表空间，请使用以下命令：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pg_dumpall -U postgres --tablespaces-only  &gt; /root/tp.sql</span></span><br></pre></td></tr></table></figure>
<h4 id="恢复数据库"><a href="#恢复数据库" class="headerlink" title="恢复数据库"></a>恢复数据库</h4><blockquote>
<p>在还原数据库之前，需要终止与该数据库的所有连接并准备备份文件。在PostgreSQL中，可以通过两种方式还原数据库：</p>
<ul>
<li>使用psql还原由pg_dump和pg_dumpall工具生成的普通SQL脚本文件</li>
</ul>
<ul>
<li>使用pg_restore还原pg_dump工具创建的tar文件和目录格式</li>
</ul>
</blockquote>
<h5 id="使用psql还原数据库"><a href="#使用psql还原数据库" class="headerlink" title="使用psql还原数据库"></a>使用psql还原数据库</h5><blockquote>
<p>使用psql实用程序，可以还原pg_dump，pg_dumpall或任何其他工具生成的兼容的SQL脚本备份文件。通过使用psql工具，必须执行整个脚本。</p>
</blockquote>
<blockquote>
<p>要还原完整备份并忽略还原过程中发生的任何错误，请使用以下命令：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql -U username -f backupfile.sql</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要停止还原数据库以防发生错误，请使用以下命令：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql -U username --<span class="built_in">set</span> ON_ERROR_STOP=on -f backupfile</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果是在特定数据库中备份特定数据库对象，则可以使用以下命令还原它们：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql -U username -d database_name -f objects.sql</span><br></pre></td></tr></table></figure>
<h5 id="使用pg-restore还原数据库"><a href="#使用pg-restore还原数据库" class="headerlink" title="使用pg_restore还原数据库"></a>使用pg_restore还原数据库</h5><blockquote>
<p>除了psqltool之外，还可以使用pg_restore程序来还原由pg_dump或pg_dump工具备份的数据库。使用pg_restore程序，可以使用多种还原数据库选项，例如：</p>
<ul>
<li>pg_restore允许使用-j选项执行并行还原，以指定要还原的线程数。每个线程同时还原一个单独的表，从而极大地加快了处理速度。当前，pg_restore仅对自定义文件格式支持此选项。</li>
</ul>
<ul>
<li>pg_restore可以在包含完整数据库的备份文件中还原特定的数据库对象。</li>
</ul>
<ul>
<li>pg_restore可以采用旧版本备份的数据库，并以新版本还原它。</li>
</ul>
</blockquote>
<blockquote>
<p>创建示例数据库</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE DATABASE newtest;</span></span><br><span class="line">CREATE DATABASE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用之前以pg_dump工具生成的tar文件格式恢复test数据库</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pg_restore --dbname=newtest --verbose /root/test.tar</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果还原数据库，该数据库与您备份的数据库相同，则可以使用以下命令：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pg_restore --dbname=test --create --verbose /root/test.tar</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建新示例数据库</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE DATABASE test_tp;</span></span><br><span class="line">CREATE DATABASE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用以下命令从test.tar备份文件中还原表结构：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pg_restore --dbname=test_tp --section=pre-data /root/test.tar</span></span><br></pre></td></tr></table></figure>
<h3 id="表空间管理"><a href="#表空间管理" class="headerlink" title="表空间管理"></a>表空间管理</h3><blockquote>
<p>表空间是PostgreSQL在磁盘上的一个位置，PostgreSQL在其中存储包含数据库对象（例如索引和表）的数据文件。PostgreSQL使用表空间将逻辑名映射到磁盘上的物理位置。</p>
</blockquote>
<blockquote>
<p>初始化数据库集群时，将自动创建两个表空间：</p>
<ul>
<li>pg_default表空间存储所有用户数据。是template1和template0数据库的默认表空间（因此，也将是其他数据库的默认表空间，除非被CREATE DATABASE中的TABLESPACE子句覆盖）。</li>
</ul>
<ul>
<li>pg_global表空间存储所有全局数据。用于共享系统目录。</li>
</ul>
</blockquote>
<blockquote>
<p>使用表空间，可以控制PostgreSQL的磁盘布局。使用表空间有两个主要优点：</p>
<ul>
<li>首先，如果初始化集群的分区空间不足，则可以在其他分区上创建新的表空间并使用它，直到重新配置系统为止。</li>
</ul>
<ul>
<li>其次，可以使用数据库对象使用情况的统计信息来优化数据库的性能。例如，可以将频繁访问索引或表放置在执行速度非常快的设备（例如固态设备）上，然后将包含存档数据的表放到速度较慢的设备上很少使用。</li>
</ul>
</blockquote>
<h4 id="CREATE-TABLESPACE语句"><a href="#CREATE-TABLESPACE语句" class="headerlink" title="CREATE TABLESPACE语句"></a>CREATE TABLESPACE语句</h4><blockquote>
<p>要创建新表空间，请使用CREATE TABLESPACE语句，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLESPACE tablespace_name</span><br><span class="line">OWNER user_name</span><br><span class="line">LOCATION directory_path;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>表空间的名称不应以pg_开头，因为这些名称是为系统表空间保留的。</p>
</blockquote>
<blockquote>
<p>默认情况下，执行CREATE TABLESPACE的用户是表空间的所有者。该语句还允许将表空间的所有权分配给OWNER子句中指定的另一个用户。</p>
</blockquote>
<blockquote>
<p>directory_path是用于表空间的空目录的绝对路径。PostgreSQL系统用户必须拥有该目录才能在其中读取和写入数据。</p>
</blockquote>
<blockquote>
<p>创建表空间后，可以在CREATE DATABASE、CREATE TABLE和CREATEINDEX语句中进行指定，以将对象的数据文件存储在表空间中。</p>
</blockquote>
<h4 id="创建表空间示例"><a href="#创建表空间示例" class="headerlink" title="创建表空间示例"></a>创建表空间示例</h4><blockquote>
<p>创建名为newtest的新表空间，该表空间的物理位置为/data/newtest。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkdir /data/newtest</span></span><br><span class="line"><span class="comment"># chown postgres:postgres /data/newtest/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE TABLESPACE newtest LOCATION '/data/newtest';</span></span><br><span class="line">CREATE TABLESPACE</span><br></pre></td></tr></table></figure>
<h4 id="ALTER-TABLESPACE语句"><a href="#ALTER-TABLESPACE语句" class="headerlink" title="ALTER TABLESPACE语句"></a>ALTER TABLESPACE语句</h4><blockquote>
<p>创建表空间后，可以使用ALTER TABLESPACE更改其定义，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLESPACE action;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PostgreSQL提供了一些操作，例如重命名表空间名称，更改所有者和设置表空间的参数。要更改表空间的名称，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLESPACE tablespace_name RENAME TO new_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要更改表空间的所有者，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLESPACE tablespace_name OWNER TO new_owner;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>还可以更改表空间的参数，包括seq_page_cost和random_page_cost，这些参数指定从表空间中的表读取页面的开销。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLESPACE tablespace_name SET parameter = value;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要执行ALTER TABLESPACE语句，您必须是表空间的超级用户或所有者。注意，ALTER TABLESPACE语句是PostgreSQL扩展。</p>
</blockquote>
<h4 id="ALTER-TABLESPACE示例"><a href="#ALTER-TABLESPACE示例" class="headerlink" title="ALTER TABLESPACE示例"></a>ALTER TABLESPACE示例</h4><blockquote>
<p>将newtest表空间重命名为ntest：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># ALTER TABLESPACE newtest RENAME TO ntest;</span></span><br><span class="line">ALTER TABLESPACE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将ntest的所有者更改为zhi</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># ALTER TABLESPACE ntest OWNER to zhi;</span></span><br><span class="line">ALTER TABLESPACE</span><br></pre></td></tr></table></figure>
<h4 id="DROP-TABLESPACE语句"><a href="#DROP-TABLESPACE语句" class="headerlink" title="DROP TABLESPACE语句"></a>DROP TABLESPACE语句</h4><blockquote>
<p>要删除表空间，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLESPACE IF EXISTS tablespace_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>您需要在DROP TABLESPACE子句之后指定表空间的名称。IF EXISTS可以避免删除不存在的表空间的错误。只有表空间所有者或超级用户可以删除表空间。在删除表空间之前，请确保其为空，这意味着其中没有数据库对象。</p>
</blockquote>
<h4 id="DROP-TABLESPACE示例"><a href="#DROP-TABLESPACE示例" class="headerlink" title="DROP TABLESPACE示例"></a>DROP TABLESPACE示例</h4><blockquote>
<p>首先，创建一个名为demo的表空间，将其映射到/data/demo目录:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE TABLESPACE demo LOCATION '/data/demo';</span></span><br><span class="line">CREATE TABLESPACE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其次，创建一个名为demodb的新数据库并将其表空间设置为demo:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE DATABASE demodb TABLESPACE = demo;</span></span><br><span class="line">CREATE DATABASE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三，在demodb中创建一个名为test的新表，并将其表空间设置为demo：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE TABLE test (</span></span><br><span class="line">   ID serial PRIMARY KEY,</span><br><span class="line">   title VARCHAR (255) NOT NULL</span><br><span class="line">) TABLESPACE demo;</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用以下查询来获取demon表空间中的所有对象：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   ts.spcname,</span><br><span class="line">   cl.relname</span><br><span class="line">FROM</span><br><span class="line">   pg_class cl</span><br><span class="line">JOIN pg_tablespace ts ON cl.reltablespace = ts.oid</span><br><span class="line">WHERE</span><br><span class="line">   ts.spcname = <span class="string">'demo'</span>;</span><br><span class="line"> spcname | relname</span><br><span class="line">---------+---------</span><br><span class="line"> demo    | <span class="built_in">test</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第四，尝试删除demo表空间：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># DROP TABLESPACE demo;</span></span><br><span class="line">错误:  表空间 <span class="string">"demo"</span> 不是空的</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第五，使用ALTER TABLE语句将数据库移至另一个表空间，例如pg_default(也可以通过先删除数据库和表再删除表空间)：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE demodb</span><br><span class="line">SET TABLESPACE = pg_default;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第六，再次删除表空间:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># DROP TABLESPACE demo;</span></span><br><span class="line">DROP TABLESPACE</span><br></pre></td></tr></table></figure>
<h2 id="实用PG"><a href="#实用PG" class="headerlink" title="实用PG"></a>实用PG</h2><h3 id="重设密码"><a href="#重设密码" class="headerlink" title="重设密码"></a>重设密码</h3><blockquote>
<p>PostgreSQL使用存储在数据库数据目录中的pg_hba.conf配置文件来控制客户端认证。HBA表示基于主机的身份验证。要重置postgres用户的密码，需要修改此配置文件中的一些参数。</p>
</blockquote>
<ul>
<li>步骤1.通过将pg_dba.conf文件复制到其他位置来进行备份，或者只是将其重命名为pg_dba_bk.conf</li>
</ul>
<ul>
<li>步骤2.通过在注释行之后的第一行添加以下行来编辑pg_dba.conf文件。注释行以＃号开头。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># "local" is for Unix domain socket connections only</span></span><br><span class="line"><span class="built_in">local</span>   all             all                                     trust</span><br></pre></td></tr></table></figure>
<blockquote>
<p>重新启动PostgreSQL服务器:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart postgresql-12</span><br></pre></td></tr></table></figure>
<blockquote>
<p>连接到PostgreSQL数据库服务器并更改postgres用户密码:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># psql -U postgres</span></span><br><span class="line">psql (12.1)</span><br><span class="line">输入 <span class="string">"help"</span> 来获取帮助信息.</span><br><span class="line"></span><br><span class="line">postgres=<span class="comment"># ALTER USER postgres with password 'very_secure_password';</span></span><br><span class="line">ALTER ROLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>恢复pg_db.conf文件并重新启动服务器，然后使用新密码连接到PostgreSQL数据库服务器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart postgresql-12</span><br></pre></td></tr></table></figure>
<h3 id="psql命令"><a href="#psql命令" class="headerlink" title="psql命令"></a>psql命令</h3><h4 id="连接到数据库"><a href="#连接到数据库" class="headerlink" title="连接到数据库"></a>连接到数据库</h4><blockquote>
<p>以下命令连接到特定用户下的数据库，按下Enter键后，PostgreSQL将询问用户密码:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql -d database -U user -W</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如，以test用户连接到test数据库</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># psql -d test -U test -W</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要连接到位于另一主机上的数据库，请按如下所示添加-h选项：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql -h host -d database -U user -W</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要使用SSL模式进行连接，只需按以下命令所示进行指定：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql -U user -h host <span class="string">"dbname=db sslmode=require"</span></span><br></pre></td></tr></table></figure>
<h4 id="切换到新数据库"><a href="#切换到新数据库" class="headerlink" title="切换到新数据库"></a>切换到新数据库</h4><blockquote>
<p>连接到数据库后，可以在用户指定的用户下将连接切换到新数据库，先前的连接将关闭，如果省略user参数，则假定为当前用户。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\c dbname username</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下命令以postgres用户身份连接到postgres数据库：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># \c postgres postgres</span></span><br><span class="line">用户 postgres 的口令：</span><br><span class="line">您现在已经连接到数据库 <span class="string">"postgres"</span>,用户 <span class="string">"postgres"</span>.</span><br></pre></td></tr></table></figure>
<h4 id="列出可用数据库"><a href="#列出可用数据库" class="headerlink" title="列出可用数据库"></a>列出可用数据库</h4><blockquote>
<p>要列出当前PostgreSQL数据库服务器中的所有数据库，请使用\l命令：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># \l</span></span><br><span class="line">                                     数据库列表</span><br><span class="line">   名称    |  拥有者  | 字元编码 |  校对规则   |    Ctype    |       存取权限        </span><br><span class="line">-----------+----------+----------+-------------+-------------+-----------------------</span><br><span class="line"> postgres  | postgres | UTF8     | zh_CN.UTF-8 | zh_CN.UTF-8 | </span><br><span class="line"> template0 | postgres | UTF8     | zh_CN.UTF-8 | zh_CN.UTF-8 | =c/postgres          +</span><br><span class="line">           |          |          |             |             | postgres=CTc/postgres</span><br><span class="line"> template1 | postgres | UTF8     | zh_CN.UTF-8 | zh_CN.UTF-8 | =c/postgres          +</span><br><span class="line">           |          |          |             |             | postgres=CTc/postgres</span><br><span class="line"> <span class="built_in">test</span>      | <span class="built_in">test</span>     | UTF8     | zh_CN.UTF-8 | zh_CN.UTF-8 | =Tc/<span class="built_in">test</span>             +</span><br><span class="line">           |          |          |             |             | <span class="built_in">test</span>=CTc/<span class="built_in">test</span></span><br><span class="line">(4 行记录)</span><br></pre></td></tr></table></figure>
<h4 id="列出可用表"><a href="#列出可用表" class="headerlink" title="列出可用表"></a>列出可用表</h4><blockquote>
<p>要列出当前数据库中的所有表，请使用\dt命令：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># \dt</span></span><br><span class="line">                关联列表</span><br><span class="line"> 架构模式 |   名称   |  类型  |  拥有者  </span><br><span class="line">----------+----------+--------+----------</span><br><span class="line"> public   | books    | 数据表 | postgres</span><br><span class="line"> public   | contacts | 数据表 | postgres</span><br><span class="line">(2 行记录)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，此命令显示当前连接的数据库中的唯一表。</p>
</blockquote>
<h4 id="获取表信息"><a href="#获取表信息" class="headerlink" title="获取表信息"></a>获取表信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># \d books</span></span><br><span class="line">                                  数据表 <span class="string">"public.books"</span></span><br><span class="line"> 栏位  |          类型          | 校对规则 |  可空的  |               预设                </span><br><span class="line">-------+------------------------+----------+----------+-----------------------------------</span><br><span class="line"> id    | <span class="built_in">integer</span>                |          | not null | nextval(<span class="string">'books_id_seq'</span>::regclass)</span><br><span class="line"> title | character varying(255) |          |          | </span><br><span class="line"> attr  | hstore                 |          |          | </span><br><span class="line">索引：</span><br><span class="line">    <span class="string">"books_pkey"</span> PRIMARY KEY, btree (id)</span><br></pre></td></tr></table></figure>
<h4 id="列出可用的架构"><a href="#列出可用的架构" class="headerlink" title="列出可用的架构"></a>列出可用的架构</h4><blockquote>
<p>要列出当前连接的数据库的所有架构，请使用\dn命令:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># \dn</span></span><br><span class="line">   架构模式列表</span><br><span class="line">  名称  |  拥有者  </span><br><span class="line">--------+----------</span><br><span class="line"> public | postgres</span><br><span class="line">(1 行记录)</span><br></pre></td></tr></table></figure>
<h4 id="列出可用功能"><a href="#列出可用功能" class="headerlink" title="列出可用功能"></a>列出可用功能</h4><blockquote>
<p>要列出当前数据库中的可用功能，请使用\df命令:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># \df</span></span><br><span class="line">                                                      函数列表</span><br><span class="line"> 架构模式 |           名称           | 结果数据类型 |                      参数数据类型                       | 类型 </span><br><span class="line">----------+--------------------------+--------------+---------------------------------------------------------+------</span><br><span class="line"> public   | akeys                    | text[]       | hstore                                                  | 函数</span><br><span class="line"> public   | avals                    | text[]       | hstore                                                  | 函数</span><br><span class="line"> public   | defined                  | boolean      | hstore, text                                            | 函数</span><br><span class="line"> public   | delete                   | hstore       | hstore, hstore                                          | 函数</span><br><span class="line"> public   | delete                   | hstore       | hstore, text                                            | 函数</span><br><span class="line"> public   | delete                   | hstore       | hstore, text[]                                          | 函数</span><br><span class="line"> public   | each                     | SETOF record | hs hstore, OUT key text, OUT value text                 | 函数</span><br><span class="line"> public   | exist                    | boolean      | hstore, text                                            | 函数</span><br><span class="line"> public   | exists_all               | boolean      | hstore, text[]                                          | 函数</span><br><span class="line"> public   | exists_any               | boolean      | hstore, text[]                                          | 函数</span><br><span class="line"> public   | fetchval                 | text         | hstore, text                                            | 函数</span><br><span class="line"> public   | ghstore_compress         | internal     | internal                                                | 函数</span><br><span class="line"> public   | ghstore_consistent       | boolean      | internal, hstore, smallint, oid, internal               | 函数</span><br><span class="line"> public   | ghstore_decompress       | internal     | internal                                                | 函数</span><br><span class="line"> public   | ghstore_in               | ghstore      | cstring                                                 | 函数</span><br><span class="line"> public   | ghstore_out              | cstring      | ghstore                                                 | 函数</span><br><span class="line"> public   | ghstore_penalty          | internal     | internal, internal, internal                            | 函数</span><br><span class="line"> public   | ghstore_picksplit        | internal     | internal, internal                                      | 函数</span><br><span class="line"> public   | ghstore_same             | internal     | ghstore, ghstore, internal                              | 函数</span><br><span class="line"> public   | ghstore_union            | ghstore      | internal, internal                                      | 函数</span><br><span class="line"> public   | gin_consistent_hstore    | boolean      | internal, smallint, hstore, <span class="built_in">integer</span>, internal, internal | 函数</span><br><span class="line"> public   | gin_extract_hstore       | internal     | hstore, internal                                        | 函数</span><br><span class="line"> public   | gin_extract_hstore_query | internal     | hstore, internal, smallint, internal, internal          | 函数</span><br><span class="line"> public   | hs_concat                | hstore       | hstore, hstore                                          | 函数</span><br><span class="line"> public   | hs_contained             | boolean      | hstore, hstore                                          | 函数</span><br><span class="line"> public   | hs_contains              | boolean      | hstore, hstore                                          | 函数</span><br><span class="line"> public   | hstore                   | hstore       | record                                                  | 函数</span><br><span class="line"> public   | hstore                   | hstore       | text[]                                                  | 函数</span><br><span class="line"> public   | hstore                   | hstore       | text, text                                              | 函数</span><br><span class="line"> public   | hstore                   | hstore       | text[], text[]                                          | 函数</span><br><span class="line"> public   | hstore_cmp               | <span class="built_in">integer</span>      | hstore, hstore                                          | 函数</span><br><span class="line"> public   | hstore_eq                | boolean      | hstore, hstore                                          | 函数</span><br><span class="line"> public   | hstore_ge                | boolean      | hstore, hstore                                          | 函数</span><br><span class="line"> public   | hstore_gt                | boolean      | hstore, hstore                                          | 函数</span><br><span class="line"> public   | hstore_hash              | <span class="built_in">integer</span>      | hstore                                                  | 函数</span><br><span class="line"> public   | hstore_hash_extended     | bigint       | hstore, bigint                                          | 函数</span><br><span class="line"> public   | hstore_in                | hstore       | cstring                                                 | 函数</span><br><span class="line"> public   | hstore_le                | boolean      | hstore, hstore                                          | 函数</span><br><span class="line"> public   | hstore_lt                | boolean      | hstore, hstore                                          | 函数</span><br><span class="line"> public   | hstore_ne                | boolean      | hstore, hstore                                          | 函数</span><br><span class="line"> public   | hstore_out               | cstring      | hstore                                                  | 函数</span><br><span class="line"> public   | hstore_recv              | hstore       | internal                                                | 函数</span><br><span class="line"> public   | hstore_send              | bytea        | hstore                                                  | 函数</span><br><span class="line"> public   | hstore_to_array          | text[]       | hstore                                                  | 函数</span><br><span class="line"> public   | hstore_to_json           | json         | hstore                                                  | 函数</span><br><span class="line"> public   | hstore_to_json_loose     | json         | hstore                                                  | 函数</span><br><span class="line"> public   | hstore_to_jsonb          | jsonb        | hstore                                                  | 函数</span><br><span class="line"> public   | hstore_to_jsonb_loose    | jsonb        | hstore                                                  | 函数</span><br><span class="line"> public   | hstore_to_matrix         | text[]       | hstore                                                  | 函数</span><br><span class="line"> public   | hstore_version_diag      | <span class="built_in">integer</span>      | hstore                                                  | 函数</span><br><span class="line"> public   | isdefined                | boolean      | hstore, text                                            | 函数</span><br><span class="line"> public   | isexists                 | boolean      | hstore, text                                            | 函数</span><br><span class="line"> public   | populate_record          | anyelement   | anyelement, hstore                                      | 函数</span><br><span class="line"> public   | skeys                    | SETOF text   | hstore                                                  | 函数</span><br><span class="line"> public   | slice                    | hstore       | hstore, text[]                                          | 函数</span><br><span class="line"> public   | slice_array              | text[]       | hstore, text[]                                          | 函数</span><br><span class="line"> public   | svals                    | SETOF text   | hstore                                                  | 函数</span><br><span class="line"> public   | tconvert                 | hstore       | text, text                                              | 函数</span><br><span class="line">(58 行记录)</span><br></pre></td></tr></table></figure>
<h4 id="列出可用的视图"><a href="#列出可用的视图" class="headerlink" title="列出可用的视图"></a>列出可用的视图</h4><blockquote>
<p>要列出当前数据库中的可用视图，请使用\dv命令:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># \dv</span></span><br><span class="line">                        关联列表</span><br><span class="line"> 架构模式 |            名称            | 类型 |  拥有者  </span><br><span class="line">----------+----------------------------+------+----------</span><br><span class="line"> public   | actor_info                 | 视图 | postgres</span><br><span class="line"> public   | city_a                     | 视图 | <span class="built_in">test</span></span><br><span class="line"> public   | city_a_usa                 | 视图 | <span class="built_in">test</span></span><br><span class="line"> public   | count                      | 视图 | <span class="built_in">test</span></span><br><span class="line"> public   | cust_data                  | 视图 | <span class="built_in">test</span></span><br><span class="line"> public   | customer_list              | 视图 | postgres</span><br><span class="line"> public   | film_list                  | 视图 | postgres</span><br><span class="line"> public   | nicer_but_slower_film_list | 视图 | postgres</span><br><span class="line"> public   | sales_by_film_category     | 视图 | postgres</span><br><span class="line"> public   | sales_by_store             | 视图 | postgres</span><br><span class="line"> public   | staff_list                 | 视图 | postgres</span><br><span class="line"> public   | usa_city                   | 视图 | <span class="built_in">test</span></span><br><span class="line">(12 行记录)</span><br></pre></td></tr></table></figure>
<h4 id="列出用户及其角色"><a href="#列出用户及其角色" class="headerlink" title="列出用户及其角色"></a>列出用户及其角色</h4><blockquote>
<p>要列出所有用户及其分配角色，请使用\du命令：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># \du</span></span><br><span class="line">                                        角色列表</span><br><span class="line"> 角色名称 |                    属性                    |            成员属于             </span><br><span class="line">----------+--------------------------------------------+---------------------------------</span><br><span class="line"> postgres | 超级用户, 建立角色, 建立 DB, 复制, 绕过RLS | &#123;&#125;</span><br><span class="line"> root     |                                            | &#123;&#125;</span><br><span class="line"> <span class="built_in">test</span>     |                                            | &#123;pg_read_server_files,postgres&#125;</span><br><span class="line"> wzj      | 无法登录                                  +| &#123;zhi&#125;</span><br><span class="line">          | 密码有效直至2020-01-01 00:00:00+08         | </span><br><span class="line"> zhi      |                                            | &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行上一个命令"><a href="#执行上一个命令" class="headerlink" title="执行上一个命令"></a>执行上一个命令</h4><blockquote>
<p>查看数据库版本:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT version();</span></span><br><span class="line">                                                 version                                                 </span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line"> PostgreSQL 12.1 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39), 64-bit</span><br><span class="line">(1 行记录)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用\g命令执行上一个命令：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># \g</span></span><br><span class="line">                                                 version                                                 </span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line"> PostgreSQL 12.1 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39), 64-bit</span><br><span class="line">(1 行记录)</span><br></pre></td></tr></table></figure>
<h4 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h4><blockquote>
<p>要显示命令历史记录，请使用\s命令:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># \s</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要将命令历史记录保存到文件，则需要按照\s命令指定文件名，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\s filename</span><br></pre></td></tr></table></figure>
<h4 id="从文件执行psql命令"><a href="#从文件执行psql命令" class="headerlink" title="从文件执行psql命令"></a>从文件执行psql命令</h4><blockquote>
<p>如果要从文件执行psql命令，请使用\i命令，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\i filename</span><br></pre></td></tr></table></figure>
<h4 id="获取有关psql命令的帮助"><a href="#获取有关psql命令的帮助" class="headerlink" title="获取有关psql命令的帮助"></a>获取有关psql命令的帮助</h4><blockquote>
<p>要知道所有可用的psql命令，请使用\？命令:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\?</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要获得有关特定PostgreSQL语句的帮助，请使用\h命令。例如，如果想了解有关ALTER TABLE语句的详细信息，请使用以下命令：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># \h ALTER TABLE</span></span><br></pre></td></tr></table></figure>
<h4 id="打开查询执行时间"><a href="#打开查询执行时间" class="headerlink" title="打开查询执行时间"></a>打开查询执行时间</h4><blockquote>
<p>要打开查询执行时间，请使用\timing命令:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># \timing</span></span><br><span class="line">启用计时功能.</span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># select count(*) from film;</span></span><br><span class="line"> count </span><br><span class="line">-------</span><br><span class="line">  1000</span><br><span class="line">(1 行记录)</span><br><span class="line"></span><br><span class="line">时间：2.967 ms</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可使用相同的命令\timing将其关闭:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># \timing</span></span><br><span class="line">停止计时功能.</span><br></pre></td></tr></table></figure>
<h4 id="开关输出选项"><a href="#开关输出选项" class="headerlink" title="开关输出选项"></a>开关输出选项</h4><blockquote>
<p>psql支持某些类型的输出格式，并允您自定义输出格式的动态格式:</p>
<ul>
<li>\a 命令从对齐的列输出切换为非对齐的列输出。</li>
</ul>
<ul>
<li>\H 命令将输出格式化为HTML格式。</li>
</ul>
</blockquote>
<h4 id="退出psql"><a href="#退出psql" class="headerlink" title="退出psql"></a>退出psql</h4><blockquote>
<p>要退出psql，请使用\q命令，然后按Enter键退出psql:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure>
<h3 id="PostgreSQL描述表"><a href="#PostgreSQL描述表" class="headerlink" title="PostgreSQL描述表"></a>PostgreSQL描述表</h3><blockquote>
<p>如果使用MySQL，则使用DESCRIBE语句在特定表的列上查找信息。PostgreSQL不提供DESCRIBE 语句。但是，可以通过两种方法查询有关表列的信息:</p>
</blockquote>
<h4 id="使用psql的DESCRIBE-TABLE"><a href="#使用psql的DESCRIBE-TABLE" class="headerlink" title="使用psql的DESCRIBE TABLE"></a>使用psql的DESCRIBE TABLE</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># \d city</span></span><br><span class="line">                                          数据表 <span class="string">"public.city"</span></span><br><span class="line">    栏位     |            类型             | 校对规则 |  可空的  |                 预设                  </span><br><span class="line">-------------+-----------------------------+----------+----------+---------------------------------------</span><br><span class="line"> city_id     | <span class="built_in">integer</span>                     |          | not null | nextval(<span class="string">'city_city_id_seq'</span>::regclass)</span><br><span class="line"> city        | character varying(50)       |          | not null | </span><br><span class="line"> country_id  | smallint                    |          | not null | </span><br><span class="line"> last_update | timestamp without time zone |          | not null | now()</span><br><span class="line">索引：</span><br><span class="line">    <span class="string">"city_pkey"</span> PRIMARY KEY, btree (city_id)</span><br><span class="line">    <span class="string">"idx_fk_country_id"</span> btree (country_id)</span><br><span class="line">外部键(FK)限制：</span><br><span class="line">    <span class="string">"fk_city"</span> FOREIGN KEY (country_id) REFERENCES country(country_id)</span><br><span class="line">由引用：</span><br><span class="line">    TABLE <span class="string">"address"</span> CONSTRAINT <span class="string">"fk_address_city"</span> FOREIGN KEY (city_id) REFERENCES city(city_id)</span><br><span class="line">触发器：</span><br><span class="line">    last_updated BEFORE UPDATE ON city FOR EACH ROW EXECUTE FUNCTION last_updated()</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># \d+ city</span></span><br><span class="line">                                                         数据表 <span class="string">"public.city"</span></span><br><span class="line">    栏位     |            类型             | 校对规则 |  可空的  |                 预设                  |   存储   | 统计目标 | 描述 </span><br><span class="line">-------------+-----------------------------+----------+----------+---------------------------------------+----------+----------+------</span><br><span class="line"> city_id     | <span class="built_in">integer</span>                     |          | not null | nextval(<span class="string">'city_city_id_seq'</span>::regclass) | plain    |          | </span><br><span class="line"> city        | character varying(50)       |          | not null |                                       | extended |          | </span><br><span class="line"> country_id  | smallint                    |          | not null |                                       | plain    |          | </span><br><span class="line"> last_update | timestamp without time zone |          | not null | now()                                 | plain    |          | </span><br><span class="line">索引：</span><br><span class="line">    <span class="string">"city_pkey"</span> PRIMARY KEY, btree (city_id)</span><br><span class="line">    <span class="string">"idx_fk_country_id"</span> btree (country_id)</span><br><span class="line">外部键(FK)限制：</span><br><span class="line">    <span class="string">"fk_city"</span> FOREIGN KEY (country_id) REFERENCES country(country_id)</span><br><span class="line">由引用：</span><br><span class="line">    TABLE <span class="string">"address"</span> CONSTRAINT <span class="string">"fk_address_city"</span> FOREIGN KEY (city_id) REFERENCES city(city_id)</span><br><span class="line">触发器：</span><br><span class="line">    last_updated BEFORE UPDATE ON city FOR EACH ROW EXECUTE FUNCTION last_updated()</span><br><span class="line">访问方法 heap</span><br></pre></td></tr></table></figure>
<h4 id="使用information-schema的DESCRIBE-TABLE"><a href="#使用information-schema的DESCRIBE-TABLE" class="headerlink" title="使用information_schema的DESCRIBE TABLE"></a>使用information_schema的DESCRIBE TABLE</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   COLUMN_NAME</span><br><span class="line">FROM</span><br><span class="line">   information_schema.COLUMNS</span><br><span class="line">WHERE</span><br><span class="line">   TABLE_NAME = <span class="string">'city'</span>;</span><br><span class="line"> column_name</span><br><span class="line">-------------</span><br><span class="line"> city_id</span><br><span class="line"> city</span><br><span class="line"> country_id</span><br><span class="line"> last_update</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><blockquote>
<p>在MySQL中，可以使用SHOW DATABASES语句显示数据库服务器中的所有数据库。PostgreSQL不直接提供此语句，而是提供了两种显示数据库的方式。</p>
</blockquote>
<h4 id="使用psql工具列出数据库"><a href="#使用psql工具列出数据库" class="headerlink" title="使用psql工具列出数据库"></a>使用psql工具列出数据库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># \l</span></span><br><span class="line">                                     数据库列表</span><br><span class="line">   名称    |  拥有者  | 字元编码 |  校对规则   |    Ctype    |       存取权限        </span><br><span class="line">-----------+----------+----------+-------------+-------------+-----------------------</span><br><span class="line"> postgres  | postgres | UTF8     | zh_CN.UTF-8 | zh_CN.UTF-8 | </span><br><span class="line"> template0 | postgres | UTF8     | zh_CN.UTF-8 | zh_CN.UTF-8 | =c/postgres          +</span><br><span class="line">           |          |          |             |             | postgres=CTc/postgres</span><br><span class="line"> template1 | postgres | UTF8     | zh_CN.UTF-8 | zh_CN.UTF-8 | =c/postgres          +</span><br><span class="line">           |          |          |             |             | postgres=CTc/postgres</span><br><span class="line"> <span class="built_in">test</span>      | <span class="built_in">test</span>     | UTF8     | zh_CN.UTF-8 | zh_CN.UTF-8 | =Tc/<span class="built_in">test</span>             +</span><br><span class="line">           |          |          |             |             | <span class="built_in">test</span>=CTc/<span class="built_in">test</span></span><br><span class="line">(4 行记录)</span><br></pre></td></tr></table></figure>
<h4 id="使用SELECT语句列出数据库"><a href="#使用SELECT语句列出数据库" class="headerlink" title="使用SELECT语句列出数据库"></a>使用SELECT语句列出数据库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   datname</span><br><span class="line">FROM</span><br><span class="line">   pg_database;</span><br><span class="line">  datname</span><br><span class="line">-----------</span><br><span class="line"> postgres</span><br><span class="line"> template1</span><br><span class="line"> template0</span><br><span class="line"> <span class="built_in">test</span></span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<h3 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h3><blockquote>
<p>在MySQL中，可以使用SHOW TABLES语句显示数据库服务器中的所有表。PostgreSQL不直接提供此语句，而是提供了两种显示表的方式。</p>
</blockquote>
<h4 id="使用psql显示表"><a href="#使用psql显示表" class="headerlink" title="使用psql显示表"></a>使用psql显示表</h4><blockquote>
<p>如果使用的是psql，则可以使用以下命令显示当前数据库中的表:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># \dt</span></span><br><span class="line">                关联列表</span><br><span class="line"> 架构模式 |   名称   |  类型  |  拥有者  </span><br><span class="line">----------+----------+--------+----------</span><br><span class="line"> public   | books    | 数据表 | postgres</span><br><span class="line"> public   | contacts | 数据表 | postgres</span><br><span class="line">(2 行记录)</span><br></pre></td></tr></table></figure>
<h4 id="使用pg-catalog模式显示表"><a href="#使用pg-catalog模式显示表" class="headerlink" title="使用pg_catalog模式显示表"></a>使用pg_catalog模式显示表</h4><blockquote>
<p>在PostgreSQL中显示表的另一种方法是使用SELECT语句从PostgreSQL目录中查询数据，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   pg_catalog.pg_tables</span><br><span class="line">WHERE</span><br><span class="line">   schemaname != <span class="string">'pg_catalog'</span></span><br><span class="line">AND schemaname != <span class="string">'information_schema'</span>;</span><br><span class="line"> schemaname | tablename | tableowner | tablespace | hasindexes | hasrules | hastriggers | rowsecurity</span><br><span class="line">------------+-----------+------------+------------+------------+----------+-------------+-------------</span><br><span class="line"> public     | contacts  | postgres   |            | t          | f        | f           | f</span><br><span class="line"> public     | books     | postgres   |            | t          | f        | f           | f</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h2 id="比较两个表中的数据"><a href="#比较两个表中的数据" class="headerlink" title="比较两个表中的数据"></a>比较两个表中的数据</h2><h3 id="使用EXCEPT和UNION运算符比较两个表"><a href="#使用EXCEPT和UNION运算符比较两个表" class="headerlink" title="使用EXCEPT和UNION运算符比较两个表"></a>使用EXCEPT和UNION运算符比较两个表</h3><blockquote>
<p>首先，创建两个具有相同结构和数据的表:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE foo (</span></span><br><span class="line">   ID INT PRIMARY KEY,</span><br><span class="line">   NAME VARCHAR (50)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO foo (ID, NAME)</span></span><br><span class="line">VALUES</span><br><span class="line">   (1, <span class="string">'a'</span>),</span><br><span class="line">   (2, <span class="string">'b'</span>);</span><br><span class="line">INSERT 0 2</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE bar (</span></span><br><span class="line">   ID INT PRIMARY KEY,</span><br><span class="line">   NAME VARCHAR (50)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO bar (ID, NAME)</span></span><br><span class="line">VALUES</span><br><span class="line">   (1, <span class="string">'a'</span>),</span><br><span class="line">   (2, <span class="string">'b'</span>);</span><br><span class="line">INSERT 0 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接下来，更新表bar中的一行:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE bar</span></span><br><span class="line">SET name = <span class="string">'c'</span></span><br><span class="line">WHERE</span><br><span class="line">   id = 2;</span><br><span class="line">UPDATE 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后，要查找foo表而不是bar表中的行，我们使用以下查询：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   ID,</span><br><span class="line">   NAME,</span><br><span class="line">   <span class="string">'not in bar'</span> AS note</span><br><span class="line">FROM</span><br><span class="line">   foo</span><br><span class="line">EXCEPT</span><br><span class="line">   SELECT</span><br><span class="line">      ID,</span><br><span class="line">      NAME,</span><br><span class="line">      <span class="string">'not in bar'</span> AS note</span><br><span class="line">   FROM</span><br><span class="line">      bar;</span><br><span class="line"> id | name |    note</span><br><span class="line">----+------+------------</span><br><span class="line">  2 | b    | not <span class="keyword">in</span> bar</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们使用EXCEPT运算符返回foo表中的行，而不返回bar表中的行。如下使用相同语法查找bar表中而不是foo表中的行:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   ID,</span><br><span class="line">   NAME,</span><br><span class="line">   <span class="string">'not in foo'</span> AS note</span><br><span class="line">FROM</span><br><span class="line">   bar</span><br><span class="line">EXCEPT</span><br><span class="line">   SELECT</span><br><span class="line">      ID,</span><br><span class="line">      NAME,</span><br><span class="line">      <span class="string">'not in foo'</span> AS note</span><br><span class="line">   FROM</span><br><span class="line">      foo;</span><br><span class="line"> id | name |    note</span><br><span class="line">----+------+------------</span><br><span class="line">  2 | c    | not <span class="keyword">in</span> foo</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用OUTER JOIN比较两个表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   id,</span><br><span class="line">   name</span><br><span class="line">FROM</span><br><span class="line">   foo</span><br><span class="line">FULL OUTER JOIN bar USING (id, name)</span><br><span class="line">WHERE</span><br><span class="line">   foo.id IS NULL</span><br><span class="line">OR bar.id IS NULL;</span><br><span class="line"> id | name</span><br><span class="line">----+------</span><br><span class="line">  2 | b</span><br><span class="line">  2 | c</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h3 id="删除重复的行"><a href="#删除重复的行" class="headerlink" title="删除重复的行"></a>删除重复的行</h3><blockquote>
<p>创建示例表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE sg(</span></span><br><span class="line">    id SERIAL PRIMARY KEY,</span><br><span class="line">    fruit VARCHAR(50) NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO sg(fruit) values('apple');</span></span><br><span class="line">INSERT INTO sg(fruit) values(<span class="string">'apple'</span>);</span><br><span class="line"> </span><br><span class="line">INSERT INTO sg(fruit) values(<span class="string">'orange'</span>);</span><br><span class="line">INSERT INTO sg(fruit) values(<span class="string">'orange'</span>);</span><br><span class="line">INSERT INTO sg(fruit) values(<span class="string">'orange'</span>);</span><br><span class="line"> </span><br><span class="line">INSERT INTO sg(fruit) values(<span class="string">'banana'</span>);</span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    id,</span><br><span class="line">    fruit</span><br><span class="line">FROM</span><br><span class="line">    sg;</span><br><span class="line"> id | fruit</span><br><span class="line">----+--------</span><br><span class="line">  1 | apple</span><br><span class="line">  2 | apple</span><br><span class="line">  3 | orange</span><br><span class="line">  4 | orange</span><br><span class="line">  5 | orange</span><br><span class="line">  6 | banana</span><br><span class="line">(6 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果表中的行很少，则可以立即看到哪些行重复。但是，大表并非如此。找到重复的行，可使用以下语句： </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    fruit,</span><br><span class="line">    COUNT( fruit )</span><br><span class="line">FROM</span><br><span class="line">    sg</span><br><span class="line">GROUP BY</span><br><span class="line">    fruit</span><br><span class="line">HAVING</span><br><span class="line">    COUNT( fruit )&gt; 1</span><br><span class="line">ORDER BY</span><br><span class="line">    fruit;</span><br><span class="line"> fruit  | count</span><br><span class="line">--------+-------</span><br><span class="line"> apple  |     2</span><br><span class="line"> orange |     3</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用DELETE USING语句删除重复的行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DELETE</span></span><br><span class="line">FROM</span><br><span class="line">    sg  a</span><br><span class="line">        USING sg b</span><br><span class="line">WHERE</span><br><span class="line">    a.id &lt; b.id</span><br><span class="line">    AND a.fruit = b.fruit;</span><br><span class="line">DELETE 3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此示例中，我们将sg表与其自身相连，并检查了fruit 列中两个不同的行（a.id &lt;b.id）是否具有相同的值。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    id,</span><br><span class="line">    fruit</span><br><span class="line">FROM</span><br><span class="line">    sg;</span><br><span class="line"> id | fruit</span><br><span class="line">----+--------</span><br><span class="line">  2 | apple</span><br><span class="line">  5 | orange</span><br><span class="line">  6 | banana</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该语句删除了ID最少的重复行，并保留了ID最高的行。如果要保留具有最低id的重复行，则只需在WHERE子句中翻转运算符即可：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DELETE</span></span><br><span class="line">FROM</span><br><span class="line">    sg  a</span><br><span class="line">        USING sg b</span><br><span class="line">WHERE</span><br><span class="line">    a.id &gt; b.id</span><br><span class="line">    AND a.fruit = b.fruit;</span><br></pre></td></tr></table></figure>
<h3 id="使用子查询删除重复的行"><a href="#使用子查询删除重复的行" class="headerlink" title="使用子查询删除重复的行"></a>使用子查询删除重复的行</h3><blockquote>
<p>以下语句使用suquery删除重复的行，并保留具有最低ID的行:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DELETE FROM sg</span></span><br><span class="line">WHERE id IN</span><br><span class="line">    (SELECT id</span><br><span class="line">    FROM</span><br><span class="line">        (SELECT id,</span><br><span class="line">         ROW_NUMBER() OVER( PARTITION BY fruit</span><br><span class="line">        ORDER BY  id ) AS row_num</span><br><span class="line">        FROM sg ) t</span><br><span class="line">        WHERE t.row_num &gt; 1 );</span><br><span class="line">DELETE 3</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    id,</span><br><span class="line">    fruit</span><br><span class="line">FROM</span><br><span class="line">    sg;</span><br><span class="line"> id | fruit</span><br><span class="line">----+--------</span><br><span class="line">  1 | apple</span><br><span class="line">  3 | orange</span><br><span class="line">  6 | banana</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此的示例子查询返回重复的行，重复组中的第一行除外。并且外部DELETE语句删除了子查询返回的重复行。</p>
</blockquote>
<blockquote>
<p>如果要保留具有最高ID的重复行，只需在子查询中更改顺序：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM sg</span><br><span class="line">WHERE id IN</span><br><span class="line">    (SELECT id</span><br><span class="line">    FROM</span><br><span class="line">        (SELECT id,</span><br><span class="line">         ROW_NUMBER() OVER( PARTITION BY fruit</span><br><span class="line">        ORDER BY  id DESC ) AS row_num</span><br><span class="line">        FROM sg ) t</span><br><span class="line">        WHERE t.row_num &gt; 1 );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要基于多个列的值删除重复项，则以下是查询模板：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name</span><br><span class="line">WHERE id IN</span><br><span class="line">    (SELECT id</span><br><span class="line">    FROM</span><br><span class="line">        (SELECT id,</span><br><span class="line">         ROW_NUMBER() OVER( PARTITION BY column_1,</span><br><span class="line">         column_2</span><br><span class="line">        ORDER BY  id ) AS row_num</span><br><span class="line">        FROM table_name ) t</span><br><span class="line">        WHERE t.row_num &gt; 1 );</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line">+ 在这种情况下，该语句将删除column_1和column_2列中所有具有重复值的行。</span><br><span class="line"></span><br><span class="line"><span class="comment">## 生成特定范围内的随机数</span></span><br><span class="line">&gt; PostgreSQL提供了random()函数，该函数返回0到1之间的随机数。以下语句返回0到1之间的随机数:</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT random();</span></span><br><span class="line">       random</span><br><span class="line">---------------------</span><br><span class="line"> 0.38380355708888203</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要生成1到10之间的随机数，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT random() * 9 + 1 AS RAND_1_10;</span></span><br><span class="line">     rand_1_10</span><br><span class="line">-------------------</span><br><span class="line"> 8.934232181654593</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要将随机数生成为整数，请按以下方式将floor()函数应用于表达式：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT floor(random() * 10 + 1)::int;</span></span><br><span class="line"> floor</span><br><span class="line">-------</span><br><span class="line">     7</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常，要生成两个整数l和h之间的随机数，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT floor(random() * (h<span class="_">-l</span>+1) + l)::int;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如下函数返回两个数字l和h之间的随机数：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE FUNCTION random_between(low INT ,high INT)</span></span><br><span class="line">   RETURNS INT AS</span><br><span class="line">$$</span><br><span class="line">BEGIN</span><br><span class="line">   RETURN floor(random()* (high-low + 1) + low);</span><br><span class="line">END;</span><br><span class="line">$$ language <span class="string">'plpgsql'</span> STRICT;</span><br><span class="line">CREATE FUNCTION</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用random_between()函数并返回1到100之间的随机数:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT random_between(1,100);</span></span><br><span class="line"> random_between</span><br><span class="line">----------------</span><br><span class="line">              9</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要获取两个整数之间的多个随机数，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT random_between(1,100)</span></span><br><span class="line">FROM generate_series(1,5);</span><br><span class="line"> random_between</span><br><span class="line">----------------</span><br><span class="line">             65</span><br><span class="line">             75</span><br><span class="line">             20</span><br><span class="line">             59</span><br><span class="line">             46</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure>
<h2 id="EXPLAIN语句"><a href="#EXPLAIN语句" class="headerlink" title="EXPLAIN语句"></a>EXPLAIN语句</h2><blockquote>
<p>EXPLAIN语句返回PostgreSQL计划程序为给定语句生成的执行计划。</p>
</blockquote>
<blockquote>
<p>EXPLAIN函数显示如何通过索引扫描或顺序扫描等方式扫描语句中涉及的表，并且如果使用多个表，将使用哪种连接算法。</p>
</blockquote>
<blockquote>
<p>下面显示了EXPLAIN语句的语法：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN [ ( option [, ...] ) ] sql_statement;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中option可以是以下之一：</p>
<ul>
<li>ANALYZE [ boolean ]</li>
</ul>
<ul>
<li>VERBOSE [ boolean ]</li>
</ul>
<ul>
<li>COSTS [ boolean ]</li>
</ul>
<ul>
<li>BUFFERS [ boolean ]</li>
</ul>
<ul>
<li>TIMING [ boolean ]  </li>
</ul>
<ul>
<li>SUMMARY [ boolean ]</li>
</ul>
<ul>
<li>FORMAT { TEXT | XML | JSON | YAML }</li>
</ul>
</blockquote>
<blockquote>
<p>布尔值指定是打开还是关闭选定的选项。可以使用TRUE，ON或1启用该选项，并使用FALSE，OFF或0禁用该选项。如果省略布尔值，则默认为ON。</p>
</blockquote>
<h3 id="ANALYZE"><a href="#ANALYZE" class="headerlink" title="ANALYZE"></a>ANALYZE</h3><blockquote>
<p>ANALYZE选项使sql_statement首先执行，然后在返回的信息中执行实际的运行时统计信息，包括在每个计划节点内花费的总经过时间以及它实际返回的行数。</p>
</blockquote>
<blockquote>
<p>ANALYZE语句实际上执行SQL语句并丢弃输出信息，因此，如果要分析任何INSERT，UPDATE或DELETE之类的更新语句而不影响数据，则应将EXPLAIN ANALYZE包装在事务中，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">    EXPLAIN ANALYZE sql_statement;</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>
<h3 id="VERBOSE"><a href="#VERBOSE" class="headerlink" title="VERBOSE"></a>VERBOSE</h3><blockquote>
<p>VERBOSE参数显示有关计划的其他信息。默认情况下，此参数设置为FALSE。</p>
</blockquote>
<h3 id="COSTS"><a href="#COSTS" class="headerlink" title="COSTS"></a>COSTS</h3><blockquote>
<p>COSTS选项包括每个计划节点的估计启动成本和总成本，以及查询计划中估计的行数和估计的每行宽度。COSTS默认为TRUE。</p>
</blockquote>
<h3 id="BUFFERS"><a href="#BUFFERS" class="headerlink" title="BUFFERS"></a>BUFFERS</h3><blockquote>
<p>此参数将信息添加到缓冲区使用情况。只有在启用ANALYZE的情况下才能使用BUFFERS。默认情况下，BUFFERS参数设置为FALSE。</p>
</blockquote>
<h3 id="TIMING"><a href="#TIMING" class="headerlink" title="TIMING"></a>TIMING</h3><blockquote>
<p>此参数包括实际的启动时间以及在输出中每个节点上花费的时间。TIMING默认为TRUE，并且仅在启用ANALYZE时才可以使用。</p>
</blockquote>
<h3 id="SUMMARY"><a href="#SUMMARY" class="headerlink" title="SUMMARY"></a>SUMMARY</h3><blockquote>
<p>Summary参数在查询计划之后添加摘要信息，例如总时间。请注意，使用ANALYZE选项时，默认情况下包括摘要信息。</p>
</blockquote>
<h3 id="FORMAT"><a href="#FORMAT" class="headerlink" title="FORMAT"></a>FORMAT</h3><blockquote>
<p>指定查询计划的输出格式，例如TEXT、XML、JSON和YAML。默认情况下，此参数设置为TEXT。</p>
</blockquote>
<h3 id="EXPLAIN示例"><a href="#EXPLAIN示例" class="headerlink" title="EXPLAIN示例"></a>EXPLAIN示例</h3><blockquote>
<p>显示在film表上进行简单查询的计划：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># EXPLAIN SELECT * FROM film;</span></span><br><span class="line">                        QUERY PLAN</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"> Seq Scan on film  (cost=0.00..64.00 rows=1000 width=384)</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">EXPLAIN</span><br></pre></td></tr></table></figure>
<blockquote>
<p>按特定的film_id返回电影</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># EXPLAIN SELECT * FROM film WHERE film_id = 100;</span></span><br><span class="line">                               QUERY PLAN</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"> Index Scan using film_pkey on film  (cost=0.28..8.29 rows=1 width=384)</span><br><span class="line">   Index Cond: (film_id = 100)</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">EXPLAIN</span><br></pre></td></tr></table></figure>
<ul>
<li>由于film_id已建立索引，因此该语句返回了另一个计划。在输出中，计划人员使用索引扫描而不是film表上的顺序扫描。</li>
</ul>
<blockquote>
<p>为了降低成本，可以使用COSTS选项：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># EXPLAIN (COSTS FALSE) SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    film</span><br><span class="line">WHERE</span><br><span class="line">    film_id = 100;</span><br><span class="line">             QUERY PLAN</span><br><span class="line">------------------------------------</span><br><span class="line"> Index Scan using film_pkey on film</span><br><span class="line">   Index Cond: (film_id = 100)</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">EXPLAIN</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为连接多个表的语句返回计划：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># EXPLAIN</span></span><br><span class="line">SELECT</span><br><span class="line">    f.film_id,</span><br><span class="line">    title,</span><br><span class="line">    name category_name</span><br><span class="line">FROM</span><br><span class="line">    film f</span><br><span class="line">    INNER JOIN film_category <span class="built_in">fc</span></span><br><span class="line">        ON fc.film_id = f.film_id</span><br><span class="line">    INNER JOIN category c</span><br><span class="line">        ON c.category_id = fc.category_id</span><br><span class="line">ORDER BY</span><br><span class="line">    title;</span><br><span class="line">                                      QUERY PLAN</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"> Sort  (cost=149.64..152.14 rows=1000 width=87)</span><br><span class="line">   Sort Key: f.title</span><br><span class="line">   -&gt;  Hash Join  (cost=77.86..99.81 rows=1000 width=87)</span><br><span class="line">         Hash Cond: (fc.category_id = c.category_id)</span><br><span class="line">         -&gt;  Hash Join  (cost=76.50..95.14 rows=1000 width=21)</span><br><span class="line">               Hash Cond: (fc.film_id = f.film_id)</span><br><span class="line">               -&gt;  Seq Scan on film_category <span class="built_in">fc</span>  (cost=0.00..16.00 rows=1000 width=4)</span><br><span class="line">               -&gt;  Hash  (cost=64.00..64.00 rows=1000 width=19)</span><br><span class="line">                     -&gt;  Seq Scan on film f  (cost=0.00..64.00 rows=1000 width=19)</span><br><span class="line">         -&gt;  Hash  (cost=1.16..1.16 rows=16 width=72)</span><br><span class="line">               -&gt;  Seq Scan on category c  (cost=0.00..1.16 rows=16 width=72)</span><br><span class="line">(11 rows)</span><br><span class="line"></span><br><span class="line">EXPLAIN</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要将实际的运行时统计信息添加到输出中，使用ANALYZE选项执行该语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># EXPLAIN ANALYZE</span></span><br><span class="line">    SELECT</span><br><span class="line">        f.film_id,</span><br><span class="line">        title,</span><br><span class="line">        name category_name</span><br><span class="line">    FROM</span><br><span class="line">        film f</span><br><span class="line">        INNER JOIN film_category <span class="built_in">fc</span></span><br><span class="line">            ON fc.film_id = f.film_id</span><br><span class="line">        INNER JOIN category c</span><br><span class="line">            ON c.category_id = fc.category_id</span><br><span class="line">    ORDER BY</span><br><span class="line">        title;</span><br><span class="line">                                                            QUERY PLAN</span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> Sort  (cost=149.64..152.14 rows=1000 width=87) (actual time=11.511..11.644 rows=1000 loops=1)</span><br><span class="line">   Sort Key: f.title</span><br><span class="line">   Sort Method: quicksort  Memory: 103kB</span><br><span class="line">   -&gt;  Hash Join  (cost=77.86..99.81 rows=1000 width=87) (actual time=3.611..5.815 rows=1000 loops=1)</span><br><span class="line">         Hash Cond: (fc.category_id = c.category_id)</span><br><span class="line">         -&gt;  Hash Join  (cost=76.50..95.14 rows=1000 width=21) (actual time=3.206..4.777 rows=1000 loops=1)</span><br><span class="line">               Hash Cond: (fc.film_id = f.film_id)</span><br><span class="line">               -&gt;  Seq Scan on film_category <span class="built_in">fc</span>  (cost=0.00..16.00 rows=1000 width=4) (actual time=0.029..0.719 rows=1000 loops=1)</span><br><span class="line">               -&gt;  Hash  (cost=64.00..64.00 rows=1000 width=19) (actual time=3.132..3.133 rows=1000 loops=1)</span><br><span class="line">                     Buckets: 1024  Batches: 1  Memory Usage: 59kB</span><br><span class="line">                     -&gt;  Seq Scan on film f  (cost=0.00..64.00 rows=1000 width=19) (actual time=0.037..2.185 rows=1000 loops=1)</span><br><span class="line">         -&gt;  Hash  (cost=1.16..1.16 rows=16 width=72) (actual time=0.263..0.263 rows=16 loops=1)</span><br><span class="line">               Buckets: 1024  Batches: 1  Memory Usage: 9kB</span><br><span class="line">               -&gt;  Seq Scan on category c  (cost=0.00..1.16 rows=16 width=72) (actual time=0.231..0.238 rows=16 loops=1)</span><br><span class="line"> Planning Time: 1.419 ms</span><br><span class="line"> Execution Time: 11.909 ms</span><br><span class="line">(16 rows)</span><br><span class="line"></span><br><span class="line">EXPLAIN</span><br></pre></td></tr></table></figure>
<h2 id="PostgreSQL与MySQL"><a href="#PostgreSQL与MySQL" class="headerlink" title="PostgreSQL与MySQL"></a>PostgreSQL与MySQL</h2><table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:right">PostgreSQL</th>
<th style="text-align:center">MySQL</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">被称为</td>
<td style="text-align:right">世界上最先进的开源数据库</td>
<td style="text-align:center">世界上最受欢迎的开源数据库</td>
</tr>
<tr>
<td style="text-align:left">发展历程</td>
<td style="text-align:right">开源项目</td>
<td style="text-align:center">开源产品</td>
</tr>
<tr>
<td style="text-align:left">许可</td>
<td style="text-align:right">MIT-style许可</td>
<td style="text-align:center">GNU通用公共许可</td>
</tr>
<tr>
<td style="text-align:left">编程语言</td>
<td style="text-align:right">C</td>
<td style="text-align:center">C/C++</td>
</tr>
<tr>
<td style="text-align:left">GUI工具</td>
<td style="text-align:right">PgAdmin</td>
<td style="text-align:center">MySQL Workbench</td>
</tr>
<tr>
<td style="text-align:left">事务管理</td>
<td style="text-align:right">允许</td>
<td style="text-align:center">允许</td>
</tr>
<tr>
<td style="text-align:left">存储引擎</td>
<td style="text-align:right">单存储引擎</td>
<td style="text-align:center">多个存储引擎，如InnoDB和MyISAM</td>
</tr>
<tr>
<td style="text-align:left">全文搜索</td>
<td style="text-align:right">允许</td>
<td style="text-align:center">允许</td>
</tr>
<tr>
<td style="text-align:left">删除临时表</td>
<td style="text-align:right">DROP TABLE语句中没有TEMP或TEMPORARY关键字</td>
<td style="text-align:center">MySQL在DROP TABLE语句中支持TEMP或TEMPORARY关键字，该语句仅允许您删除临时表</td>
</tr>
<tr>
<td style="text-align:left">DROP TABLE</td>
<td style="text-align:right">支持CASCADE选项以删除表相关对象，例如表，视图等</td>
<td style="text-align:center">不支持CASCADE选项</td>
</tr>
<tr>
<td style="text-align:left">TRUNCATE TABLE</td>
<td style="text-align:right">PostgreSQL TRUNCATE TABLE支持更多功能，例如CASCADE，RESTART IDENTITY，CONTINUE IDENTITY，事务安全等。</td>
<td style="text-align:center">MySQL TRUNCATE TABLE不支持CASCADE和事务安全，即数据一旦删除，便无法回滚。</td>
</tr>
<tr>
<td style="text-align:left">自动递增</td>
<td style="text-align:right">SERIAL</td>
<td style="text-align:center">AUTO_INCREMENT</td>
</tr>
<tr>
<td style="text-align:left">分析功能</td>
<td style="text-align:right">有</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:left">数据类型</td>
<td style="text-align:right">支持许多高级类型，如数组、hstore和用户定义的类型</td>
<td style="text-align:center">SQL标准类型</td>
</tr>
<tr>
<td style="text-align:left">无符号整形</td>
<td style="text-align:right">不支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:left">布尔型</td>
<td style="text-align:right">支持</td>
<td style="text-align:center">在内部将TINYINT(1)用于布尔值</td>
</tr>
<tr>
<td style="text-align:left">IP地址数据类型</td>
<td style="text-align:right">支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:left">设置列的默认值</td>
<td style="text-align:right">支持常量和函数调用</td>
<td style="text-align:center">对于TIMESTAMP或DATETIME列，必须为常数或CURRENT_TIMESTAMP</td>
</tr>
<tr>
<td style="text-align:left">公用表表达式</td>
<td style="text-align:right">支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:left">EXPLAIN输出</td>
<td style="text-align:right">详细</td>
<td style="text-align:center">详细</td>
</tr>
<tr>
<td style="text-align:left">实体化视图</td>
<td style="text-align:right">支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:left">检查约束</td>
<td style="text-align:right">支持</td>
<td style="text-align:center">MySQL忽略CHECK约束</td>
</tr>
<tr>
<td style="text-align:left">表继承</td>
<td style="text-align:right">支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:left">存储过程的编程语言</td>
<td style="text-align:right">Ruby、Perl、Python、TCL、PL/pgSQL、SQL、JavaScript等</td>
<td style="text-align:center">数据库标准SQL2003相关存储过程语法</td>
</tr>
<tr>
<td style="text-align:left">FULL OUTER JOIN</td>
<td style="text-align:right">支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:left">INTERSECT</td>
<td style="text-align:right">支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:left">EXCEPT</td>
<td style="text-align:right">支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:left">部分索引</td>
<td style="text-align:right">支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:left">位图索引</td>
<td style="text-align:right">支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:left">表达式索引</td>
<td style="text-align:right">支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:left">覆盖索引</td>
<td style="text-align:right">支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:left">触发器</td>
<td style="text-align:right">支持可以在大多数命令类型上触发的触发器，但在全局范围内影响数据库的触发器除外，例如角色和表空间</td>
<td style="text-align:center">仅限于某些命令</td>
</tr>
<tr>
<td style="text-align:left">分区</td>
<td style="text-align:right">RANGE, LIST</td>
<td style="text-align:center">RANGE、LIST、HASH、KEY和组合分区，结合使用RANGE或LIST与HASH或KEY子分区</td>
</tr>
<tr>
<td style="text-align:left">任务时间表</td>
<td style="text-align:right">pgAgent</td>
<td style="text-align:center">Scheduled event</td>
</tr>
<tr>
<td style="text-align:left">连接可扩展性</td>
<td style="text-align:right">每个新连接都是一个OS进程</td>
<td style="text-align:center">每个新连接都是一个OS线程</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    
    
    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="zhijiansd.github.io/blog/pg15/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhiJian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhiJian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/pg15/" class="post-title-link" itemprop="zhijiansd.github.io/index.html">PostgreSQL之索引</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-20 13:25:40 / 修改时间：13:27:54" itemprop="dateCreated datePublished" datetime="2020-05-20T13:25:40+08:00">2020-05-20</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/postresql/" itemprop="url" rel="index"><span itemprop="name">postresql</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/pg15/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/pg15/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">22k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">37 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="PostgreSQL索引"><a href="#PostgreSQL索引" class="headerlink" title="PostgreSQL索引"></a>PostgreSQL索引</h2><blockquote>
<p>以特定顺序组织表中存储的数据，以加快各种搜索的速度。这就是索引起作用的原因。</p>
</blockquote>
<blockquote>
<p>索引是一个单独的数据结构，例如B树，它以增加写入和存储以维持该表为代价来加快对表的数据检索速度</p>
</blockquote>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><h4 id="CREATE-INDEX语句的语法"><a href="#CREATE-INDEX语句的语法" class="headerlink" title="CREATE INDEX语句的语法"></a>CREATE INDEX语句的语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX  index_name  ON table_name</span><br><span class="line">[USING method]</span><br><span class="line">(</span><br><span class="line">    column_name [ASC | DESC] [NULLS &#123;FIRST | LAST &#125;],</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，在CREATE INDEX子句之后指定索引名称。索引名称应该有意义并且易于记忆。</li>
</ul>
<ul>
<li>其次，指定索引所属的表的名称。</li>
</ul>
<ul>
<li>第三，指定索引方法，例如btree，hash，gist，spgist，gin和brin。PostgreSQL默认使用btree。</li>
</ul>
<ul>
<li>第四，列出要存储在索引中的一列或多列。ASC和DESC指定排序顺序。默认为ASC。NULLS FIRST或NULLS LAST指定在非null之前或之后的null排序。当指定DESC时，NULLS FIRST是默认值，而当未指定DESC时，NULLS LAST是默认值。</li>
</ul>
<blockquote>
<p>要检查查询是否使用索引，请使用EXPLAIN语句。</p>
</blockquote>
<h4 id="CREATE-INDEX示例"><a href="#CREATE-INDEX示例" class="headerlink" title="CREATE INDEX示例"></a>CREATE INDEX示例</h4><blockquote>
<p>查询电话号码为223664661973的地址</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    address</span><br><span class="line">WHERE</span><br><span class="line">    phone = <span class="string">'223664661973'</span>;</span><br><span class="line"> address_id |      address       | address2 | district  | city_id | postal_code |    phone     |     last_update</span><br><span class="line">------------+--------------------+----------+-----------+---------+-------------+--------------+---------------------</span><br><span class="line">         85 | 320 Baiyin Parkway |          | Mahajanga |     319 | 37307       | 223664661973 | 2006-02-15 09:45:30</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用EXPLAIN语句显示查询计划，数据库引擎必须扫描整个address表以查找地址</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># EXPLAIN</span></span><br><span class="line">SELECT</span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    address</span><br><span class="line">WHERE</span><br><span class="line">    phone = <span class="string">'223664661973'</span>;</span><br><span class="line">                       QUERY PLAN</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"> Seq Scan on address  (cost=0.00..15.54 rows=1 width=61)</span><br><span class="line">   Filter: ((phone)::text = <span class="string">'223664661973'</span>::text)</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">EXPLAIN</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要为address表的phone栏中的值创建索引，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE INDEX idx_address_phone</span></span><br><span class="line">ON address(phone);</span><br><span class="line">CREATE INDEX</span><br></pre></td></tr></table></figure>
<blockquote>
<p>再次执行查询，现在数据库引擎使用索引进行查找</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># EXPLAIN</span></span><br><span class="line">SELECT</span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    address</span><br><span class="line">WHERE</span><br><span class="line">    phone = <span class="string">'223664661973'</span>;</span><br><span class="line">                                    QUERY PLAN</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"> Index Scan using idx_address_phone on address  (cost=0.28..8.29 rows=1 width=61)</span><br><span class="line">   Index Cond: ((phone)::text = <span class="string">'223664661973'</span>::text)</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">EXPLAIN</span><br></pre></td></tr></table></figure>
<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><h4 id="DROP-INDEX语句语法"><a href="#DROP-INDEX语句语法" class="headerlink" title="DROP INDEX语句语法"></a>DROP INDEX语句语法</h4><blockquote>
<p> INDEX语句从数据库系统中删除现有索引，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX  [ CONCURRENTLY]</span><br><span class="line">[ IF EXISTS ]  index_name</span><br><span class="line">[ CASCADE | RESTRICT ];</span><br></pre></td></tr></table></figure>
<ul>
<li>index_name:在DROP INDEX子句之后指定要删除的索引的名称。</li>
</ul>
<ul>
<li>IF EXISTS:尝试删除不存在的索引将导致错误。为避免这种情况，可以使用IF EXISTS选项。如果使用IF EXISTS删除不存在的索引，则PostgreSQL会发出通知。</li>
</ul>
<ul>
<li>CASCADE:如果索引具有从属对象，则可以使用CASCADE选项自动删除这些对象以及所有依赖于那些对象的对象。</li>
</ul>
<ul>
<li>RESTRICT:指示PostgreSQL如果任何对象依赖该索引，则拒绝删除该索引。默认情况下，DROP INDEX使用RESTRICT。</li>
</ul>
<blockquote>
<p>可以一次删除多个索引，方法是用逗号(，)分隔索引：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name, index_name2,... ;</span><br></pre></td></tr></table></figure>
<ul>
<li>CONCURRENTLY:当您执行DROP INDEX语句时，PostgreSQL在表上获取排他锁并阻止其他访问，直到索引删除完成。要强制命令在删除索引之前等待冲突的事务完成，可以使用CONCURRENTLY选项。</li>
</ul>
<blockquote>
<p>DROP INDEX同时具有一些限制：</p>
<ul>
<li>首先，不支持CASCADE选项。</li>
</ul>
<ul>
<li>其次，也不支持在事务块中执行。</li>
</ul>
</blockquote>
<h4 id="DROP-INDEX示例"><a href="#DROP-INDEX示例" class="headerlink" title="DROP INDEX示例"></a>DROP INDEX示例</h4><blockquote>
<p>为actor表的first_name列创建索引:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE INDEX idx_actor_first_name</span></span><br><span class="line">ON actor (first_name);</span><br><span class="line">CREATE INDEX</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有时，查询优化器不使用索引。例如，以下语句查找名称为John的演员：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    actor</span><br><span class="line">WHERE</span><br><span class="line">    first_name = <span class="string">'John'</span>;</span><br><span class="line"> actor_id | first_name | last_name |      last_update</span><br><span class="line">----------+------------+-----------+------------------------</span><br><span class="line">      192 | John       | Suvari    | 2013-05-26 14:47:57.62</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该查询未使用前面定义的idx_actor_first_name索引，如以下EXPLAIN语句所述：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># EXPLAIN SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    actor</span><br><span class="line">WHERE</span><br><span class="line">    first_name = <span class="string">'John'</span>;</span><br><span class="line">                      QUERY PLAN</span><br><span class="line">------------------------------------------------------</span><br><span class="line"> Seq Scan on actor  (cost=0.00..4.50 rows=1 width=25)</span><br><span class="line">   Filter: ((first_name)::text = <span class="string">'John'</span>::text)</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">EXPLAIN</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是因为查询优化器认为只扫描整个表以查找行是最佳选择。因此，idx_actor_first_name在这种情况下，没什么用，我们需要将其删除：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DROP INDEX idx_actor_first_name;</span></span><br><span class="line">DROP INDEX</span><br></pre></td></tr></table></figure>
<h3 id="列出索引"><a href="#列出索引" class="headerlink" title="列出索引"></a>列出索引</h3><blockquote>
<p>PostgreSQL没有提供像SHOW INDEXES这样的命令来列出表或数据库的索引信息。但是，它提供了pg_indexes视图的访问权限，以便可以查询索引信息。如果使用psql访问PostgreSQL数据库，则可以使用\d命令查看表的索引信息。</p>
</blockquote>
<h4 id="pg-indexes视图的使用"><a href="#pg-indexes视图的使用" class="headerlink" title="pg_indexes视图的使用"></a>pg_indexes视图的使用</h4><blockquote>
<p>pg_indexes视图允许访问PostgreSQL数据库中每个索引的有用信息。</p>
</blockquote>
<blockquote>
<p>pg_indexes视图由五列组成：</p>
<ul>
<li>schemaname：存储包含表和索引的架构的名称。</li>
</ul>
<ul>
<li>tablename：存储索引所属表的名称。</li>
</ul>
<ul>
<li>indexname：存储索引名称。</li>
</ul>
<ul>
<li>tablespace：存储包含索引的表空间的名称。</li>
</ul>
<ul>
<li>indexdef：以CREATE INDEX语句的形式存储索引定义命令。</li>
</ul>
</blockquote>
<blockquote>
<p>以下语句列出了当前数据库中public模式的所有索引：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    tablename,</span><br><span class="line">    indexname,</span><br><span class="line">    indexdef</span><br><span class="line">FROM</span><br><span class="line">    pg_indexes</span><br><span class="line">WHERE</span><br><span class="line">    schemaname = <span class="string">'public'</span></span><br><span class="line">ORDER BY</span><br><span class="line">    tablename,</span><br><span class="line">    indexname;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要显示表的所有索引，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    indexname,</span><br><span class="line">    indexdef</span><br><span class="line">FROM</span><br><span class="line">    pg_indexes</span><br><span class="line">WHERE</span><br><span class="line">    tablename = <span class="string">'table_name'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如，要列出customer表的所有索引，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    indexname,</span><br><span class="line">    indexdef</span><br><span class="line">FROM</span><br><span class="line">    pg_indexes</span><br><span class="line">WHERE</span><br><span class="line">    tablename = <span class="string">'customer'</span>;</span><br><span class="line">     indexname     |                                    indexdef</span><br><span class="line">-------------------+--------------------------------------------------------------------------------</span><br><span class="line"> customer_pkey     | CREATE UNIQUE INDEX customer_pkey ON public.customer USING btree (customer_id)</span><br><span class="line"> idx_fk_address_id | CREATE INDEX idx_fk_address_id ON public.customer USING btree (address_id)</span><br><span class="line"> idx_fk_store_id   | CREATE INDEX idx_fk_store_id ON public.customer USING btree (store_id)</span><br><span class="line"> idx_last_name     | CREATE INDEX idx_last_name ON public.customer USING btree (last_name)</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要获取名称以字母c开头的表的索引列表，则可以使用以下查询：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    tablename,</span><br><span class="line">    indexname,</span><br><span class="line">    indexdef</span><br><span class="line">FROM</span><br><span class="line">    pg_indexes</span><br><span class="line">WHERE</span><br><span class="line">    tablename LIKE <span class="string">'c%'</span></span><br><span class="line">ORDER BY</span><br><span class="line">    tablename,</span><br><span class="line">    indexname;</span><br><span class="line">    tablename    |        indexname         |                                         indexdef</span><br><span class="line">-----------------+--------------------------+-------------------------------------------------------------------------------------------</span><br><span class="line"> categories      | categories_pkey          | CREATE UNIQUE INDEX categories_pkey ON public.categories USING btree (category_id)</span><br><span class="line"> category        | category_pkey            | CREATE UNIQUE INDEX category_pkey ON public.category USING btree (category_id)</span><br><span class="line"> cities          | cities_pkey              | CREATE UNIQUE INDEX cities_pkey ON public.cities USING btree (city_id)</span><br><span class="line"> city            | city_pkey                | CREATE UNIQUE INDEX city_pkey ON public.city USING btree (city_id)</span><br><span class="line"> city            | idx_fk_country_id        | CREATE INDEX idx_fk_country_id ON public.city USING btree (country_id)</span><br><span class="line"> contact_backup  | contact_backup_email_key | CREATE UNIQUE INDEX contact_backup_email_key ON public.contact_backup USING btree (email)</span><br><span class="line"> contact_backup  | contact_backup_pkey      | CREATE UNIQUE INDEX contact_backup_pkey ON public.contact_backup USING btree (id)</span><br><span class="line"> contacts        | contacts_email_key       | CREATE UNIQUE INDEX contacts_email_key ON public.contacts USING btree (email)</span><br><span class="line"> contacts        | contacts_pkey            | CREATE UNIQUE INDEX contacts_pkey ON public.contacts USING btree (id)</span><br><span class="line"> country         | country_pkey             | CREATE UNIQUE INDEX country_pkey ON public.country USING btree (country_id)</span><br><span class="line"> cust            | cust_pkey                | CREATE UNIQUE INDEX cust_pkey ON public.cust USING btree (id)</span><br><span class="line"> cust_groups     | cust_groups_pkey         | CREATE UNIQUE INDEX cust_groups_pkey ON public.cust_groups USING btree (id)</span><br><span class="line"> customer        | customer_pkey            | CREATE UNIQUE INDEX customer_pkey ON public.customer USING btree (customer_id)</span><br><span class="line"> customer        | idx_fk_address_id        | CREATE INDEX idx_fk_address_id ON public.customer USING btree (address_id)</span><br><span class="line"> customer        | idx_fk_store_id          | CREATE INDEX idx_fk_store_id ON public.customer USING btree (store_id)</span><br><span class="line"> customer        | idx_last_name            | CREATE INDEX idx_last_name ON public.customer USING btree (last_name)</span><br><span class="line"> customer_groups | customer_groups_pkey     | CREATE UNIQUE INDEX customer_groups_pkey ON public.customer_groups USING btree (id)</span><br><span class="line"> customers       | customers_pkey           | CREATE UNIQUE INDEX customers_pkey ON public.customers USING btree (id)</span><br><span class="line">(18 rows)</span><br></pre></td></tr></table></figure>
<h4 id="psql命令的使用"><a href="#psql命令的使用" class="headerlink" title="psql命令的使用"></a>psql命令的使用</h4><blockquote>
<p>如果使用psql连接到PostgreSQL数据库并想列出表的所有索引，则可以使用\d psql命令，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d table_name</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该命令将返回表的所有信息，包括表的结构，索引，约束和触发器。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; \d customer</span><br><span class="line">                                            数据表 <span class="string">"public.customer"</span></span><br><span class="line">    栏位     |            类型             | 校对规则 |  可空的  |                     预设                      </span><br><span class="line">-------------+-----------------------------+----------+----------+-----------------------------------------------</span><br><span class="line"> customer_id | <span class="built_in">integer</span>                     |          | not null | nextval(<span class="string">'customer_customer_id_seq'</span>::regclass)</span><br><span class="line"> store_id    | smallint                    |          | not null | </span><br><span class="line"> first_name  | character varying(45)       |          | not null | </span><br><span class="line"> last_name   | character varying(45)       |          | not null | </span><br><span class="line"> email       | character varying(50)       |          |          | </span><br><span class="line"> address_id  | smallint                    |          | not null | </span><br><span class="line"> activebool  | boolean                     |          | not null | <span class="literal">true</span></span><br><span class="line"> create_date | date                        |          | not null | <span class="string">'now'</span>::text::date</span><br><span class="line"> last_update | timestamp without time zone |          |          | now()</span><br><span class="line"> active      | <span class="built_in">integer</span>                     |          |          | </span><br><span class="line">索引：</span><br><span class="line">    <span class="string">"customer_pkey"</span> PRIMARY KEY, btree (customer_id)</span><br><span class="line">    <span class="string">"idx_fk_address_id"</span> btree (address_id)</span><br><span class="line">    <span class="string">"idx_fk_store_id"</span> btree (store_id)</span><br><span class="line">    <span class="string">"idx_last_name"</span> btree (last_name)</span><br><span class="line">外部键(FK)限制：</span><br><span class="line">    <span class="string">"customer_address_id_fkey"</span> FOREIGN KEY (address_id) REFERENCES address(address_id) ON UPDATE CASCADE ON DELETE RESTRICT</span><br><span class="line">由引用：</span><br><span class="line">    TABLE <span class="string">"payment"</span> CONSTRAINT <span class="string">"payment_customer_id_fkey"</span> FOREIGN KEY (customer_id) REFERENCES customer(customer_id) ON UPDATE CASCADE ON DELETE RESTRICT</span><br><span class="line">    TABLE <span class="string">"rental"</span> CONSTRAINT <span class="string">"rental_customer_id_fkey"</span> FOREIGN KEY (customer_id) REFERENCES customer(customer_id) ON UPDATE CASCADE ON DELETE RESTRICT</span><br><span class="line">触发器：</span><br><span class="line">    last_updated BEFORE UPDATE ON customer FOR EACH ROW EXECUTE FUNCTION last_updated()</span><br></pre></td></tr></table></figure>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><blockquote>
<p>PostgreSQL有几种索引类型：B-tree,Hash,GiST,SP-GiST,GIN和BRIN。每种索引类型使用不同的存储结构和算法来处理不同种类的查询。</p>
</blockquote>
<blockquote>
<p>在不指定索引类型的情况下使用CREATE INDEX语句时，PostgreSQL默认使用B-tree索引类型，因为它最适合最常见的查询。</p>
</blockquote>
<h4 id="B-tree索引"><a href="#B-tree索引" class="headerlink" title="B-tree索引"></a>B-tree索引</h4><blockquote>
<p>B-tree是一种自平衡树，用于维护排序的数据，并允许在对数时间内进行搜索，插入，删除和顺序访问。</p>
</blockquote>
<blockquote>
<p>PostgreSQL查询计划程序将考虑在使用以下运算符之一的比较中涉及索引列时使用B-tree索引：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;</span><br><span class="line">&lt;=</span><br><span class="line">=</span><br><span class="line">&gt;=</span><br><span class="line">BETWEEN</span><br><span class="line">IN</span><br><span class="line">IS NULL</span><br><span class="line">IS NOT NULL</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另外，查询计划者可以将B-tree索引用于涉及模式匹配运算符LIKE和〜的查询，如果模式是一个常量并且在模式的开始处锚定，例如：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">column_name LIKE <span class="string">'foo%'</span></span><br><span class="line">column_name LKE <span class="string">'bar%'</span></span><br><span class="line">column_name  ~ <span class="string">'^foo'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>此外，如果模式以非字母字符开头(即不受大写/小写转换影响的字符)，则查询计划人员将考虑对ILIKE和〜*使用B-tree索引。</p>
</blockquote>
<blockquote>
<p>如果已开始使用索引来优化PostgreSQL数据库，那么B-tree可能就是您想要的。</p>
</blockquote>
<h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><blockquote>
<p>Hash索引只能处理简单的相等比较(=)。这意味着，只要使用equal(=)运算符在比较中涉及索引列，查询计划者就会考虑使用哈希索引。</p>
</blockquote>
<blockquote>
<p>要创建哈希索引，请使用CREATE INDEX语句，并在USING子句中使用HASH索引类型，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name</span><br><span class="line">ON table_name USING HASH (indexed_column);</span><br></pre></td></tr></table></figure>
<h4 id="GIN索引"><a href="#GIN索引" class="headerlink" title="GIN索引"></a>GIN索引</h4><blockquote>
<p>GIN代表广义倒排索引。通常称为GIN。当您将多个值存储在单个列中时，例如hstore，array，jsonb和range类型，GIN索引最有用。</p>
</blockquote>
<h4 id="BRIN"><a href="#BRIN" class="headerlink" title="BRIN"></a>BRIN</h4><blockquote>
<p>BRIN代表块范围索引。与B-tree索引相比，BRIN小得多，维护成本也低。BRIN允许在非常大的表上使用索引，而以前使用B-tree在没有水平分区的情况下这是不切实际的。BRIN通常用于具有线性排序顺序的列，例如，销售订单表的创建日期列。</p>
</blockquote>
<h4 id="GiST索引"><a href="#GiST索引" class="headerlink" title="GiST索引"></a>GiST索引</h4><blockquote>
<p>GiST代表广义搜索树。GiST索引允许构建一般的树结构。GiST索引在索引几何数据类型和全文搜索时很有用。</p>
</blockquote>
<h4 id="SP-GiST索引"><a href="#SP-GiST索引" class="headerlink" title="SP-GiST索引"></a>SP-GiST索引</h4><blockquote>
<p>SP-GiST代表空间分区的GiST。SP-GiST支持分区搜索树，这些树有助于开发各种不同的非平衡数据结构。</p>
</blockquote>
<blockquote>
<p>SP-GiST索引对于具有自然聚类元素且不是均衡树的数据最为有用，例如GIS，多媒体，电话路由和IP路由。</p>
</blockquote>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><h4 id="UNIQUE索引语法"><a href="#UNIQUE索引语法" class="headerlink" title="UNIQUE索引语法"></a>UNIQUE索引语法</h4><blockquote>
<p>PostgreSQL UNIQUE索引在一个或多个列中强制值的唯一性。要创建UNIQUE索引，可以使用以下语法：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX index_name</span><br><span class="line">ON table_name(column_name, [...]);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，只有B-tree索引可以声明为唯一索引。</p>
</blockquote>
<blockquote>
<p>为列定义UNIQUE索引时，该列不能存储具有相同值的多行。如果为两个或更多列定义UNIQUE索引，则这些列中的组合值不能在多行中重复。</p>
</blockquote>
<blockquote>
<p>PostgreSQL将NULL视为不同的值，因此，在具有UNIQUE索引的列中可以有多个NULL值。</p>
</blockquote>
<blockquote>
<p>为表定义主键或唯一约束时，PostgreSQL会自动创建一个对应的UNIQUE索引。</p>
</blockquote>
<h4 id="UNIQUE索引示例"><a href="#UNIQUE索引示例" class="headerlink" title="UNIQUE索引示例"></a>UNIQUE索引示例</h4><blockquote>
<p>创建示例表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE test17 (</span></span><br><span class="line">    employee_id SERIAL PRIMARY KEY,</span><br><span class="line">    first_name VARCHAR(255) NOT NULL,</span><br><span class="line">    last_name VARCHAR(255) NOT NULL,</span><br><span class="line">    email VARCHAR(255) UNIQUE</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此语句中，employee_id是主键列，而email列具有唯一约束，因此，PostgreSQL创建了两个UNIQUE索引，每个索引一个。</p>
</blockquote>
<blockquote>
<p>要显示表的索引，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    tablename,</span><br><span class="line">    indexname,</span><br><span class="line">    indexdef</span><br><span class="line">FROM</span><br><span class="line">    pg_indexes</span><br><span class="line">WHERE</span><br><span class="line">    tablename = <span class="string">'test17'</span>;</span><br><span class="line"> tablename |    indexname     |                                  indexdef</span><br><span class="line">-----------+------------------+----------------------------------------------------------------------------</span><br><span class="line"> test17    | test17_pkey      | CREATE UNIQUE INDEX test17_pkey ON public.test17 USING btree (employee_id)</span><br><span class="line"> test17    | test17_email_key | CREATE UNIQUE INDEX test17_email_key ON public.test17 USING btree (email)</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h4 id="UNIQUE索引–单列示例"><a href="#UNIQUE索引–单列示例" class="headerlink" title="UNIQUE索引–单列示例"></a>UNIQUE索引–单列示例</h4><blockquote>
<p>以下语句将mobile_phone列添加到表中：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE test17</span></span><br><span class="line">ADD mobile_phone VARCHAR(20);</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为确保所有员工的手机号码互不相同，为mobile_phone列定义UNIQUE索引，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE UNIQUE INDEX idx_test17_mobile_phone</span></span><br><span class="line">ON test17(mobile_phone);</span><br><span class="line">CREATE INDEX</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在表中插入新行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test17(first_name, last_name, email, mobile_phone)</span></span><br><span class="line">VALUES (<span class="string">'James'</span>,<span class="string">'Harden'</span>,<span class="string">'james.harden@pg.com'</span>, <span class="string">'12345678909'</span>);</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>尝试插入具有相同电话号码的另一行，由于手机号码重复，PostgreSQL发出以下错误：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test17(first_name, last_name, email, mobile_phone)</span></span><br><span class="line">VALUES (<span class="string">'Michael'</span>,<span class="string">'Jordan'</span>,<span class="string">'michael.jordan@pg.com'</span>, <span class="string">'12345678909'</span>);</span><br><span class="line">错误:  重复键违反唯一约束<span class="string">"idx_test17_mobile_phone"</span></span><br><span class="line">DETAIL:  键值<span class="string">"(mobile_phone)=(12345678909)"</span> 已经存在</span><br></pre></td></tr></table></figure>
<h4 id="UNIQUE索引–多列示例"><a href="#UNIQUE索引–多列示例" class="headerlink" title="UNIQUE索引–多列示例"></a>UNIQUE索引–多列示例</h4><blockquote>
<p>在test17表中添加了两个新列，分别为work_phone和extension：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE test17</span></span><br><span class="line">ADD work_phone VARCHAR(20),</span><br><span class="line">ADD extension VARCHAR(5);</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>多名员工可以共享相同的工作电话号码。但是，它们不能具有相同的分机号。要实施此规则，可以在work_phone和extension列上定义UNIQUE索引：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE UNIQUE INDEX idx_test17_workphone</span></span><br><span class="line">ON test17(work_phone, extension);</span><br><span class="line">CREATE INDEX</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在test17表中插入一行：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test17(first_name, last_name, work_phone, extension)</span></span><br><span class="line">VALUES(<span class="string">'Jason'</span>, <span class="string">'Tatum'</span>, <span class="string">'(408)-3333-1234'</span>,<span class="string">'10'</span>);</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>插入另一名工作电话号码相同但分机号不同的员工：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test17(first_name, last_name, work_phone, extension)</span></span><br><span class="line">VALUES(<span class="string">'Jaylen'</span>, <span class="string">'Brown'</span>, <span class="string">'(408)-3333-1234'</span>,<span class="string">'12'</span>);</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<ul>
<li>该语句有效，因为work_phone和extension列中的值组合是唯一的。</li>
</ul>
<blockquote>
<p>尝试在employees表中插入已存在的work_phone和extension列中具有相同值的行，PostgreSQL将发生错误:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test17(first_name, last_name, work_phone, extension)</span></span><br><span class="line">VALUES(<span class="string">'Kevin'</span>, <span class="string">'Garnett'</span>, <span class="string">'(408)-3333-1234'</span>,<span class="string">'12'</span>);</span><br><span class="line">错误:  重复键违反唯一约束<span class="string">"idx_test17_workphone"</span></span><br><span class="line">DETAIL:  键值<span class="string">"(work_phone, extension)=((408)-3333-1234, 12)"</span> 已经存在</span><br></pre></td></tr></table></figure>
<h3 id="表达式索引"><a href="#表达式索引" class="headerlink" title="表达式索引"></a>表达式索引</h3><h4 id="表达式索引简介"><a href="#表达式索引简介" class="headerlink" title="表达式索引简介"></a>表达式索引简介</h4><blockquote>
<p>通常创建一个索引来引用表的一个或多个列。但是，也可以基于涉及表列的表达式创建索引。该索引称为表达式索引。表达式的索引也称为基于函数的索引。</p>
</blockquote>
<blockquote>
<p>在表达式上创建索引的语法如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name</span><br><span class="line">ON table_name (expression);</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，在CREATE INDEX子句之后指定索引的名称。</li>
</ul>
<ul>
<li>然后，形成一个包含table_name的表列的表达式。</li>
</ul>
<blockquote>
<p>定义索引表达式后，当定义索引的表达式出现在SQL语句的WHERE子句或ORDER BY子句中时，PostgreSQL将考虑使用该索引。</p>
</blockquote>
<blockquote>
<p>请注意，维护表达式的索引非常昂贵，因为PostgreSQL必须在插入或更新表达式时评估每一行的表达式并将其用于索引。因此，当检索速度比插入和更新速度更重要时，应在表达式上使用索引。</p>
</blockquote>
<h4 id="表达式索引示例"><a href="#表达式索引示例" class="headerlink" title="表达式索引示例"></a>表达式索引示例</h4><blockquote>
<p>customer表具有为first_name列定义的B-Tree索引，如下查询查找姓氏为Purdy的客户：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    customer_id,</span><br><span class="line">    first_name,</span><br><span class="line">    last_name</span><br><span class="line">FROM</span><br><span class="line">    customer</span><br><span class="line">WHERE</span><br><span class="line">    last_name = <span class="string">'Purdy'</span>;</span><br><span class="line"> customer_id | first_name | last_name</span><br><span class="line">-------------+------------+-----------</span><br><span class="line">         333 | Andrew     | Purdy</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行此查询时，PostgreSQL使用idx_last_name索引，如以下EXPLAIN语句所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># EXPLAIN</span></span><br><span class="line">SELECT</span><br><span class="line">    customer_id,</span><br><span class="line">    first_name,</span><br><span class="line">    last_name</span><br><span class="line">FROM</span><br><span class="line">    customer</span><br><span class="line">WHERE</span><br><span class="line">    last_name = <span class="string">'Purdy'</span>;</span><br><span class="line">                                  QUERY PLAN</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"> Index Scan using idx_last_name on customer  (cost=0.28..8.29 rows=1 width=17)</span><br><span class="line">   Index Cond: ((last_name)::text = <span class="string">'Purdy'</span>::text)</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">EXPLAIN</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下语句查找姓氏为purdy的小写客户。但是，PostgreSQL无法利用索引进行查找：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># EXPLAIN</span></span><br><span class="line">SELECT</span><br><span class="line">    customer_id,</span><br><span class="line">    first_name,</span><br><span class="line">    last_name</span><br><span class="line">FROM</span><br><span class="line">    customer</span><br><span class="line">WHERE</span><br><span class="line">    LOWER(last_name) = <span class="string">'purdy'</span>;</span><br><span class="line">                        QUERY PLAN</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"> Seq Scan on customer  (cost=0.00..17.98 rows=3 width=17)</span><br><span class="line">   Filter: (lower((last_name)::text) = <span class="string">'purdy'</span>::text)</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">EXPLAIN</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了改善此查询，可以定义一个索引表达式，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE INDEX idx_ic_last_name</span></span><br><span class="line">ON customer(LOWER(last_name));</span><br><span class="line">CREATE INDEX</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在，以不区分大小写的方式根据姓氏查找客户的查询将使用表达式上的索引，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># EXPLAIN</span></span><br><span class="line">SELECT</span><br><span class="line">    customer_id,</span><br><span class="line">    first_name,</span><br><span class="line">    last_name</span><br><span class="line">FROM</span><br><span class="line">    customer</span><br><span class="line">WHERE</span><br><span class="line">    LOWER(last_name) = <span class="string">'purdy'</span>;</span><br><span class="line">                                  QUERY PLAN</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"> Bitmap Heap Scan on customer  (cost=4.30..11.15 rows=3 width=17)</span><br><span class="line">   Recheck Cond: (lower((last_name)::text) = <span class="string">'purdy'</span>::text)</span><br><span class="line">   -&gt;  Bitmap Index Scan on idx_ic_last_name  (cost=0.00..4.30 rows=3 width=0)</span><br><span class="line">         Index Cond: (lower((last_name)::text) = <span class="string">'purdy'</span>::text)</span><br><span class="line">(4 rows)</span><br><span class="line"></span><br><span class="line">EXPLAIN</span><br></pre></td></tr></table></figure>
<h3 id="部分索引"><a href="#部分索引" class="headerlink" title="部分索引"></a>部分索引</h3><blockquote>
<p>PostgreSQL部分索引允许指定应建立索引的表的行。此部分索引有助于加快查询速度，同时减小索引的大小。</p>
</blockquote>
<blockquote>
<p>如果具有常用的WHERE条件，这些条件使用常量值，则部分索引很有用：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    table_name</span><br><span class="line">WHERE</span><br><span class="line">    column_name = constant_value;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">&gt; 查找所有不活动的客户:</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    customer_id,</span><br><span class="line">    first_name,</span><br><span class="line">    last_name,</span><br><span class="line">    email</span><br><span class="line">FROM</span><br><span class="line">    customer</span><br><span class="line">WHERE</span><br><span class="line">    active = 0;</span><br><span class="line"> customer_id | first_name | last_name |                email</span><br><span class="line">-------------+------------+-----------+-------------------------------------</span><br><span class="line">          16 | Sandra     | Martin    | sandra.martin@sakilacustomer.org</span><br><span class="line">          64 | Judith     | Cox       | judith.cox@sakilacustomer.org</span><br><span class="line">         124 | Sheila     | Wells     | sheila.wells@sakilacustomer.org</span><br><span class="line">         169 | Erica      | Matthews  | erica.matthews@sakilacustomer.org</span><br><span class="line">         241 | Heidi      | Larson    | heidi.larson@sakilacustomer.org</span><br><span class="line">         271 | Penny      | Neal      | penny.neal@sakilacustomer.org</span><br><span class="line">         315 | Kenneth    | Gooden    | kenneth.gooden@sakilacustomer.org</span><br><span class="line">         368 | Harry      | Arce      | harry.arce@sakilacustomer.org</span><br><span class="line">         406 | Nathan     | Runyon    | nathan.runyon@sakilacustomer.org</span><br><span class="line">         446 | Theodore   | Culp      | theodore.culp@sakilacustomer.org</span><br><span class="line">         482 | Maurice    | Crawley   | maurice.crawley@sakilacustomer.org</span><br><span class="line">         510 | Ben        | Easter    | ben.easter@sakilacustomer.org</span><br><span class="line">         534 | Christian  | Jung      | christian.jung@sakilacustomer.org</span><br><span class="line">         558 | Jimmie     | Eggleston | jimmie.eggleston@sakilacustomer.org</span><br><span class="line">         592 | Terrance   | Roush     | terrance.roush@sakilacustomer.org</span><br><span class="line">(15 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要执行此查询，查询计划者需要扫描customer表，如以下EXPLAIN语句所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># EXPLAIN SELECT</span></span><br><span class="line">    customer_id,</span><br><span class="line">    first_name,</span><br><span class="line">    last_name,</span><br><span class="line">    email</span><br><span class="line">FROM</span><br><span class="line">    customer</span><br><span class="line">WHERE</span><br><span class="line">    active = 0;</span><br><span class="line">                        QUERY PLAN</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"> Seq Scan on customer  (cost=0.00..16.49 rows=15 width=49)</span><br><span class="line">   Filter: (active = 0)</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">EXPLAIN</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以通过为活动列创建索引来优化此查询，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE INDEX idx_customer_active</span></span><br><span class="line">ON customer(active);</span><br><span class="line">CREATE INDEX</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如上索引实现了其目的，但是，它包含了所有活动客户。要定义仅包含非活动客户的索引，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE INDEX idx_customer_inactive</span></span><br><span class="line">ON customer(active)</span><br><span class="line">WHERE active = 0;</span><br><span class="line">CREATE INDEX</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从现在开始，只要WHERE子句出现在查询中，PostgreSQL就会考虑部分索引：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># EXPLAIN SELECT</span></span><br><span class="line">    customer_id,</span><br><span class="line">    first_name,</span><br><span class="line">    last_name,</span><br><span class="line">    email</span><br><span class="line">FROM</span><br><span class="line">    customer</span><br><span class="line">WHERE</span><br><span class="line">    active = 0;</span><br><span class="line">                                      QUERY PLAN</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line"> Index Scan using idx_customer_active on customer  (cost=0.28..12.30 rows=15 width=49)</span><br><span class="line">   Index Cond: (active = 0)</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">EXPLAIN</span><br></pre></td></tr></table></figure>
<blockquote>
<p>定义部分索引的语法非常简单：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name</span><br><span class="line">ON table_name(column_list)</span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用这种语法，WHERE子句指定应将哪些行添加到索引。</p>
</blockquote>
<h3 id="重新索引"><a href="#重新索引" class="headerlink" title="重新索引"></a>重新索引</h3><h4 id="REINDEX语句简介"><a href="#REINDEX语句简介" class="headerlink" title="REINDEX语句简介"></a>REINDEX语句简介</h4><blockquote>
<p>实际上，由于硬件故障或软件错误，索引可能会损坏，并且不再包含有效数据。要恢复索引，可以使用以下REINDEX语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REINDEX [ ( VERBOSE ) ] &#123; INDEX | TABLE | SCHEMA | DATABASE | SYSTEM &#125; name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此语法中，VERBOSE关键字是可选的。当包含该语句时，该语句将在为每个索引重新编制索引时显示进度报告。</p>
</blockquote>
<blockquote>
<p>要重新创建单个索引，请在REINDEX INDEX子句之后指定索引名称，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REINDEX INDEX index_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要重新创建表的所有索引，请使用TABLE关键字并指定表的名称:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REINDEX TABLE table_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要在模式中重新创建所有索引，请使用SCHEMA关键字，后跟模式名称：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REINDEX SCHEMA schema_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要在特定数据库中重新创建所有索引，请在REINDEX DATABASE子句后指定数据库名称：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REINDEX DATABASE database_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在特定数据库中的系统目录上重新创建所有索引：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REINDEX SYSTEM database_name;</span><br></pre></td></tr></table></figure>
<h4 id="REINDEX与DROP-INDEX和CREATE-INDEX"><a href="#REINDEX与DROP-INDEX和CREATE-INDEX" class="headerlink" title="REINDEX与DROP INDEX和CREATE INDEX"></a>REINDEX与DROP INDEX和CREATE INDEX</h4><blockquote>
<p>REINDEX语句从头开始重建索引内容，其作用与删除和重新创建索引相似。但是，它们之间的锁定机制是不同的。</p>
</blockquote>
<blockquote>
<p>REINDEX语句：</p>
<ul>
<li>锁定写入但不读取索引所属的表。</li>
</ul>
<ul>
<li>对正在处理的索引进行排他锁，这将阻止尝试使用该索引的读取。</li>
</ul>
</blockquote>
<blockquote>
<p>DROP INDEX和CREATE INDEX语句：</p>
<ul>
<li>首先，DROP INDEX通过获取表上的排他锁来锁定索引所属表的写入和读取。</li>
</ul>
<ul>
<li>然后，后续的CREATE INDEX语句锁定从索引的父表进行的写入操作，但不会进行读取。但是，在创建索引期间读取可能会很昂贵。</li>
</ul>
</blockquote>
<h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><h4 id="多列索引简介"><a href="#多列索引简介" class="headerlink" title="多列索引简介"></a>多列索引简介</h4><blockquote>
<p>在一个表的多个列上创建索引，该索引称为多列索引、复合索引、组合索引或串联索引。</p>
</blockquote>
<blockquote>
<p>一个多列索引最多可以有一个表的32列。在构建PostgreSQL时，可以通过修改pg_config_manual.h来更改该限制。此外，仅B-tree、GIST、GIN和BRIN索引类型支持多列索引。</p>
</blockquote>
<blockquote>
<p>以下语法显示了如何创建多列索引：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name</span><br><span class="line">ON table_name(a,b,c,...);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>定义多列索引时，应将WHERE子句中经常使用的列放在列列表的开头，然后将在条件中不经常使用的列放在后面。</p>
</blockquote>
<blockquote>
<p>在以上语法中，PostgreSQL优化器将在以下情况下考虑使用索引：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE a = v1 and b = v2 and c = v3;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE a = v1 and b = v2;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>又或</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE a = v1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是，在以下情况下，它将不考虑使用索引：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE  c = v3;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE b = v2 and c = v3;</span><br></pre></td></tr></table></figure>
<h4 id="多列索引示例"><a href="#多列索引示例" class="headerlink" title="多列索引示例"></a>多列索引示例</h4><blockquote>
<p>创建一个名为people的新表，该表具有三列：id，名字和姓氏：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE people(</span></span><br><span class="line">    id INT GENERATED BY DEFAULT AS IDENTITY,</span><br><span class="line">    first_name VARCHAR(50) NOT NULL,</span><br><span class="line">    last_name VARCHAR(50) NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查找姓氏为Adams的人：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    people</span><br><span class="line">WHERE</span><br><span class="line">    last_name = <span class="string">'Adams'</span>;</span><br><span class="line">  id  | first_name | last_name</span><br><span class="line">------+------------+-----------</span><br><span class="line">  323 | Olivia     | Adams</span><br><span class="line">  533 | Vincent    | Adams</span><br><span class="line">  695 | Jean       | Adams</span><br><span class="line"> 1416 | Mamie      | Adams</span><br><span class="line"> 1517 | Lou        | Adams</span><br><span class="line"> 2476 | Jordan     | Adams</span><br><span class="line"> 5328 | Chris      | Adams</span><br><span class="line"> 5768 | Evan       | Adams</span><br><span class="line"> 7229 | Rose       | Adams</span><br><span class="line"> 8041 | Marguerite | Adams</span><br><span class="line"> 8190 | Myrtie     | Adams</span><br><span class="line"> 8975 | Melvin     | Adams</span><br><span class="line"> 9309 | Nannie     | Adams</span><br><span class="line">(13 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于未为last_name列定义索引，PostgreSQL对人员表执行了顺序扫描以查找相应的行。</p>
</blockquote>
<blockquote>
<p>在last_name和first_name列上定义一个B树索引。假设按姓氏搜索人比按名搜索更多，我们用以下列顺序定义索引：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE INDEX idx_people_names</span></span><br><span class="line">ON people (last_name, first_name);</span><br><span class="line">CREATE INDEX</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在，如果搜索姓氏是Adams的人，则PostgreSQL优化器将使用以下语句的输出中所示的索引：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># EXPLAIN SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    people</span><br><span class="line">WHERE</span><br><span class="line">    last_name = <span class="string">'Adams'</span>;</span><br><span class="line">                                   QUERY PLAN</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"> Bitmap Heap Scan on people  (cost=4.42..44.07 rows=18 width=17)</span><br><span class="line">   Recheck Cond: ((last_name)::text = <span class="string">'Adams'</span>::text)</span><br><span class="line">   -&gt;  Bitmap Index Scan on idx_people_names  (cost=0.00..4.42 rows=18 width=0)</span><br><span class="line">         Index Cond: ((last_name)::text = <span class="string">'Adams'</span>::text)</span><br><span class="line">(4 rows)</span><br><span class="line"></span><br><span class="line">EXPLAIN</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查找姓氏为Adams且姓氏为Lou的人。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    people</span><br><span class="line">WHERE</span><br><span class="line">    last_name = <span class="string">'Adams'</span></span><br><span class="line">AND first_name = <span class="string">'Lou'</span>;</span><br><span class="line">  id  | first_name | last_name</span><br><span class="line">------+------------+-----------</span><br><span class="line"> 1517 | Lou        | Adams</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PostgreSQL Optimizer使用该语句的索引，因为WHERE子句中的两列都在索引中：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># EXPLAIN SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    people</span><br><span class="line">WHERE</span><br><span class="line">    last_name = <span class="string">'Adams'</span></span><br><span class="line">AND first_name = <span class="string">'Lou'</span>;</span><br><span class="line">                                         QUERY PLAN</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"> Index Scan using idx_people_names on people  (cost=0.29..8.30 rows=1 width=17)</span><br><span class="line">   Index Cond: (((last_name)::text = <span class="string">'Adams'</span>::text) AND ((first_name)::text = <span class="string">'Lou'</span>::text))</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">EXPLAIN</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是，如果搜索名字叫Lou的人，PostgreSQL将对表执行顺序扫描，而不是使用以下语句的输出中所示的索引：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># EXPLAIN SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    people</span><br><span class="line">WHERE</span><br><span class="line">    first_name = <span class="string">'Lou'</span>;</span><br><span class="line">                        QUERY PLAN</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"> Seq Scan on people  (cost=0.00..186.00 rows=32 width=17)</span><br><span class="line">   Filter: ((first_name)::text = <span class="string">'Lou'</span>::text)</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">EXPLAIN</span><br></pre></td></tr></table></figure>
<blockquote>
<p>即使first_name列是索引的一部分，PostgreSQL也无法利用它。</p>
</blockquote>
<blockquote>
<p>要取消的一个关键点是，当您定义多列索引时，应始终考虑业务上下文以查找经常用于查找的列，并在定义索引时将这些列放在列列表的开头。</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    
    
    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="zhijiansd.github.io/blog/pg15/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhiJian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhiJian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/pg15/" class="post-title-link" itemprop="zhijiansd.github.io/index.html">PostgreSQL之视图</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-20 13:23:12 / 修改时间：13:25:05" itemprop="dateCreated datePublished" datetime="2020-05-20T13:23:12+08:00">2020-05-20</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/postresql/" itemprop="url" rel="index"><span itemprop="name">postresql</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/pg15/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/pg15/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">21k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">35 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="PostgreSQL视图"><a href="#PostgreSQL视图" class="headerlink" title="PostgreSQL视图"></a>PostgreSQL视图</h2><h3 id="管理视图"><a href="#管理视图" class="headerlink" title="管理视图"></a>管理视图</h3><blockquote>
<p>视图是存储查询的数据库对象。可以在PostgreSQL中将视图作为虚拟表进行访问。换句话说，PostgreSQL视图是一个逻辑表，它通过SELECT语句表示一个或多个基础表的数据。请注意，除实例化视图外，视图并不物理存储数据。</p>
</blockquote>
<blockquote>
<p>视图在某些情况下可能非常有用，例如：</p>
<ul>
<li>视图可以简化查询的复杂性，因为您可以使用简单的SELECT语句查询基于复杂查询的视图。</li>
</ul>
<ul>
<li>像表一样，您可以通过包含用户被授权查看的特定数据的视图向用户授予权限。</li>
</ul>
<ul>
<li>一个视图提供了一个一致的层，即使基础表的列发生了变化。</li>
</ul>
</blockquote>
<h4 id="创建PostgreSQL视图"><a href="#创建PostgreSQL视图" class="headerlink" title="创建PostgreSQL视图"></a>创建PostgreSQL视图</h4><h5 id="CREATE-VIEW语法"><a href="#CREATE-VIEW语法" class="headerlink" title="CREATE VIEW语法"></a>CREATE VIEW语法</h5><blockquote>
<p>要创建视图，我们使用CREATE VIEW语句。 CREATE VIEW语句的最简单语法如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW view_name AS query;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先，在CREATE VIEW子句之后指定视图的名称，然后在AS关键字之后放置一个查询。查询可以是简单的SELECT语句，也可以是带有连接的复杂的SELECT语句。</p>
</blockquote>
<h5 id="CREATE-VIEW示例"><a href="#CREATE-VIEW示例" class="headerlink" title="CREATE VIEW示例"></a>CREATE VIEW示例</h5><blockquote>
<p>例如，在示例数据库中，我们有四个表:</p>
<ul>
<li>customer – 存储所有客户数据</li>
</ul>
<ul>
<li>address  – 客户的商店地址</li>
</ul>
<ul>
<li>city     – 存储城市数据</li>
</ul>
<ul>
<li>country  – 存储国家数据</li>
</ul>
</blockquote>
<blockquote>
<p>如果要获取完整的客户数据，通常可以按以下方式构造联接语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT cu.customer_id AS id,</span></span><br><span class="line">    cu.first_name || <span class="string">' '</span> || cu.last_name AS name,</span><br><span class="line">    a.address,</span><br><span class="line">    a.postal_code AS <span class="string">"zip code"</span>,</span><br><span class="line">    a.phone,</span><br><span class="line">    city.city,</span><br><span class="line">    country.country,</span><br><span class="line">        CASE</span><br><span class="line">            WHEN cu.activebool THEN <span class="string">'active'</span></span><br><span class="line">            ELSE <span class="string">''</span></span><br><span class="line">        END AS notes,</span><br><span class="line">    cu.store_id AS sid</span><br><span class="line">   FROM customer cu</span><br><span class="line">     INNER JOIN address a USING (address_id)</span><br><span class="line">     INNER JOIN city USING (city_id)</span><br><span class="line">     INNER JOIN country USING (country_id);</span><br><span class="line"> id  |         name          |                address                 | zip code |    phone     |            city            |                country                | notes  | sid </span><br><span class="line">-----+-----------------------+----------------------------------------+----------+--------------+----------------------------+---------------------------------------+--------+-----</span><br><span class="line"> 524 | Jared Ely             | 1003 Qinhuangdao Street                | 25972    | 35533115997  | Purwakarta                 | Indonesia                             | active |   1</span><br><span class="line">   1 | Mary Smith            | 1913 Hanoi Way                         | 35200    | 28303384290  | Sasebo                     | Japan                                 | active |   1</span><br><span class="line">   2 | Patricia Johnson      | 1121 Loja Avenue                       | 17886    | 838635286649 | San Bernardino             | United States                         | active |   1</span><br><span class="line">   3 | Linda Williams        | 692 Joliet Street                      | 83579    | 448477190408 | Athenai                    | Greece                                | active |   1</span><br><span class="line">   4 | Barbara Jones         | 1566 Inegl Manor                       | 53561    | 705814003527 | Myingyan                   | Myanmar                               | active |   2</span><br><span class="line">   5 | Elizabeth Brown       | 53 Idfu Parkway                        | 42399    | 10655648674  | Nantou                     | Taiwan                                | active |   1</span><br><span class="line">   6 | Jennifer Davis        | 1795 Santiago de Compostela Way        | 18743    | 860452626434 | Laredo                     | United States                         | active |   2</span><br><span class="line">   7 | Maria Miller          | 900 Santiago de Compostela Parkway     | 93896    | 716571220373 | Kragujevac                 | Yugoslavia                            | active |   1</span><br><span class="line">   8 | Susan Wilson          | 478 Joliet Way                         | 77948    | 657282285970 | Hamilton                   | New Zealand                           | active |   2</span><br><span class="line">   9 | Margaret Moore        | 613 Korolev Drive                      | 45844    | 380657522649 | Masqat                     | Oman                                  | active |   2</span><br><span class="line">  10 | Dorothy Taylor        | 1531 Sal Drive                         | 53628    | 648856936185 | Esfahan                    | Iran                                  | active |   1</span><br><span class="line">  11 | Lisa Anderson         | 1542 Tarlac Parkway                    | 1027     | 635297277345 | Sagamihara                 | Japan                                 | active |   2</span><br><span class="line">  12 | Nancy Thomas          | 808 Bhopal Manor                       | 10672    | 465887807014 | Yamuna Nagar               | India                                 | active |   1</span><br><span class="line">  13 | Karen Jackson         | 270 Amroha Parkway                     | 29610    | 695479687538 | Osmaniye                   | Turkey                                | active |   2</span><br><span class="line">  14 | Betty White           | 770 Bydgoszcz Avenue                   | 16266    | 517338314235 | Citrus Heights             | United States                         | active |   2</span><br><span class="line">  15 | Helen Harris          | 419 Iligan Lane                        | 72878    | 990911107354 | Bhopal                     | India                                 | active |   1</span><br><span class="line">  16 | Sandra Martin         | 360 Toulouse Parkway                   | 54308    | 949312333307 | Southend-on-Sea            | United Kingdom                        | active |   2</span><br><span class="line">  17 | Donna Thompson        | 270 Toulon Boulevard                   | 81766    | 407752414682 | Elista                     | Russian Federation                    | active |   1</span><br><span class="line">  18 | Carol Garcia          | 320 Brest Avenue                       | 43331    | 747791594069 | Kaduna                     | Nigeria                               | active |   2</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个查询非常复杂。但是，可以创建一个名为customer_master的视图，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE VIEW customer_master AS</span></span><br><span class="line">  SELECT cu.customer_id AS id,</span><br><span class="line">    cu.first_name || <span class="string">' '</span> || cu.last_name AS name,</span><br><span class="line">    a.address,</span><br><span class="line">    city.city,</span><br><span class="line">    country.country,</span><br><span class="line">        CASE</span><br><span class="line">            WHEN cu.activebool THEN <span class="string">'active'</span></span><br><span class="line">            ELSE <span class="string">''</span></span><br><span class="line">        END AS notes</span><br><span class="line">   FROM customer cu</span><br><span class="line">     INNER JOIN address a USING (address_id)</span><br><span class="line">     INNER JOIN city USING (city_id)</span><br><span class="line">     INNER JOIN country USING (country_id);</span><br><span class="line">CREATE VIEW</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从现在开始，每当需要获取完整的客户数据时，只需执行以下简单的SELECT语句即可从视图中查询数据：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> id  |         name          |                address                 |            city            |                country                | notes  </span><br><span class="line">-----+-----------------------+----------------------------------------+----------------------------+---------------------------------------+--------</span><br><span class="line"> 524 | Jared Ely             | 1003 Qinhuangdao Street                | Purwakarta                 | Indonesia                             | active</span><br><span class="line">   1 | Mary Smith            | 1913 Hanoi Way                         | Sasebo                     | Japan                                 | active</span><br><span class="line">   2 | Patricia Johnson      | 1121 Loja Avenue                       | San Bernardino             | United States                         | active</span><br><span class="line">   3 | Linda Williams        | 692 Joliet Street                      | Athenai                    | Greece                                | active</span><br><span class="line">   4 | Barbara Jones         | 1566 Inegl Manor                       | Myingyan                   | Myanmar                               | active</span><br><span class="line">   5 | Elizabeth Brown       | 53 Idfu Parkway                        | Nantou                     | Taiwan                                | active</span><br><span class="line">   6 | Jennifer Davis        | 1795 Santiago de Compostela Way        | Laredo                     | United States                         | active</span><br><span class="line">   7 | Maria Miller          | 900 Santiago de Compostela Parkway     | Kragujevac                 | Yugoslavia                            | active</span><br><span class="line">   8 | Susan Wilson          | 478 Joliet Way                         | Hamilton                   | New Zealand                           | active</span><br><span class="line">   9 | Margaret Moore        | 613 Korolev Drive                      | Masqat                     | Oman                                  | active</span><br><span class="line">  10 | Dorothy Taylor        | 1531 Sal Drive                         | Esfahan                    | Iran                                  | active</span><br><span class="line">  11 | Lisa Anderson         | 1542 Tarlac Parkway                    | Sagamihara                 | Japan                                 | active</span><br><span class="line">  12 | Nancy Thomas          | 808 Bhopal Manor                       | Yamuna Nagar               | India                                 | active</span><br><span class="line">  13 | Karen Jackson         | 270 Amroha Parkway                     | Osmaniye                   | Turkey                                | active</span><br><span class="line">  14 | Betty White           | 770 Bydgoszcz Avenue                   | Citrus Heights             | United States                         | active</span><br><span class="line">  15 | Helen Harris          | 419 Iligan Lane                        | Bhopal                     | India                                 | active</span><br><span class="line">  16 | Sandra Martin         | 360 Toulouse Parkway                   | Southend-on-Sea            | United Kingdom                        | active</span><br><span class="line">  17 | Donna Thompson        | 270 Toulon Boulevard                   | Elista                     | Russian Federation                    | active</span><br><span class="line">  18 | Carol Garcia          | 320 Brest Avenue                       | Kaduna                     | Nigeria                               | active</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<h4 id="更改PostgreSQL视图"><a href="#更改PostgreSQL视图" class="headerlink" title="更改PostgreSQL视图"></a>更改PostgreSQL视图</h4><h5 id="更改视图语法"><a href="#更改视图语法" class="headerlink" title="更改视图语法"></a>更改视图语法</h5><blockquote>
<p>要更改视图的定义查询，请使用CREATE VIEW带有OR REPLACE以下内容的语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW view_name</span><br><span class="line">AS</span><br><span class="line">query</span><br></pre></td></tr></table></figure>
<h5 id="更改视图示例"><a href="#更改视图示例" class="headerlink" title="更改视图示例"></a>更改视图示例</h5><blockquote>
<p>将电话号码添加到customer_master视图，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE VIEW customer_master AS</span></span><br><span class="line">  SELECT cu.customer_id AS id,</span><br><span class="line">    cu.first_name || <span class="string">' '</span> || cu.last_name AS name,</span><br><span class="line">    a.address,</span><br><span class="line">    city.city,</span><br><span class="line">    country.country,</span><br><span class="line">        CASE</span><br><span class="line">            WHEN cu.activebool THEN <span class="string">'active'</span></span><br><span class="line">            ELSE <span class="string">''</span></span><br><span class="line">        END AS notes,</span><br><span class="line">    a.phone</span><br><span class="line">   FROM customer cu</span><br><span class="line">     INNER JOIN address a USING (address_id)</span><br><span class="line">     INNER JOIN city USING (city_id)</span><br><span class="line">     INNER JOIN country USING (country_id);</span><br><span class="line">CREATE VIEW</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在，从customer_master视图中选择数据，您将在列表末尾看到phone列。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   customer_master;</span><br><span class="line">id  |         name          |                address                 |            city            |                country                | notes  |    phone     </span><br><span class="line">-----+-----------------------+----------------------------------------+----------------------------+---------------------------------------+--------+--------------</span><br><span class="line"> 524 | Jared Ely             | 1003 Qinhuangdao Street                | Purwakarta                 | Indonesia                             | active | 35533115997</span><br><span class="line">   1 | Mary Smith            | 1913 Hanoi Way                         | Sasebo                     | Japan                                 | active | 28303384290</span><br><span class="line">   2 | Patricia Johnson      | 1121 Loja Avenue                       | San Bernardino             | United States                         | active | 838635286649</span><br><span class="line">   3 | Linda Williams        | 692 Joliet Street                      | Athenai                    | Greece                                | active | 448477190408</span><br><span class="line">   4 | Barbara Jones         | 1566 Inegl Manor                       | Myingyan                   | Myanmar                               | active | 705814003527</span><br><span class="line">   5 | Elizabeth Brown       | 53 Idfu Parkway                        | Nantou                     | Taiwan                                | active | 10655648674</span><br><span class="line">   6 | Jennifer Davis        | 1795 Santiago de Compostela Way        | Laredo                     | United States                         | active | 860452626434</span><br><span class="line">   7 | Maria Miller          | 900 Santiago de Compostela Parkway     | Kragujevac                 | Yugoslavia                            | active | 716571220373</span><br><span class="line">   8 | Susan Wilson          | 478 Joliet Way                         | Hamilton                   | New Zealand                           | active | 657282285970</span><br><span class="line">   9 | Margaret Moore        | 613 Korolev Drive                      | Masqat                     | Oman                                  | active | 380657522649</span><br><span class="line">  10 | Dorothy Taylor        | 1531 Sal Drive                         | Esfahan                    | Iran                                  | active | 648856936185</span><br><span class="line">  11 | Lisa Anderson         | 1542 Tarlac Parkway                    | Sagamihara                 | Japan                                 | active | 635297277345</span><br><span class="line">  12 | Nancy Thomas          | 808 Bhopal Manor                       | Yamuna Nagar               | India                                 | active | 465887807014</span><br><span class="line">  13 | Karen Jackson         | 270 Amroha Parkway                     | Osmaniye                   | Turkey                                | active | 695479687538</span><br><span class="line">  14 | Betty White           | 770 Bydgoszcz Avenue                   | Citrus Heights             | United States                         | active | 517338314235</span><br><span class="line">  15 | Helen Harris          | 419 Iligan Lane                        | Bhopal                     | India                                 | active | 990911107354</span><br><span class="line">  16 | Sandra Martin         | 360 Toulouse Parkway                   | Southend-on-Sea            | United Kingdom                        | active | 949312333307</span><br><span class="line">  17 | Donna Thompson        | 270 Toulon Boulevard                   | Elista                     | Russian Federation                    | active | 407752414682</span><br><span class="line">  18 | Carol Garcia          | 320 Brest Avenue                       | Kaduna                     | Nigeria                               | active | 747791594069</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要更改视图的定义，请使用ALTER VIEW语句。例如，将视图的名称从customer_master更改为customer_info：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER VIEW customer_master RENAME TO customer_info;</span></span><br><span class="line">ALTER VIEW</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PostgreSQL允许您设置列名的默认值，更改视图的架构，设置或重置视图的选项。</p>
</blockquote>
<h4 id="删除PostgreSQL视图"><a href="#删除PostgreSQL视图" class="headerlink" title="删除PostgreSQL视图"></a>删除PostgreSQL视图</h4><blockquote>
<p>要删除PostgreSQL中的现有视图，请使用DROP VIEW语句，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW [ IF EXISTS ] view_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以在DROP VIEW子句之后指定要删除的视图的名称。删除数据库中不存在的视图将导致错误。为了避免这种情况，通常在语句中添加IF EXISTS选项，以指示PostgreSQL删除该视图（如果存在），否则，什么也不做。</p>
</blockquote>
<blockquote>
<p>例如，要删除已创建的customer_info视图，请执行以下查询：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DROP VIEW IF EXISTS customer_info;</span></span><br><span class="line">DROP VIEW</span><br></pre></td></tr></table></figure>
<h3 id="创建可更新视图"><a href="#创建可更新视图" class="headerlink" title="创建可更新视图"></a>创建可更新视图</h3><blockquote>
<p>满足以下条件的PostgreSQL视图是可更新的：</p>
<ul>
<li>视图的定义查询必须在FROM子句中恰好具有一个条目，该条目可以是表或另一个可更新的视图。</li>
</ul>
<ul>
<li>定义查询不得在顶层包含以下子句之一：GROUP BY，HAVING，LIMIT，OFFSET，DISTINCT，WITH，UNION，INTERSECT和EXCEPT。</li>
</ul>
<ul>
<li>选择列表不得包含任何窗口函数，任何返回集合的函数或任何聚合函数，例如SUM，COUNT，AVG，MIN和MAX。</li>
</ul>
</blockquote>
<blockquote>
<p>可更新视图可以同时包含可更新列和不可更新列。如果尝试插入或更新不可更新的列，PostgreSQL将引发错误。</p>
</blockquote>
<blockquote>
<p>当执行诸如INSERT，UPDATE或DELETE之类的更新操作时，PosgreSQL会将此语句转换为基础表的相应语句。</p>
</blockquote>
<blockquote>
<p>如果在视图的定义查询中有WHERE条件，仍然可以更新或删除在视图中不可见的行。但是，如果要避免这种情况，可以在定义视图时使用CHECK OPTION。</p>
</blockquote>
<blockquote>
<p>执行更新操作时，必须在视图上具有相应的特权，但不必在基础表上具有特权。但是，视图所有者必须具有基础表的相关特权。</p>
</blockquote>
<blockquote>
<p>使用CREATE VIEW语句创建一个新的可更新视图count:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE VIEW count AS SELECT</span></span><br><span class="line">   city,</span><br><span class="line">   country_id</span><br><span class="line">FROM</span><br><span class="line">   city</span><br><span class="line">WHERE</span><br><span class="line">   country_id = 103;</span><br><span class="line">CREATE VIEW</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接下来，通过执行以下SELECT语句检查count视图中的数据：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   count;</span><br><span class="line">          city           | country_id </span><br><span class="line">-------------------------+------------</span><br><span class="line"> Akron                   |        103</span><br><span class="line"> Arlington               |        103</span><br><span class="line"> Augusta-Richmond County |        103</span><br><span class="line"> Aurora                  |        103</span><br><span class="line"> Bellevue                |        103</span><br><span class="line"> Brockton                |        103</span><br><span class="line"> Cape Coral              |        103</span><br><span class="line"> Citrus Heights          |        103</span><br><span class="line"> Clarksville             |        103</span><br><span class="line"> Compton                 |        103</span><br><span class="line"> Dallas                  |        103</span><br><span class="line"> Dayton                  |        103</span><br><span class="line"> El Monte                |        103</span><br><span class="line"> Fontana                 |        103</span><br><span class="line"> Garden Grove            |        103</span><br><span class="line"> Garland                 |        103</span><br><span class="line"> Grand Prairie           |        103</span><br><span class="line"> Greensboro              |        103</span><br><span class="line"> Joliet                  |        103</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后，使用INSERT语句通过count视图将新城市插入到city表中：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO count (city, country_id)</span></span><br><span class="line">VALUES(<span class="string">'San Jose'</span>, 103);</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>之后，检查city表的内容：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   city,</span><br><span class="line">   country_id</span><br><span class="line">FROM</span><br><span class="line">   city</span><br><span class="line">WHERE</span><br><span class="line">   country_id = 103</span><br><span class="line">ORDER BY</span><br><span class="line">   last_update DESC;</span><br><span class="line">          city           | country_id </span><br><span class="line">-------------------------+------------</span><br><span class="line"> San Jose                |        103</span><br><span class="line"> Arlington               |        103</span><br><span class="line"> Augusta-Richmond County |        103</span><br><span class="line"> Aurora                  |        103</span><br><span class="line"> Bellevue                |        103</span><br><span class="line"> Brockton                |        103</span><br><span class="line"> Cape Coral              |        103</span><br><span class="line"> Citrus Heights          |        103</span><br><span class="line"> Clarksville             |        103</span><br><span class="line"> Compton                 |        103</span><br><span class="line"> Dallas                  |        103</span><br><span class="line"> Dayton                  |        103</span><br><span class="line"> El Monte                |        103</span><br><span class="line"> Fontana                 |        103</span><br><span class="line"> Garden Grove            |        103</span><br><span class="line"> Garland                 |        103</span><br><span class="line"> Grand Prairie           |        103</span><br><span class="line"> Greensboro              |        103</span><br><span class="line"> Akron                   |        103</span><br><span class="line">--More--</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">&gt; 最后，删除已通过count视图添加的条目。</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># DELETE</span></span><br><span class="line">FROM</span><br><span class="line">   count</span><br><span class="line">WHERE</span><br><span class="line">   city = <span class="string">'San Jose'</span>;</span><br><span class="line">DELETE 1</span><br></pre></td></tr></table></figure>
<h3 id="实例化视图"><a href="#实例化视图" class="headerlink" title="实例化视图"></a>实例化视图</h3><blockquote>
<p>PosgreSQL将视图概念扩展到了一个新级别，该视图允许视图物理存储数据，我们称这些视图为实例化视图。实例化视图缓存复杂的昂贵查询的结果，并允许定期刷新此结果。</p>
</blockquote>
<blockquote>
<p>实例化视图在许多需要快速访问数据的情况下很有用，因此它们通常用于数据仓库或商业智能应用程序中。</p>
</blockquote>
<h4 id="创建实例化视图"><a href="#创建实例化视图" class="headerlink" title="创建实例化视图"></a>创建实例化视图</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE MATERIALIZED VIEW view_name</span><br><span class="line">AS</span><br><span class="line">query</span><br><span class="line">WITH [NO] DATA;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，在CREATE MATERIALIZED VIEW子句之后指定view_name。</li>
</ul>
<ul>
<li>其次，在AS关键字之后添加从基础表获取数据的查询。</li>
</ul>
<ul>
<li>第三，如果要在创建时将数据加载到实例化视图中，请放置WITH DATA选项，否则放置WITH WITH DATA。如果使用WITH NO DATA，则该视图被标记为不可读。这意味着您无法从视图中查询数据，除非将数据加载到视图中。</li>
</ul>
<h4 id="刷新实例化视图的数据"><a href="#刷新实例化视图的数据" class="headerlink" title="刷新实例化视图的数据"></a>刷新实例化视图的数据</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REFRESH MATERIALIZED VIEW view_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当刷新实例化视图的数据时，PosgreSQL会锁定整个表，因此无法针对该表查询数据。为避免这种情况，可以使用CONCURRENTLY选项:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REFRESH MATERIALIZED VIEW CONCURRENTLY view_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>刷新实例化视图，而不会锁定实例化视图上的并发选择。没有此选项，影响很多行的刷新将倾向于使用较少的资源并更快地完成，但是可能会阻止其他尝试从实例化视图读取的连接。在少数行受到影响的情况下，此选项可能会更快。</p>
</blockquote>
<blockquote>
<p>使用CONCURRENTLY选项，PostgreSQL创建实例化视图的临时更新版本，比较两个版本，并仅执行差异中的INSERT和UPDATE。可以在实例化视图更新时对其进行查询。使用CONCURRENTLY选项的一项要求是，实例化视图必须具有UNIQUE索引。</p>
</blockquote>
<h4 id="删除实例化视图"><a href="#删除实例化视图" class="headerlink" title="删除实例化视图"></a>删除实例化视图</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP MATERIALIZED VIEW view_name;</span><br></pre></td></tr></table></figure>
<h4 id="实例化视图示例"><a href="#实例化视图示例" class="headerlink" title="实例化视图示例"></a>实例化视图示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE MATERIALIZED VIEW rental_by_category</span></span><br><span class="line">AS</span><br><span class="line">SELECT c.name AS category,</span><br><span class="line">    sum(p.amount) AS total_sales</span><br><span class="line">   FROM (((((payment p</span><br><span class="line">     JOIN rental r ON ((p.rental_id = r.rental_id)))</span><br><span class="line">     JOIN inventory i ON ((r.inventory_id = i.inventory_id)))</span><br><span class="line">     JOIN film f ON ((i.film_id = f.film_id)))</span><br><span class="line">     JOIN film_category <span class="built_in">fc</span> ON ((f.film_id = fc.film_id)))</span><br><span class="line">     JOIN category c ON ((fc.category_id = c.category_id)))</span><br><span class="line">  GROUP BY c.name</span><br><span class="line">  ORDER BY sum(p.amount) DESC</span><br><span class="line">WITH NO DATA;</span><br><span class="line">CREATE MATERIALIZED VIEW</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为使用了WITH NO DATA选项，所以无法从视图中查询数据。如果我们尝试这样做，则会收到如下错误消息：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   rental_by_category;</span><br><span class="line">错误:  物化视图 <span class="string">"rental_by_category"</span>未被初始化</span><br><span class="line">HINT:  使用命令 REFRESH MATERIALIZED VIEW.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>初始化视图</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># REFRESH MATERIALIZED VIEW rental_by_category;</span></span><br><span class="line">REFRESH MATERIALIZED VIEW</span><br></pre></td></tr></table></figure>
<blockquote>
<p>再次查询数据</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   rental_by_category;</span><br><span class="line">  category   | total_sales</span><br><span class="line">-------------+-------------</span><br><span class="line"> Sports      |     4892.19</span><br><span class="line"> Sci-Fi      |     4336.01</span><br><span class="line"> Animation   |     4245.31</span><br><span class="line"> Drama       |     4118.46</span><br><span class="line"> Comedy      |     4002.48</span><br><span class="line"> New         |     3966.38</span><br><span class="line"> Action      |     3951.84</span><br><span class="line"> Foreign     |     3934.47</span><br><span class="line"> Games       |     3922.18</span><br><span class="line"> Family      |     3830.15</span><br><span class="line"> Documentary |     3749.65</span><br><span class="line"> Horror      |     3401.27</span><br><span class="line"> Classics    |     3353.38</span><br><span class="line"> Children    |     3309.39</span><br><span class="line"> Travel      |     3227.36</span><br><span class="line"> Music       |     3071.52</span><br><span class="line">(16 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用REFRESH MATERIALIZED VIEW语句刷新rental_by_category视图中的数据。但是，要使用CONCURRENTLY选项刷新它，我们需要首先为视图创建一个UNIQUE索引。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE UNIQUE INDEX rental_category ON rental_by_category (category);</span></span><br><span class="line">CREATE INDEX</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同时为Rental_by_category视图刷新数据</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># REFRESH MATERIALIZED VIEW CONCURRENTLY rental_by_category;</span></span><br><span class="line">REFRESH MATERIALIZED VIEW</span><br></pre></td></tr></table></figure>
<h3 id="使用WITH-CHECK-OPTION子句创建可更新视图"><a href="#使用WITH-CHECK-OPTION子句创建可更新视图" class="headerlink" title="使用WITH CHECK OPTION子句创建可更新视图"></a>使用WITH CHECK OPTION子句创建可更新视图</h3><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><blockquote>
<p>创建一个名为usa_city的可更新视图</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE VIEW usa_city AS SELECT</span></span><br><span class="line">   city_id,</span><br><span class="line">   city,</span><br><span class="line">   country_id</span><br><span class="line">FROM</span><br><span class="line">   city</span><br><span class="line">WHERE</span><br><span class="line">   country_id = 103</span><br><span class="line">ORDER BY</span><br><span class="line">   city;</span><br><span class="line">CREATE VIEW</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过usa_city将新行插入到city表中</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO usa_city (city, country_id)</span></span><br><span class="line">VALUES (<span class="string">'Birmingham'</span>, 102);</span><br><span class="line"> </span><br><span class="line">INSERT INTO usa_city (city, country_id)</span><br><span class="line">VALUES (<span class="string">'Cambridge'</span>, 102);</span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了防止用户插入或更新在视图中不可见的行，请在创建视图时使用WITH CHECK OPTION子句。</p>
</blockquote>
<blockquote>
<p>更改usa_city视图，使其包含WITH CHECK OPTION子句</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE</span></span><br><span class="line">OR REPLACE VIEW usa_city AS SELECT</span><br><span class="line">   city_id,</span><br><span class="line">   city,</span><br><span class="line">   country_id</span><br><span class="line">FROM</span><br><span class="line">   city</span><br><span class="line">WHERE</span><br><span class="line">   country_id = 103</span><br><span class="line">ORDER BY</span><br><span class="line">   city WITH CHECK OPTION;</span><br><span class="line">CREATE VIEW</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更改城市ID将发生错误</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE usa_city</span></span><br><span class="line">SET country_id = 102</span><br><span class="line">WHERE</span><br><span class="line">   city_id = 135;</span><br><span class="line">错误:  新行违反了视图<span class="string">"usa_city"</span>的检查选项</span><br><span class="line">DETAIL:  失败, 行包含(135, Dallas, 102, 2019-12-04 22:21:33.039525).</span><br></pre></td></tr></table></figure>
<ul>
<li>这是因为UPDATE语句导致通过usa_city视图看不到正在更新的行。</li>
</ul>
<h4 id="用LOCAL和CASCADED检查的范围"><a href="#用LOCAL和CASCADED检查的范围" class="headerlink" title="用LOCAL和CASCADED检查的范围"></a>用LOCAL和CASCADED检查的范围</h4><blockquote>
<p>首先，创建一个视图，返回名称以字母A开头的所有城市。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE VIEW city_a AS SELECT</span></span><br><span class="line">   city_id,</span><br><span class="line">   city,</span><br><span class="line">   country_id</span><br><span class="line">FROM</span><br><span class="line">   city</span><br><span class="line">WHERE</span><br><span class="line">   city LIKE <span class="string">'A%'</span>;</span><br><span class="line">CREATE VIEW</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其次，创建另一个视图，以返回名称以字母A开头并位于美国的城市。该city_a_usa视图基于city_a视图。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE</span></span><br><span class="line">OR REPLACE VIEW city_a_usa AS SELECT</span><br><span class="line">   city_id,</span><br><span class="line">   city,</span><br><span class="line">   country_id</span><br><span class="line">FROM</span><br><span class="line">   city_a</span><br><span class="line">WHERE</span><br><span class="line">   country_id = 103</span><br><span class="line">WITH CASCADED CHECK OPTION;</span><br><span class="line">CREATE VIEW</span><br></pre></td></tr></table></figure>
<ul>
<li>city_a_usa视图具有WITH CASCADED CHECK OPTION子句。注意CASCADED选项。</li>
</ul>
<blockquote>
<p>通过city_a_usa表将一行插入到city表中。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO city_a_usa (city, country_id)</span></span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'Houston'</span>, 103);</span><br><span class="line">错误:  新行违反了视图<span class="string">"city_a"</span>的检查选项</span><br><span class="line">DETAIL:  失败, 行包含(606, Houston, 103, 2019-12-04 22:29:35.695079).</span><br></pre></td></tr></table></figure>
<ul>
<li>该错误消息表明，即使city_a视图没有WITH CHECK OPTION子句，也违反了city_a视图的视图定义条件。</li>
</ul>
<ul>
<li>这是因为当我们对city_a_usa视图使用WITH CASCADED CHECK OPTION时，PostgreSQL检查了city_a_usa视图以及所有基础视图的视图定义条件，在这种情况下，它是city_a视图。</li>
</ul>
<blockquote>
<p>要检查插入或更新的视图的视图定义条件，请按以下方式使用WITH LOCAL CHECK OPTION：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE VIEW city_a_usa AS SELECT</span></span><br><span class="line">   city_id,</span><br><span class="line">   city,</span><br><span class="line">   country_id</span><br><span class="line">FROM</span><br><span class="line">   city_a</span><br><span class="line">WHERE</span><br><span class="line">   country_id = 103</span><br><span class="line">WITH LOCAL CHECK OPTION;</span><br><span class="line">CREATE VIEW</span><br></pre></td></tr></table></figure>
<blockquote>
<p>再次通过city_a_usa视图在城市表中插入新行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO city_a_usa (city, country_id)</span></span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'Houston'</span>, 103);</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这次成功了，因为新行满足了city_a_usa视图的视图定义条件。PostgreSQL没有检查基本视图的视图定义条件。</p>
</blockquote>
<h3 id="创建递归视图"><a href="#创建递归视图" class="headerlink" title="创建递归视图"></a>创建递归视图</h3><h4 id="CREATE-RECURSIVE-VIEW语法"><a href="#CREATE-RECURSIVE-VIEW语法" class="headerlink" title="CREATE RECURSIVE VIEW语法"></a>CREATE RECURSIVE VIEW语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE RECURSIVE VIEW view_name(columns) AS</span><br><span class="line">SELECT columns;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，在CREATE RECURSIVE VIEW子句中指定要创建的视图的名称。可以在视图名称中添加一个可选的限定模式。</li>
</ul>
<ul>
<li>其次，添加SELECT语句以从基表中查询数据。SELECT语句引用view_name以使视图递归。</li>
</ul>
<blockquote>
<p>上面的该语句等效于以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW view_name</span><br><span class="line">AS</span><br><span class="line">  WITH RECURSIVE cte_name (columns) AS (</span><br><span class="line">    SELECT ...)</span><br><span class="line">  SELECT columns FROM cte_name;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    
    
    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="zhijiansd.github.io/blog/pg13/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhiJian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhiJian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/pg13/" class="post-title-link" itemprop="zhijiansd.github.io/index.html">PostgreSQL之触发器</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-20 13:21:31 / 修改时间：13:22:57" itemprop="dateCreated datePublished" datetime="2020-05-20T13:21:31+08:00">2020-05-20</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/postresql/" itemprop="url" rel="index"><span itemprop="name">postresql</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/pg13/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/pg13/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">6.2k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">10 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="PostgreSQL触发器"><a href="#PostgreSQL触发器" class="headerlink" title="PostgreSQL触发器"></a>PostgreSQL触发器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>PostgreSQL触发器是每当与表关联的事件发生时自动调用的函数。事件可以是以下任意事件：INSERT，UPDATE，DELETE或TRUNCATE。</p>
</blockquote>
<blockquote>
<p>触发器是绑定到表的特殊用户定义函数。要创建新的触发器，必须先定义一个触发器函数，然后将该触发器函数绑定到表。触发器和用户定义函数之间的区别在于，事件发生时会自动调用触发器。</p>
</blockquote>
<blockquote>
<p>PostgreSQL提供两种主要类型的触发器：行触发器和语句级触发器。两者之间的区别在于触发触发器的次数和时间。例如，如果发出UPDATE影响20行的语句，则行级触发器将被调用20次，而语句级触发器将被调用1次。</p>
</blockquote>
<blockquote>
<p>可以指定在事件之前还是之后调用触发器。如果在事件之前调用触发器，则它可以跳过当前行的操作，甚至可以更改要更新或插入的行。如果在事件之后调用触发器，则所有更改都可用于触发器。</p>
</blockquote>
<blockquote>
<p>在各种应用程序访问数据库的情况下，触发器是有用的，并且您希望将跨功能保留在数据库中，该数据库可以在修改表的数据时自动运行。例如，如果想保留数据历史记录，而无需应用程序具有检查每个事件（例如INSERT或UDPATE）的逻辑。</p>
</blockquote>
<blockquote>
<p>还可以使用触发器来维护复杂的数据完整性规则，只有在数据库级别才能在其他地方实现。例如，当在customer表中添加新行时，还必须在银行和贷方表中创建其他行。</p>
</blockquote>
<blockquote>
<p>使用触发器的主要缺点是，您必须知道触发器的存在并了解其逻辑，以便找出数据更改时的影响。</p>
</blockquote>
<blockquote>
<p>即使PostgreSQL实现了SQL标准，PostgreSQL中的触发器也具有一些特定的功能，如下所示：</p>
<ul>
<li>PostgreSQL触发TRUNCATE事件的触发器  。</li>
</ul>
<ul>
<li>PostgreSQL允许在视图上定义语句级触发器。</li>
</ul>
<ul>
<li>PostgreSQL要求定义用户定义的函数作为触发器的动作，而SQL标准允许使用任何数量的SQL命令。</li>
</ul>
</blockquote>
<h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><blockquote>
<p>要在PostgreSQL中创建新的触发器，请按照以下步骤操作：</p>
<ul>
<li>首先，使用CREATE FUNCTION语句创建触发函数。</li>
</ul>
<ul>
<li>其次，使用CREATE TRIGGER语句将触发器函数绑定到表。<br>如果不熟悉创建用户定义的函数，则可以查看存储过程部分。</li>
</ul>
</blockquote>
<h4 id="创建触发功能"><a href="#创建触发功能" class="headerlink" title="创建触发功能"></a>创建触发功能</h4><blockquote>
<p>触发功能类似于普通功能。但是，触发器函数不带任何参数，并且具有触发器类型的返回值。</p>
</blockquote>
<blockquote>
<p>创建触发函数的语法：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION trigger_function()</span><br><span class="line">   RETURNS trigger AS</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以使用PostgreSQL支持的任何语言创建触发函数。</p>
</blockquote>
<blockquote>
<p>触发函数通过称为TriggerData的特殊结构接收有关其调用环境的数据，该结构包含一组局部变量。例如，OLD和NEW表示触发事件之前或之后表中行的状态。PostgreSQL提供了以TG_开头的其他局部变量作为前缀，例如TG_WHEN和TG_TABLE_NAME。</p>
</blockquote>
<blockquote>
<p>定义触发函数后，可以将其绑定到一个或多个触发事件，例如INSERT，UPDATE和DELETE。</p>
</blockquote>
<h4 id="CREATE-TRIGGER语句"><a href="#CREATE-TRIGGER语句" class="headerlink" title="CREATE TRIGGER语句"></a>CREATE TRIGGER语句</h4><blockquote>
<p>CREATE TRIGGER语句创建一个新的触发器。CREATE TRIGGER的完整语法非常复杂，有很多选项。如下所示为CREATE TRIGGER语法的基本形式：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name</span><br><span class="line">&#123;BEFORE | AFTER | INSTEAD OF&#125; &#123;event [OR ...]&#125;</span><br><span class="line">   ON table_name</span><br><span class="line">   [FOR [EACH] &#123;ROW | STATEMENT&#125;]</span><br><span class="line">       EXECUTE PROCEDURE trigger_function</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该事件可以是INSERT，UPDATE，DELETE或TRUNCATE。可以定义在事件之前（BEFORE）之前或之后（AFTER）触发的触发器。INSTEAD OF仅用于视图上的INSERT，UPDATE或DELETE。</p>
</blockquote>
<blockquote>
<p>PostgreSQL支持两种触发器：行级触发器和语句级触发器，可以由FOR EACH ROW（行级触发器）子句和FOR EACH STATEMENT（语句级触发器）指定。</p>
</blockquote>
<h4 id="触发器示例"><a href="#触发器示例" class="headerlink" title="触发器示例"></a>触发器示例</h4><ul>
<li>创建表</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE employees(</span></span><br><span class="line">   id SERIAL PRIMARY KEY,</span><br><span class="line">   first_name VARCHAR(40) NOT NULL,</span><br><span class="line">   last_name VARCHAR(40) NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<ul>
<li>当员工的姓名更改时，我们将更改记录在名为employee_audits的单独表中：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE employee_audits (</span></span><br><span class="line">   id SERIAL PRIMARY KEY,</span><br><span class="line">   employee_id INT NOT NULL,</span><br><span class="line">   last_name VARCHAR(40) NOT NULL,</span><br><span class="line">   changed_on TIMESTAMP(6) NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，定义一个名为log_last_name_changes的新函数：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE FUNCTION log_last_name_changes()</span></span><br><span class="line">  RETURNS trigger AS</span><br><span class="line"><span class="variable">$BODY</span>$</span><br><span class="line">BEGIN</span><br><span class="line">   IF NEW.last_name &lt;&gt; OLD.last_name THEN</span><br><span class="line">       INSERT INTO employee_audits(employee_id,last_name,changed_on)</span><br><span class="line">       VALUES(OLD.id,OLD.last_name,now());</span><br><span class="line">   END IF;</span><br><span class="line"> </span><br><span class="line">   RETURN NEW;</span><br><span class="line">END;</span><br><span class="line"><span class="variable">$BODY</span>$ LANGUAGE plpgsql;</span><br><span class="line">CREATE FUNCTION</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该函数将旧的姓氏插入到employee_audits表中，其中包括员工ID，姓氏以及员工姓氏更改时的更改时间。</p>
</blockquote>
<blockquote>
<p>其次，将触发功能绑定到employees表。触发器名称为last_name_changes。在更新last_name列的值之前，将自动调用触发函数以记录更改。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TRIGGER last_name_changes</span></span><br><span class="line">  BEFORE UPDATE</span><br><span class="line">  ON employees</span><br><span class="line">  FOR EACH ROW</span><br><span class="line">  EXECUTE PROCEDURE log_last_name_changes();</span><br><span class="line">CREATE TRIGGER</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三，将两行插入到employees表中:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO employees (first_name, last_name)</span></span><br><span class="line">VALUES (<span class="string">'Michael'</span>, <span class="string">'Jordan'</span>);</span><br><span class="line"> </span><br><span class="line">INSERT INTO employees (first_name, last_name)</span><br><span class="line">VALUES (<span class="string">'James'</span>, <span class="string">'Harden'</span>);</span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line">INSERT 0 </span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT * FROM employees;</span></span><br><span class="line"> id | first_name | last_name</span><br><span class="line">----+------------+-----------</span><br><span class="line">  1 | Michael    | Jordan</span><br><span class="line">  2 | James      | Harden</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>假设James Harden想将名字更改为James Louis，如以下查询所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE employees</span></span><br><span class="line">SET last_name = <span class="string">'Louis'</span></span><br><span class="line">WHERE ID = 2;</span><br><span class="line">UPDATE 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT * FROM employees;</span></span><br><span class="line"> id | first_name | last_name</span><br><span class="line">----+------------+-----------</span><br><span class="line">  1 | Michael    | Jordan</span><br><span class="line">  2 | James      | Louis</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>验证employee_audits表的内容</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT *</span></span><br><span class="line">FROM employee_audits;</span><br><span class="line"> id | employee_id | last_name |        changed_on</span><br><span class="line">----+-------------+-----------+---------------------------</span><br><span class="line">  1 |           2 | Harden    | 2019-12-04 14:33:00.21562</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<ul>
<li>更改已由触发器记录在employee_audits表中。</li>
</ul>
<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><h4 id="DROP-TRIGGER语法"><a href="#DROP-TRIGGER语法" class="headerlink" title="DROP TRIGGER语法"></a>DROP TRIGGER语法</h4><blockquote>
<p>要从表中删除触发器，请使用DROP TRIGGER语句:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER [IF EXISTS] trigger_name</span><br><span class="line">ON table_name [ CASCADE | RESTRICT ];</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，在DROP TRIGGER关键字之后指定要删除的触发器的名称。</li>
</ul>
<ul>
<li>其次，仅在触发器存在时使用IF EXISTS有条件地删除它。尝试删除不存在的触发器而不指定IF EXISTS语句会导致错误。如果使用IF EXISTS删除不存在的触发器，则PostgreSQL会发出通知。</li>
</ul>
<ul>
<li>第三，指定触发器所属的表的名称。如果表属于特定架构，则可以使用表的架构限定名称，例如schema_name.table_name。</li>
</ul>
<ul>
<li>第四，如果要自动删除依赖触发器的对象，请使用CASCADE选项。请注意，CASCADE选项还将删除依赖于依赖触发器的对象的对象。</li>
</ul>
<ul>
<li>第五，如果任何对象依赖触发器，请使用RESTRICT TO拒绝删除触发器。默认情况下，DROP TRIGGER语句使用RESTRICT。</li>
</ul>
<blockquote>
<p>请注意，在SQL标准中，触发器名称不是表本地的，因此该语句很简单：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER trigger_name;</span><br></pre></td></tr></table></figure>
<h4 id="DROP-TRIGGER示例"><a href="#DROP-TRIGGER示例" class="headerlink" title="DROP TRIGGER示例"></a>DROP TRIGGER示例</h4><blockquote>
<p>创建一个用于验证职员用户名的函数。staff的用户名不能为null，长度至少为8。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE FUNCTION check_staff_user()</span></span><br><span class="line">    RETURNS TRIGGER</span><br><span class="line">AS $$</span><br><span class="line">BEGIN</span><br><span class="line">    IF length(NEW.username) &lt; 8 OR NEW.username IS NULL THEN</span><br><span class="line">        RAISE EXCEPTION <span class="string">'The username cannot be less than 8 characters'</span>;</span><br><span class="line">    END IF;</span><br><span class="line">    IF NEW.NAME IS NULL THEN</span><br><span class="line">        RAISE EXCEPTION <span class="string">'Username cannot be NULL'</span>;</span><br><span class="line">    END IF;</span><br><span class="line">    RETURN NEW;</span><br><span class="line">END;</span><br><span class="line">$$</span><br><span class="line">LANGUAGE plpgsql;</span><br><span class="line">CREATE FUNCTION</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其次，在staff表上创建一个新触发器，以检查职员的用户名。每当在staff表中插入或更新一行时（从示例数据库中），将触发此触发器：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TRIGGER username_check</span></span><br><span class="line">    BEFORE INSERT OR UPDATE</span><br><span class="line">ON staff</span><br><span class="line">FOR EACH ROW</span><br><span class="line">    EXECUTE PROCEDURE check_staff_user();</span><br><span class="line">CREATE TRIGGER</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三，使用DROP TRIGGER语句删除username_check触发器：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DROP TRIGGER username_check</span></span><br><span class="line">ON staff;</span><br><span class="line">DROP TRIGGER</span><br></pre></td></tr></table></figure>
<h3 id="管理触发器"><a href="#管理触发器" class="headerlink" title="管理触发器"></a>管理触发器</h3><h4 id="修改触发器"><a href="#修改触发器" class="headerlink" title="修改触发器"></a>修改触发器</h4><blockquote>
<p>要修改触发器，请使用ALTER TRIGGER语句。该语句是SQL标准的PostgreSQL扩展。ALTER TRIGGER语句的语法如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TRIGGER trigger_name ON table_name</span><br><span class="line">RENAME TO new_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，指定与要更改的特定表关联的触发器的名称。</li>
</ul>
<ul>
<li>其次，将新的触发器名称放在RENAME TO子句中。</li>
</ul>
<blockquote>
<p>例如，如果要将与employees表关联的last_name_changes触发器更改为log_last_name_changes，则可以使用ALTER TRIGGER语句，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TRIGGER last_name_changes</span></span><br><span class="line">ON employees</span><br><span class="line">RENAME TO log_last_name_changes;</span><br><span class="line">ALTER TRIGGER</span><br></pre></td></tr></table></figure>
<h4 id="禁用触发器"><a href="#禁用触发器" class="headerlink" title="禁用触发器"></a>禁用触发器</h4><blockquote>
<p>PostgreSQL没有提供任何特定的语句（例如DISABLE TRIGGER）来禁用现有触发器。但是，可以使用ALTER TABLE语句禁用触发器，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">DISABLE TRIGGER trigger_name | ALL</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用该语法，可以在DISABLE TRIGGER关键字之后指定要禁用的触发器的名称。要禁用与表关联的所有触发器，请使用ALL而不是特定的触发器名称。</p>
</blockquote>
<blockquote>
<p>注意，禁用的触发器在数据库中仍然可用。但是，触发事件发生时不会触发。</p>
</blockquote>
<blockquote>
<p>假设要禁用与employeestable相关联的log_last_name_changes触发器，可以使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE employees</span></span><br><span class="line">DISABLE TRIGGER log_last_name_changes;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要禁用与employees表关联的所有触发器，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE employees</span></span><br><span class="line">DISABLE TRIGGER ALL;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<h4 id="删除触发器-1"><a href="#删除触发器-1" class="headerlink" title="删除触发器"></a>删除触发器</h4><blockquote>
<p>要删除现有的触发器，请使用DROP TRIGGER语句，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER [IF EXISTS] trigger_name</span><br><span class="line">ON table_name [RESTRICT | CASCADE]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用该语法，可以在DROP TRIGGER子句和与触发器关联的表之后指定要删除的触发器名称。</p>
</blockquote>
<blockquote>
<p>为避免删除不存在的触发器的错误，请使用IF EXISTS选项。</p>
</blockquote>
<blockquote>
<p>例如，以下语句从employee表中删除log_last_name_changes触发器：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DROP TRIGGER log_last_name_changes</span></span><br><span class="line">ON employees;</span><br><span class="line">DROP TRIGGER</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    
    
    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="zhijiansd.github.io/blog/pg12/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhiJian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhiJian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/pg12/" class="post-title-link" itemprop="zhijiansd.github.io/index.html">PostgreSQL之存储过程</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-20 13:03:16 / 修改时间：13:18:28" itemprop="dateCreated datePublished" datetime="2020-05-20T13:03:16+08:00">2020-05-20</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/postresql/" itemprop="url" rel="index"><span itemprop="name">postresql</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/pg12/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/pg12/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">32k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">53 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="PostgreSQL存储过程"><a href="#PostgreSQL存储过程" class="headerlink" title="PostgreSQL存储过程"></a>PostgreSQL存储过程</h2><blockquote>
<p>在PostgreSQL中，过程语言（例如PL/pgSQL，C，Perl，Python和Tcl）被称为存储过程。该过程添加了许多过程元素，例如控制结构，循环和复杂的计算，以扩展SQL标准。它使您可以在PostgreSQL中开发复杂的功能和存储过程，而这是使用普通SQL可能无法实现的。</p>
</blockquote>
<blockquote>
<p>这里将重点介绍与Oracle PL/SQL相似的PL/pgSQL过程语言。以下是选择PL/pgSQL的原因：</p>
<ul>
<li>PL/pgSQL简单易学。</li>
</ul>
<ul>
<li>PostgreSQL默认附带PL/pgSQL。在PL/pgSQL中开发的用户定义函数可以像任何内置函数一样使用。</li>
</ul>
<ul>
<li>PL/pgSQL具有许多功能，可让您开发复杂的用户定义函数。</li>
</ul>
</blockquote>
<h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><blockquote>
<p>PostgreSQL允许使用各种过程语言元素（通常称为存储过程）使用用户定义的函数和存储过程来扩展数据库功能。</p>
</blockquote>
<blockquote>
<p>存储过程定义用于创建触发器的功能或自定义聚合功能。此外，存储过程还添加了许多过程功能，例如控制结构和复杂的计算。这些使您可以更轻松，更有效地开发自定义功能。</p>
</blockquote>
<blockquote>
<p>可以使用DO命令调用过程代码块，而无需定义函数或存储过程。</p>
</blockquote>
<blockquote>
<p>PostgreSQL将过程语言分为两大类：</p>
<ul>
<li>任何用户都可以使用安全语言。SQL和PL/pgSQL是安全的语言。</li>
</ul>
<ul>
<li>沙盒语言仅由超级用户使用，因为沙盒语言提供了绕过安全性并允许访问外部源的功能。C是沙盒语言的示例。</li>
</ul>
</blockquote>
<blockquote>
<p>缺省情况下，PostgreSQL支持三种过程语言：SQL，PL/pgSQL和C。还可以使用扩展将其他过程语言（例如Perl，Python和TCL）加载到PostgreSQL中。</p>
</blockquote>
<h4 id="使用PostgreSQL存储过程的优点"><a href="#使用PostgreSQL存储过程的优点" class="headerlink" title="使用PostgreSQL存储过程的优点"></a>使用PostgreSQL存储过程的优点</h4><ul>
<li>减少应用程序和数据库服务器之间的往返次数。所有SQL语句都包装在存储在PostgreSQL数据库服务器中的函数内，因此应用程序仅需发出函数调用即可返回结果，而不必发送多个SQL语句并等待每次调用之间的结果。</li>
</ul>
<ul>
<li>由于用户定义的函数和存储过程已预编译并存储在PostgreSQL数据库服务器中，因此提高了应用程序性能。</li>
</ul>
<ul>
<li>可在许多应用程序中重用。一旦开发了功能，就可以在任何应用程序中重用它。</li>
</ul>
<h4 id="使用PostgreSQL存储过程的缺点"><a href="#使用PostgreSQL存储过程的缺点" class="headerlink" title="使用PostgreSQL存储过程的缺点"></a>使用PostgreSQL存储过程的缺点</h4><ul>
<li>由于存储过程编程需要许多开发人员不具备的专业技能，因此软件开发速度缓慢。</li>
</ul>
<ul>
<li>难以管理版本且难以调试。</li>
</ul>
<ul>
<li>可能无法移植到其他数据库管理系统，例如MySQL或Microsoft SQL Server。</li>
</ul>
<h3 id="PL-pgSQL块结构"><a href="#PL-pgSQL块结构" class="headerlink" title="PL/pgSQL块结构"></a>PL/pgSQL块结构</h3><blockquote>
<p>PL/pgSQL是一种块结构语言，因此，PL/pgSQL函数或存储过程被组织为块。</p>
</blockquote>
<h4 id="PL-pgSQL的语法"><a href="#PL-pgSQL的语法" class="headerlink" title="PL/pgSQL的语法"></a>PL/pgSQL的语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ &lt;&lt;label&gt;&gt; ]</span><br><span class="line">[ DECLARE</span><br><span class="line">    declarations ]</span><br><span class="line">BEGIN</span><br><span class="line">    statements;</span><br><span class="line">   ...</span><br><span class="line">END [ label ];</span><br></pre></td></tr></table></figure>
<ul>
<li>每个块都有两个部分:声明和正文。声明部分是可选的，而主体部分是必需的。该块以END关键字后的分号（;）结尾。</li>
</ul>
<ul>
<li>块的开头和结尾可能有可选标签。如果要EXIT在块主体的语句中指定它，或者要限定在块中声明的变量的名称，请使用块标签。</li>
</ul>
<ul>
<li>在声明部分，您可以声明主体部分中使用的所有变量。声明部分中的每个语句均以分号（;）结尾。</li>
</ul>
<ul>
<li>正文部分是您放置代码的地方。主体部分中的每个语句也以分号（;）终止。</li>
</ul>
<h4 id="PL-pgSQL块结构示例"><a href="#PL-pgSQL块结构示例" class="headerlink" title="PL/pgSQL块结构示例"></a>PL/pgSQL块结构示例</h4><blockquote>
<p>匿名块</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DO $$</span></span><br><span class="line">&lt;&lt;first_block&gt;&gt;</span><br><span class="line">DECLARE</span><br><span class="line">  counter <span class="built_in">integer</span> := 0;</span><br><span class="line">BEGIN</span><br><span class="line">   counter := counter + 1;</span><br><span class="line">   RAISE NOTICE <span class="string">'The current value of counter is %'</span>, counter;</span><br><span class="line">END first_block $$;</span><br><span class="line">注意:  The current value of counter is 1</span><br><span class="line">DO</span><br></pre></td></tr></table></figure>
<ul>
<li>请注意，DO语句不属于该块。它用于执行匿名块。</li>
</ul>
<ul>
<li>在声明部分，声明了一个变量counter并将其值设置为零。</li>
</ul>
<ul>
<li>在主体部分内部，将计数器的值增加到1并使用RAISE NOTICE语句输出其值。</li>
</ul>
<ul>
<li>first_block标签仅用于演示目的。在此示例中，它什么也不做。</li>
</ul>
<blockquote>
<p>双美元（$$）是单引号（’）的替代。开发PL/pgSQL块，函数或存储过程时，必须以字符串文字形式传递其主体。如果您使用双美元（$$），则可以避免引用问题。您也可以在$$之间使用令牌，例如$function$或$procedure$。</p>
</blockquote>
<h4 id="PL-pgSQL子块"><a href="#PL-pgSQL子块" class="headerlink" title="PL/pgSQL子块"></a>PL/pgSQL子块</h4><blockquote>
<p>PL/pgSQL允许您将一个块放置在另一个块的主体内。嵌套在另一个块内的该块称为子块。包含子块的块称为外部块。</p>
</blockquote>
<blockquote>
<p>子块用于对语句进行分组，以便可以将大块划分为较小和更多的逻辑子块。子块中的变量可以具有与外部块中的变量相同的名称，即使这不是一个好习惯。</p>
</blockquote>
<blockquote>
<p>当在子块中声明与外部块中名称相同的变量时，外部块中的变量将隐藏在子块中。如果要访问外部块中的变量，请使用块标签来限定其名称，如以下示例所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DO $$</span></span><br><span class="line">&lt;&lt;outer_block&gt;&gt;</span><br><span class="line">DECLARE</span><br><span class="line">  counter <span class="built_in">integer</span> := 0;</span><br><span class="line">BEGIN</span><br><span class="line">   counter := counter + 1;</span><br><span class="line">   RAISE NOTICE <span class="string">'The current value of counter is %'</span>, counter;</span><br><span class="line"> </span><br><span class="line">   DECLARE</span><br><span class="line">       counter <span class="built_in">integer</span> := 0;</span><br><span class="line">   BEGIN</span><br><span class="line">       counter := counter + 10;</span><br><span class="line">       RAISE NOTICE <span class="string">'The current value of counter in the subblock is %'</span>, counter;</span><br><span class="line">       RAISE NOTICE <span class="string">'The current value of counter in the outer block is %'</span>, outer_block.counter;</span><br><span class="line">   END;</span><br><span class="line"> </span><br><span class="line">   RAISE NOTICE <span class="string">'The current value of counter in the outer block is %'</span>, counter;</span><br><span class="line">  </span><br><span class="line">END outer_block $$;</span><br><span class="line">注意:  The current value of counter is 1</span><br><span class="line">注意:  The current value of counter <span class="keyword">in</span> the subblock is 10</span><br><span class="line">注意:  The current value of counter <span class="keyword">in</span> the outer block is 1</span><br><span class="line">注意:  The current value of counter <span class="keyword">in</span> the outer block is 1</span><br><span class="line">DO</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，我们在outer_block中声明了一个名为counter的变量。</li>
</ul>
<ul>
<li>接下来，在子块中，我们还声明了一个具有相同名称的变量。</li>
</ul>
<ul>
<li>然后，在进入子块之前，计数器的值为1。在子块中，我们将计数器的值增加到10并打印出来。注意，更改仅影响子块中的计数器变量。</li>
</ul>
<ul>
<li>之后，我们使用块标签在外部块中引用计数器变量，以限定其名称external_block.counter。</li>
</ul>
<ul>
<li>最后，我们在外部块中打印出计数器变量的值，其值保持不变。</li>
</ul>
<h3 id="PL-pgSQL变量"><a href="#PL-pgSQL变量" class="headerlink" title="PL/pgSQL变量"></a>PL/pgSQL变量</h3><blockquote>
<p>PL/pgSQL变量是内存位置的有意义的名称。变量保存一个可以通过块或功能更改的值。变量始终与特定的数据类型相关联。</p>
</blockquote>
<blockquote>
<p>在使用变量之前，必须在PL/pgSQL块的声明部分中对其进行声明。声明变量的语法:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable_name data_type [:= expression];</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，指定变量的名称。将有意义的名称分配给变量是一个好习惯。例如，应该使用index或i代替命名变量counter。</li>
</ul>
<ul>
<li>其次，将特定的数据类型与变量关联。数据类型可以是任何有效的PostgreSQL数据类型，例如INTEGER，NUMERIC，VARCHAR和CHAR。</li>
</ul>
<ul>
<li>第三，可选地为变量分配默认值。如果不这样做，则变量的初始值将初始化为NULL。</li>
</ul>
<blockquote>
<p>声明和初始化各种变量</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DO $$</span><br><span class="line">DECLARE</span><br><span class="line">   counter    INTEGER := 1;</span><br><span class="line">   first_name VARCHAR(50) := <span class="string">'John'</span>;</span><br><span class="line">   last_name  VARCHAR(50) := <span class="string">'Doe'</span>;</span><br><span class="line">   payment    NUMERIC(11,2) := 20.5;</span><br><span class="line">BEGIN</span><br><span class="line">   RAISE NOTICE <span class="string">'% % % has been paid % USD'</span>, counter, first_name, last_name, payment;</span><br><span class="line">END $$;</span><br></pre></td></tr></table></figure>
<ul>
<li>counter变量是被初始化为1的整数</li>
</ul>
<ul>
<li>first_name和last_name是VARCHAR，50个字符，并初始化John和Doe文字字符串。</li>
</ul>
<ul>
<li>payment是有两个小数数字和初始化20.5<blockquote>
<p>请注意，当输入该块时，PostgreSQL将评估默认值并为变量设置它们。</p>
</blockquote>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DO $$</span></span><br><span class="line">DECLARE</span><br><span class="line">   created_at time := NOW();</span><br><span class="line">BEGIN</span><br><span class="line">   RAISE NOTICE <span class="string">'%'</span>, created_at;</span><br><span class="line">   PERFORM pg_sleep(10);</span><br><span class="line">   RAISE NOTICE <span class="string">'%'</span>, created_at;</span><br><span class="line">END $$;</span><br><span class="line">注意:  23:07:05.060536</span><br><span class="line">注意:  23:07:05.060536</span><br><span class="line">DO</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，声明一个变量，其默认值初始化为当前时间。</li>
</ul>
<ul>
<li>其次，打印出变量的值并在10秒内暂停执行</li>
</ul>
<ul>
<li>第三，再次打印出created_at变量的值。</li>
</ul>
<h4 id="复制数据类型"><a href="#复制数据类型" class="headerlink" title="复制数据类型"></a>复制数据类型</h4><blockquote>
<p>PostgreSQL使您可以定义一个数据类型的变量，该数据类型引用表的列的数据类型或另一个变量的数据类型：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable_name table_name.column_name%TYPE;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable_name variable%TYPE;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>定义一个变量city_name，其名称name与city表的列名称相同，其数据类型如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">city_name city.name%TYPE := <span class="string">'San Francisco'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过使用复制类型功能，您可以获得以下优点：</p>
<ul>
<li>首先，您无需关心列的数据类型。您声明一个变量以仅保留查询中该列的值。</li>
</ul>
<ul>
<li>其次，当列的数据类型更改时，您无需更改函数中的变量声明即可适应新的更改。</li>
</ul>
<ul>
<li>第三，由于内部变量的类型可以从一个调用更改为另一个调用，因此可以将变量的类型引用为函数参数的数据类型以创建多态函数。</li>
</ul>
</blockquote>
<h4 id="为变量分配别名"><a href="#为变量分配别名" class="headerlink" title="为变量分配别名"></a>为变量分配别名</h4><blockquote>
<p>PostgreSQL允许您为任何变量定义别名，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_name ALIAS FOR old_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>别名主要用于触发过程中，以便为具有预定名称（例如NEW或OLD）的变量分配更有意义的名称。</p>
</blockquote>
<h3 id="PL-pgSQL常量"><a href="#PL-pgSQL常量" class="headerlink" title="PL/pgSQL常量"></a>PL/pgSQL常量</h3><blockquote>
<p>与变量不同，常量的值一旦初始化就无法更改。以下是使用常量的原因:</p>
</blockquote>
<ul>
<li>首先，常量使代码更具可读性。例如，假设我们有一个公式如下:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">price = net_price * 0.8;</span><br></pre></td></tr></table></figure>
<ul>
<li>0.8是什么意思？ 它可以解释为任何东西。但是，我们可以为其赋予其折扣的的含义:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">price = net_price * ZK;</span><br></pre></td></tr></table></figure>
<ul>
<li>其次，常量减少了维护工作，假设您在函数中具有用于计算价格的公式。当折扣从例如0.8更改为0.9时，您需要更改所有这些硬编码值。但是，通过使用常量，您只需要在声明和初始化常量的一个地方进行更改。</li>
</ul>
<h4 id="声明常量语法"><a href="#声明常量语法" class="headerlink" title="声明常量语法"></a>声明常量语法</h4><blockquote>
<p>要在PL/pgSQL中声明一个常量，请使用以下语法：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constant_name CONSTANT data_type := expression;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，指定常量名称。按照惯例，它采用大写形式，例如ZK和DISCOUNT。</li>
</ul>
<ul>
<li>其次，放置CONSTANT关键字并指定与常量关联的数据类型。</li>
</ul>
<ul>
<li>第三，为常量初始化一个值。</li>
</ul>
<h4 id="PL-pgSQL常量示例"><a href="#PL-pgSQL常量示例" class="headerlink" title="PL/pgSQL常量示例"></a>PL/pgSQL常量示例</h4><blockquote>
<p>为折扣声明一个名为zk的常量，并根据净价计算售价：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DO $$</span></span><br><span class="line">DECLARE</span><br><span class="line">   ZK CONSTANT NUMERIC := 0.8;</span><br><span class="line">   net_price    NUMERIC := 50;</span><br><span class="line">BEGIN</span><br><span class="line">   RAISE NOTICE <span class="string">'The price is %'</span>, net_price * ZK ;</span><br><span class="line">END $$;</span><br><span class="line">注意:  The price is 40.0</span><br><span class="line">DO</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在，尝试如下更改常量的值出现错误:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DO $$</span></span><br><span class="line">DECLARE</span><br><span class="line">   ZK constant NUMERIC := 0.8;</span><br><span class="line">   net_price    NUMERIC := 50;</span><br><span class="line">BEGIN</span><br><span class="line">   RAISE NOTICE <span class="string">'The price is %'</span>, net_price * ZK ;</span><br><span class="line">   ZK := 0.85;</span><br><span class="line">END $$;</span><br><span class="line">错误:  变量<span class="string">"zk"</span>被声明为常量</span><br><span class="line">LINE 7:    ZK := 0.85;</span><br><span class="line">           ^</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，当在运行时而不是编译时输入该块时，PostgreSQL会计算常量的值。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DO $$</span></span><br><span class="line">DECLARE</span><br><span class="line">   start_at CONSTANT time := now();</span><br><span class="line">BEGIN</span><br><span class="line">   RAISE NOTICE <span class="string">'Start executing block at %'</span>, start_at;</span><br><span class="line">END $$;</span><br><span class="line">注意:  Start executing block at 11:38:34.260159</span><br><span class="line">DO</span><br></pre></td></tr></table></figure>
<blockquote>
<p>每次我们调用该块时，PostgreSQL都会评估NOW()函数。为了证明这一点，我们再次执行该块:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DO $$</span></span><br><span class="line">DECLARE</span><br><span class="line">   start_at CONSTANT time := now();</span><br><span class="line">BEGIN</span><br><span class="line">   RAISE NOTICE <span class="string">'Start executing block at %'</span>, start_at;</span><br><span class="line">END $$;</span><br><span class="line">注意:  Start executing block at 11:39:52.209155</span><br><span class="line">DO</span><br></pre></td></tr></table></figure>
<h3 id="PL-pgSQL错误和消息"><a href="#PL-pgSQL错误和消息" class="headerlink" title="PL/pgSQL错误和消息"></a>PL/pgSQL错误和消息</h3><blockquote>
<p>要发出消息，请使用RAISE语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAISE level format;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在RAISE语句之后是用于指定错误严重性的级别选项。PostgreSQL有以下级别：</p>
<ul>
<li>DEBUG(调试)</li>
</ul>
<ul>
<li>LOG(日志)</li>
</ul>
<ul>
<li>NOTICE(注意)</li>
</ul>
<ul>
<li>INFO(信息)</li>
</ul>
<ul>
<li>WARNING(警告)</li>
</ul>
<ul>
<li>EXCEPTION(例外)</li>
</ul>
</blockquote>
<blockquote>
<p>如果您未指定级别，则默认情况下，RAISE语句将使用EXCEPTION级别，这会引发错误并停止并停止当前事务。</p>
</blockquote>
<blockquote>
<p>格式是指定消息的字符串。该格式使用百分比(%)占位符，这些占位符将由下一个参数替换。占位符的数量必须与参数的数量匹配，否则，PostgreSQL将报告错误消息。</p>
</blockquote>
<blockquote>
<p>以下示例说明了RAISE语句，该语句在当前时间报告不同的消息:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DO $$</span></span><br><span class="line">BEGIN</span><br><span class="line">  RAISE INFO <span class="string">'information message %'</span>, now() ;</span><br><span class="line">  RAISE LOG <span class="string">'log message %'</span>, now();</span><br><span class="line">  RAISE DEBUG <span class="string">'debug message %'</span>, now();</span><br><span class="line">  RAISE WARNING <span class="string">'warning message %'</span>, now();</span><br><span class="line">  RAISE NOTICE <span class="string">'notice message %'</span>, now();</span><br><span class="line">END $$;</span><br><span class="line">信息:  information message 2019-12-03 12:03:41.136714+08</span><br><span class="line">警告:  warning message 2019-12-03 12:03:41.136714+08</span><br><span class="line">注意:  notice message 2019-12-03 12:03:41.136714+08</span><br><span class="line">DO</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，并非所有消息都报告给客户端，只有INFO，WARNING和NOTICE级别的消息报告给客户端。这由client_min_messages 和log_min_messages 配置参数控制。</p>
</blockquote>
<h4 id="PL-pgSQL引发错误提示"><a href="#PL-pgSQL引发错误提示" class="headerlink" title="PL/pgSQL引发错误提示"></a>PL/pgSQL引发错误提示</h4><blockquote>
<p>要引发错误提示，请在RAISE语句后使用EXCEPTION级别。请注意，RAISE语句默认情况下使用EXCEPTION级别。</p>
</blockquote>
<blockquote>
<p>除了引发错误提示之外，还可以在RAISE语句中使用以下子句来添加更多详细信息：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USING option = expression</span><br></pre></td></tr></table></figure>
<ul>
<li>MESSAGE：设置错误消息文本</li>
</ul>
<ul>
<li>HINT：提供提示信息，以便更容易发现错误的根本原因。</li>
</ul>
<ul>
<li>DETAIL：提供有关错误的详细信息。</li>
</ul>
<ul>
<li>ERRCODE：标识错误代码，可以通过条件名称或直接由五个字符组成的SQLSTATE代码。 </li>
</ul>
<blockquote>
<p>引发重复的电子邮件错误消息：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DO $$</span></span><br><span class="line">DECLARE</span><br><span class="line">   email varchar(255) := <span class="string">'info@postgresql.org'</span>;</span><br><span class="line">BEGIN</span><br><span class="line">  -- check email <span class="keyword">for</span> duplicate</span><br><span class="line">  -- ...</span><br><span class="line">  -- report duplicate email</span><br><span class="line">  RAISE EXCEPTION <span class="string">'Duplicate email: %'</span>, email</span><br><span class="line">      USING HINT = <span class="string">'Check the email again'</span>;</span><br><span class="line">END $$;</span><br><span class="line">错误:  Duplicate email: info@postgresql.org</span><br><span class="line">HINT:  Check the email again</span><br><span class="line">CONTEXT:  在RAISE的第8行的PL/pgSQL函数inline_code_block</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下示例说明了如何引发SQLSTATE及其对应条件：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DO $$</span><br><span class="line">BEGIN</span><br><span class="line">   --...</span><br><span class="line">   RAISE SQLSTATE <span class="string">'2210B'</span>;</span><br><span class="line">END $$;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DO $$</span><br><span class="line">BEGIN</span><br><span class="line">   --...</span><br><span class="line">   RAISE invalid_regular_expression;</span><br><span class="line">END $$;</span><br></pre></td></tr></table></figure>
<h4 id="使用ASSERT语句进行调试检查"><a href="#使用ASSERT语句进行调试检查" class="headerlink" title="使用ASSERT语句进行调试检查"></a>使用ASSERT语句进行调试检查</h4><blockquote>
<p>ASSERT语句的语法</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASSERT condition [, message];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>条件是布尔表达式。如果条件评估为TRUE，则ASSERT语句不执行任何操作。如果条件评估为FALSE或NULL，则引发ASSERT_FAILURE。</p>
</blockquote>
<blockquote>
<p>如果不提供该消息，则PL/pgSQL默认使用“断言失败”消息。如果提供了该消息，则ASSERT语句将使用它来替换默认消息。</p>
</blockquote>
<h3 id="CREATE-FUNCTION语句"><a href="#CREATE-FUNCTION语句" class="headerlink" title="CREATE FUNCTION语句"></a>CREATE FUNCTION语句</h3><h4 id="CREATE-FUNCTION语句语法"><a href="#CREATE-FUNCTION语句语法" class="headerlink" title="CREATE FUNCTION语句语法"></a>CREATE FUNCTION语句语法</h4><blockquote>
<p>要在PostgreSQL中创建新的用户定义函数，请使用CREATE FUNCTION语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION function_name(p1 <span class="built_in">type</span>, p2 <span class="built_in">type</span>)</span><br><span class="line">RETURNS <span class="built_in">type</span> AS</span><br><span class="line">BEGIN</span><br><span class="line">-- logic</span><br><span class="line">END;</span><br><span class="line">LANGUAGE language_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，在CREATE FUNCTION关键字之后指定函数的名称。</li>
</ul>
<ul>
<li>然后，在函数名称后的括号内放入逗号分隔的参数列表。</li>
</ul>
<ul>
<li>接下来，在RETURNS关键字之后指定函数的返回类型。</li>
</ul>
<ul>
<li>之后，将代码放入BEGIN和END块中。该函数始终以分号（;）结尾，后跟END关键字。</li>
</ul>
<ul>
<li>最后，在使用PL/pgSQL的情况下，说明函数的过程语言，例如plpgsql。</li>
</ul>
<h4 id="CREATE-FUNCTION语句示例"><a href="#CREATE-FUNCTION语句示例" class="headerlink" title="CREATE FUNCTION语句示例"></a>CREATE FUNCTION语句示例</h4><blockquote>
<p>开发一个名为inc的非常简单的函数，该函数将整数增加1并返回结果。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE FUNCTION inc(val integer) RETURNS integer AS $$</span></span><br><span class="line">BEGIN</span><br><span class="line">RETURN val + 1;</span><br><span class="line">END; $$</span><br><span class="line">LANGUAGE PLPGSQL;</span><br><span class="line">CREATE FUNCTION</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提供给CREATE FUNCTION的整个函数定义必须是一个单引号字符串。这意味着如果函数具有任何单引号（’），则必须对其进行转义。</p>
</blockquote>
<blockquote>
<p>PostgreSQL提供了一种称为“$”的功能，该功能使您可以选择一个合适的字符串,从而您不必对其进行转义。</p>
</blockquote>
<blockquote>
<p>如果函数有效，则PostgreSQL将创建函数并返回CREATE FUNCTION语句，如上所示。</p>
</blockquote>
<blockquote>
<p>调用函数:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT inc(20);</span></span><br><span class="line"> inc</span><br><span class="line">-----</span><br><span class="line">  21</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT inc(inc(20));</span></span><br><span class="line"> inc</span><br><span class="line">-----</span><br><span class="line">  22</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h3 id="PL-pgSQL函数参数"><a href="#PL-pgSQL函数参数" class="headerlink" title="PL/pgSQL函数参数"></a>PL/pgSQL函数参数</h3><h4 id="PL-pgSQL-IN参数"><a href="#PL-pgSQL-IN参数" class="headerlink" title="PL/pgSQL IN参数"></a>PL/pgSQL IN参数</h4><blockquote>
<p>从创建一个名为get_sum()的新函数:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE FUNCTION get_sum(</span></span><br><span class="line">   a NUMERIC,</span><br><span class="line">   b NUMERIC)</span><br><span class="line">RETURNS NUMERIC AS $$</span><br><span class="line">BEGIN</span><br><span class="line">   RETURN a + b;</span><br><span class="line">END; $$</span><br><span class="line"> </span><br><span class="line">LANGUAGE plpgsql;</span><br><span class="line">CREATE FUNCTION</span><br></pre></td></tr></table></figure>
<blockquote>
<p>get_sum()函数接受两个参数：a和b并返回一个数字。这两个参数的数据类型为NUMERIC。默认情况下，PostgreSQL中任何参数的参数类型均为IN参数。可以将IN参数传递给函数，但不能将它们作为结果的一部分取回。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT get_sum(10,20);</span></span><br><span class="line"> get_sum</span><br><span class="line">---------</span><br><span class="line">      30</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="PL-pgSQL-OUT参数"><a href="#PL-pgSQL-OUT参数" class="headerlink" title="PL/pgSQL OUT参数"></a>PL/pgSQL OUT参数</h4><blockquote>
<p>OUT参数被定义为函数参数列表的一部分，并作为结果的一部分返回。</p>
</blockquote>
<blockquote>
<p>要定义OUT参数，请使用OUT关键字，如以下示例所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE FUNCTION abc(</span></span><br><span class="line">   a NUMERIC,</span><br><span class="line">   b NUMERIC,</span><br><span class="line">   c NUMERIC,</span><br><span class="line">        OUT high NUMERIC,</span><br><span class="line">   OUT low NUMERIC)</span><br><span class="line">AS $$</span><br><span class="line">BEGIN</span><br><span class="line">   high := GREATEST(a,b,c);</span><br><span class="line">   low := LEAST(a,b,c);</span><br><span class="line">END; $$</span><br><span class="line"> </span><br><span class="line">LANGUAGE plpgsql;</span><br><span class="line">CREATE FUNCTION</span><br></pre></td></tr></table></figure>
<blockquote>
<p>abc函数接受5个参数：</p>
<ul>
<li>三个IN参数：a，b，c。</li>
</ul>
<ul>
<li>两个OUT参数：high（高）和low（低）。</li>
</ul>
</blockquote>
<blockquote>
<p>在函数内部，使用GREATEST和LEAST内置函数可以获取最大多和最小的三个IN参数。因为我们使用OUT参数，所以我们不需要RETURN语句。OUT参数在需要返回多个值而不定义自定义类型的函数中很有用。</p>
</blockquote>
<blockquote>
<p>以下语句调用abc函数：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT abc(10,20,30);</span></span><br><span class="line">   abc</span><br><span class="line">---------</span><br><span class="line"> (30,10)</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出分隔为列，请使用以下语法:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT * FROM abc(10,20,30);</span></span><br><span class="line"> high | low</span><br><span class="line">------+-----</span><br><span class="line">   30 |  10</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="PL-pgSQL-INOUT参数"><a href="#PL-pgSQL-INOUT参数" class="headerlink" title="PL/pgSQL INOUT参数"></a>PL/pgSQL INOUT参数</h4><blockquote>
<p>INOUT参数是IN和OUT参数的组合。这意味着调用者可以将值传递给函数。然后，函数更改参数，并将值作为结果的一部分传回。</p>
</blockquote>
<blockquote>
<p>下面的示例展示平方函数，该函数接受一个数字并返回该数字的平方:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE FUNCTION square(</span></span><br><span class="line">   INOUT a NUMERIC)</span><br><span class="line">AS $$</span><br><span class="line">BEGIN</span><br><span class="line">   a := a * a;</span><br><span class="line">END; $$</span><br><span class="line">LANGUAGE plpgsql;</span><br><span class="line">CREATE FUNCTION</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT square(4);</span></span><br><span class="line"> square</span><br><span class="line">--------</span><br><span class="line">     16</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="PL-pgSQL-VARIADIC参数"><a href="#PL-pgSQL-VARIADIC参数" class="headerlink" title="PL/pgSQL VARIADIC参数"></a>PL/pgSQL VARIADIC参数</h4><blockquote>
<p>PostgreSQL函数可以接受可变数量的参数，但条件是所有参数都具有相同的数据类型。参数作为数组传递给函数。请参见以下示例：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE FUNCTION sum_avg(</span></span><br><span class="line">   VARIADIC list NUMERIC[],</span><br><span class="line">   OUT total NUMERIC,</span><br><span class="line">        OUT average NUMERIC)</span><br><span class="line">AS $$</span><br><span class="line">BEGIN</span><br><span class="line">   SELECT INTO total SUM(list[i])</span><br><span class="line">   FROM generate_subscripts(list, 1) g(i);</span><br><span class="line"> </span><br><span class="line">   SELECT INTO average AVG(list[i])</span><br><span class="line">   FROM generate_subscripts(list, 1) g(i);</span><br><span class="line">   </span><br><span class="line">END; $$</span><br><span class="line">LANGUAGE plpgsql;</span><br><span class="line">CREATE FUNCTION</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT * FROM sum_avg(10,20,30);</span></span><br><span class="line"> total |       average</span><br><span class="line">-------+---------------------</span><br><span class="line">    60 | 20.0000000000000000</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h3 id="PL-pgSQL函数重载"><a href="#PL-pgSQL函数重载" class="headerlink" title="PL/pgSQL函数重载"></a>PL/pgSQL函数重载</h3><blockquote>
<p>PostgreSQL允许多个函数具有相同的名称，只要参数不同即可。如果多个函数具有相同的名称，则可以说这些函数已重载。调用函数时，PostgreSQL根据输入参数确定正在调用的确切函数。</p>
</blockquote>
<blockquote>
<p>get_rental_function函数接受p_customer_id作为参数。它返回特定客户租借DVD的持续时间总和（以天为单位）。例如，我们可以获取客户ID为232的客户的租期，我们调用get_rental_duration函数，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE FUNCTION get_rental_duration(p_customer_id INTEGER)</span></span><br><span class="line">   RETURNS INTEGER AS $$</span><br><span class="line">   </span><br><span class="line">DECLARE</span><br><span class="line">   rental_duration INTEGER;</span><br><span class="line">BEGIN</span><br><span class="line">   -- get the rate based on film_id</span><br><span class="line">   SELECT INTO rental_duration SUM( EXTRACT( DAY FROM return_date - rental_date))</span><br><span class="line">    FROM rental</span><br><span class="line">   WHERE customer_id=p_customer_id;</span><br><span class="line"> </span><br><span class="line">   RETURN rental_duration;</span><br><span class="line">END; $$</span><br><span class="line">LANGUAGE plpgsql;</span><br><span class="line">CREATE FUNCTION</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT get_rental_duration(232);</span></span><br><span class="line"> get_rental_duration</span><br><span class="line">---------------------</span><br><span class="line">                  90</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>假设我们想知道从特定日期到现在的客户的租期。我们可以在get_retal_duration（）函数中再添加一个参数p_from_date，或者可以开发一个具有相同名称但具有两个参数的新函数，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE FUNCTION get_rental_duration(p_customer_id INTEGER, p_from_date DATE)</span></span><br><span class="line">   RETURNS INTEGER AS $$</span><br><span class="line">DECLARE</span><br><span class="line">   rental_duration <span class="built_in">integer</span>;</span><br><span class="line">BEGIN</span><br><span class="line">   -- get the rental duration based on customer_id and rental date</span><br><span class="line">   SELECT INTO rental_duration</span><br><span class="line">               SUM( EXTRACT( DAY FROM return_date + <span class="string">'12:00:00'</span> - rental_date))</span><br><span class="line">   FROM rental</span><br><span class="line">   WHERE customer_id= p_customer_id AND</span><br><span class="line">        rental_date &gt;= p_from_date;</span><br><span class="line">   </span><br><span class="line">   RETURN rental_duration;</span><br><span class="line">END; $$</span><br><span class="line">LANGUAGE plpgsql;</span><br><span class="line">CREATE FUNCTION</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该函数与第一个函数具有相同的名称，只是它具有两个参数。我们说get_rental_duration（integer）函数被get_rental_duration（integer，date）函数重载。以下语句获取自2005年7月1日起客户ID为232的客户的租期：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT get_rental_duration(232,'2005-07-01');</span></span><br><span class="line"> get_rental_duration</span><br><span class="line">---------------------</span><br><span class="line">                  85</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，如果我们忽略第二个参数，PostgreSQL将调用第一个函数。</p>
</blockquote>
<h4 id="PL-pgSQL函数重载和默认值"><a href="#PL-pgSQL函数重载和默认值" class="headerlink" title="PL/pgSQL函数重载和默认值"></a>PL/pgSQL函数重载和默认值</h4><blockquote>
<p>在get_rental_duration（integer，date）函数中，如果我们想为第二个参数添加默认值，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE FUNCTION get_rental_duration(</span></span><br><span class="line">      p_customer_id INTEGER,</span><br><span class="line">      p_from_date DATE DEFAULT <span class="string">'2005-01-01'</span></span><br><span class="line">   )</span><br><span class="line">   RETURNS INTEGER AS $$</span><br><span class="line">DECLARE</span><br><span class="line">   rental_duration <span class="built_in">integer</span>;</span><br><span class="line">BEGIN</span><br><span class="line">   -- get the rental duration based on customer_id and rental date</span><br><span class="line">   SELECT INTO rental_duration</span><br><span class="line">               SUM( EXTRACT( DAY FROM return_date + <span class="string">'12:00:00'</span> - rental_date))</span><br><span class="line">   FROM rental</span><br><span class="line">   WHERE customer_id= p_customer_id AND</span><br><span class="line">        rental_date &gt;= p_from_date;</span><br><span class="line">   </span><br><span class="line">   RETURN rental_duration;</span><br><span class="line">END; $$</span><br><span class="line">LANGUAGE plpgsql;</span><br><span class="line">CREATE FUNCTION</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这意味着如果我们忽略传递p_from_date参数，PostgreSQL将使用2015年1月1日作为默认值。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT get_rental_duration(232);</span></span><br><span class="line">错误:  函数 get_rental_duration(<span class="built_in">integer</span>) 不是唯一的</span><br><span class="line">LINE 1: SELECT get_rental_duration(232)</span><br><span class="line">               ^</span><br><span class="line">HINT:  无法选择最佳候选函数. 你也许需要增加明确的类型转换.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PostgreSQL应该使用一个参数调用第一个函数还是使用两个参数调用第二个函数？它无法选择。因此，当重载现有功能时，应始终使它们的功能接口不同。现在，可以通过显式传递第二个参数来仅使用第二个函数。无法使用第一个函数，因为它使PostgreSQL混淆了调用哪个函数。</p>
</blockquote>
<blockquote>
<p>我们需要删除具有默认值的get_rental_duration()函数，并再次使用两个参数重新创建get_rental_duration函数，而无需为第二个参数指定默认值。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DROP FUNCTION get_rental_duration(INTEGER,DATE);</span></span><br><span class="line">DROP FUNCTION</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，删除函数时，必须同时指定参数和函数名称。实际上，在PostgreSQL中，函数的完整名称包括名称和参数。</p>
</blockquote>
<blockquote>
<p>最后一个重要说明是，应避免使用过多的重载，这会使开发人员难以通过查看代码来知道将调用哪个函数。</p>
</blockquote>
<blockquote>
<p>使用ILIKE运算符返回标题匹配特定图案的所有电影</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE FUNCTION get_film (p_pattern VARCHAR)</span></span><br><span class="line">   RETURNS TABLE (</span><br><span class="line">      film_title VARCHAR,</span><br><span class="line">      film_release_year INT</span><br><span class="line">)</span><br><span class="line">AS $$</span><br><span class="line">BEGIN</span><br><span class="line">   RETURN QUERY SELECT</span><br><span class="line">      title,</span><br><span class="line">      cast( release_year as <span class="built_in">integer</span>)</span><br><span class="line">   FROM</span><br><span class="line">      film</span><br><span class="line">   WHERE</span><br><span class="line">      title ILIKE p_pattern ;</span><br><span class="line">END; $$</span><br><span class="line"> </span><br><span class="line">LANGUAGE <span class="string">'plpgsql'</span>;</span><br><span class="line">CREATE FUNCTION</span><br></pre></td></tr></table></figure>
<blockquote>
<p>get_film（varchar）函数接受一个参数p_pattern，这是您要与影片标题匹配的模式。要从函数返回表，请使用RETURNS TABLE语法并指定表的列。每列均以逗号(,)分隔。</p>
</blockquote>
<blockquote>
<p>在该函数中，我们返回一个查询，该查询是SELECT语句的结果。请注意，SELECT语句中的列必须与我们要返回的表的列匹配。由于电影表的的数据类型release_year不是整数，因此我们必须使用强制类型转换将其转换为整数。</p>
</blockquote>
<blockquote>
<p>调用get_film（varchar）函数来获取标题以Al开头的所有电影:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   get_film (<span class="string">'Al%'</span>);</span><br><span class="line">    film_title    | film_release_year</span><br><span class="line">------------------+-------------------</span><br><span class="line"> Alabama Devil    |              2006</span><br><span class="line"> Aladdin Calendar |              2006</span><br><span class="line"> Alamo Videotape  |              2006</span><br><span class="line"> Alaska Phantom   |              2006</span><br><span class="line"> Ali Forever      |              2006</span><br><span class="line"> Alice Fantasia   |              2006</span><br><span class="line"> Alien Center     |              2006</span><br><span class="line"> Alley Evolution  |              2006</span><br><span class="line"> Alone Trip       |              2006</span><br><span class="line"> Alter Victory    |              2006</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果使用以下语句调用该函数，PostgreSQL返回一个包含一列的表，其中包含电影数组:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   get_film (<span class="string">'Al%'</span>);</span><br><span class="line">         get_film</span><br><span class="line">---------------------------</span><br><span class="line"> (<span class="string">"Alabama Devil"</span>,2006)</span><br><span class="line"> (<span class="string">"Aladdin Calendar"</span>,2006)</span><br><span class="line"> (<span class="string">"Alamo Videotape"</span>,2006)</span><br><span class="line"> (<span class="string">"Alaska Phantom"</span>,2006)</span><br><span class="line"> (<span class="string">"Ali Forever"</span>,2006)</span><br><span class="line"> (<span class="string">"Alice Fantasia"</span>,2006)</span><br><span class="line"> (<span class="string">"Alien Center"</span>,2006)</span><br><span class="line"> (<span class="string">"Alley Evolution"</span>,2006)</span><br><span class="line"> (<span class="string">"Alone Trip"</span>,2006)</span><br><span class="line"> (<span class="string">"Alter Victory"</span>,2006)</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上，通常在将每一行添加到函数的结果集中之前对其进行处理。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE FUNCTION get_film (p_pattern VARCHAR,p_year INT)</span></span><br><span class="line">   RETURNS TABLE (</span><br><span class="line">      film_title VARCHAR,</span><br><span class="line">      film_release_year INT</span><br><span class="line">) AS $$</span><br><span class="line">DECLARE</span><br><span class="line">    var_r record;</span><br><span class="line">BEGIN</span><br><span class="line">   FOR var_r IN(SELECT</span><br><span class="line">                  title,</span><br><span class="line">                  release_year</span><br><span class="line">                FROM film</span><br><span class="line">            WHERE title ILIKE p_pattern AND</span><br><span class="line">                         release_year = p_year)  </span><br><span class="line">   LOOP</span><br><span class="line">        film_title := upper(var_r.title) ;</span><br><span class="line">      film_release_year := var_r.release_year;</span><br><span class="line">        RETURN NEXT;</span><br><span class="line">   END LOOP;</span><br><span class="line">END; $$</span><br><span class="line">LANGUAGE <span class="string">'plpgsql'</span>;</span><br><span class="line">CREATE FUNCTION</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建了一个具有类似名称get_film（varchar，int）的函数，但是接受两个参数：</p>
<ul>
<li>第一个参数是p_pattern，如果标题与此模式匹配，我们将使用p_pattern搜索电影。我们使用ILIKE运算符执行搜索。</li>
</ul>
<ul>
<li>第二个参数是电影的发行年份。</li>
</ul>
<ul>
<li>因为要在返回每个行之前对其进行处理，所以我们使用FOR LOOP语句对其进行处理。在每次迭代中，我们使用UPPER函数使影片的标题大写。 </li>
</ul>
</blockquote>
<blockquote>
<p>RETURN NEXT语句在该函数的结果集中添加一行。继续执行，并在循环的每次迭代中建立结果集。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   get_film (<span class="string">'wr%'</span>, 2006);</span><br><span class="line">   film_title   | film_release_year</span><br><span class="line">----------------+-------------------</span><br><span class="line"> WRATH MILE     |              2006</span><br><span class="line"> WRONG BEHAVIOR |              2006</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h3 id="PL-pgSQL-IF语句"><a href="#PL-pgSQL-IF语句" class="headerlink" title="PL/pgSQL IF语句"></a>PL/pgSQL IF语句</h3><blockquote>
<p>IF语句用于有条件地执行命令。PL/pgSQL为您提供了三种形式的IF语句。</p>
</blockquote>
<h4 id="IF语句的最简单形式"><a href="#IF语句的最简单形式" class="headerlink" title="IF语句的最简单形式"></a>IF语句的最简单形式</h4><blockquote>
<p>如果条件为真，则IF语句执行语句。如果条件的计算结果为false，则将控制传递到END IF部分之后的下一个语句。下面说明了IF语句的最简单形式：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IF condition THEN</span><br><span class="line">   statement;</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>条件是一个布尔表达式，其结果为true或false。</p>
</blockquote>
<blockquote>
<p>该语句是在条件为真时将执行的语句。它可以是任何有效的语句，甚至可以是另一个IF语句。IF代码语句放在另一个IF语句内，称为嵌套IF语句。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DO $$</span></span><br><span class="line">DECLARE</span><br><span class="line">  a <span class="built_in">integer</span> := 10;</span><br><span class="line">  b <span class="built_in">integer</span> := 20;</span><br><span class="line">BEGIN</span><br><span class="line">  IF a &gt; b THEN</span><br><span class="line">   RAISE NOTICE <span class="string">'a is greater than b'</span>;</span><br><span class="line">  END IF;</span><br><span class="line"> </span><br><span class="line">  IF a &lt; b THEN</span><br><span class="line">   RAISE NOTICE <span class="string">'a is less than b'</span>;</span><br><span class="line">  END IF;</span><br><span class="line"> </span><br><span class="line">  IF a = b THEN</span><br><span class="line">   RAISE NOTICE <span class="string">'a is equal to b'</span>;</span><br><span class="line">  END IF;</span><br><span class="line">END $$;</span><br><span class="line">注意:  a is less than b</span><br><span class="line">DO</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此示例中，我们声明了两个变量a和b。在块的主体中，我们使用IF语句的布尔表达式中的比较运算符&gt;，&lt;和=比较a和b的值，并打印出相应的消息。</p>
</blockquote>
<h4 id="IF-THEN-ELSE语句"><a href="#IF-THEN-ELSE语句" class="headerlink" title="IF THEN ELSE语句"></a>IF THEN ELSE语句</h4><h5 id="IF-THEN-ELSE语句的语法"><a href="#IF-THEN-ELSE语句的语法" class="headerlink" title="IF THEN ELSE语句的语法"></a>IF THEN ELSE语句的语法</h5><blockquote>
<p>IF THEN ELSE语句在条件为true时执行命令，在条件为false时执行替代命令。下面说明了IF THEN ELSE语句的语法：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IF condition THEN</span><br><span class="line">  statements;</span><br><span class="line">ELSE</span><br><span class="line">  alternative-statements;</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>
<h5 id="IF-THEN-ELSE语句示例"><a href="#IF-THEN-ELSE语句示例" class="headerlink" title="IF THEN ELSE语句示例"></a>IF THEN ELSE语句示例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DO $$</span></span><br><span class="line">DECLARE</span><br><span class="line">  a <span class="built_in">integer</span> := 10;</span><br><span class="line">  b <span class="built_in">integer</span> := 20;</span><br><span class="line">BEGIN</span><br><span class="line">   IF a &gt; b THEN</span><br><span class="line">      RAISE NOTICE <span class="string">'a is greater than b'</span>;</span><br><span class="line">   ELSE</span><br><span class="line">      RAISE NOTICE <span class="string">'a is not greater than b'</span>;</span><br><span class="line">   END IF;</span><br><span class="line">END $$;</span><br><span class="line">注意:  a is not greater than b</span><br><span class="line">DO</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于表达式a &gt; b为假，因此将执行ELSE子句中的语句。</p>
</blockquote>
<h4 id="IF-THEN-ELSIF-THEN-ELSE语句"><a href="#IF-THEN-ELSIF-THEN-ELSE语句" class="headerlink" title="IF THEN ELSIF THEN ELSE语句"></a>IF THEN ELSIF THEN ELSE语句</h4><h5 id="IF-THEN-ELSIF-THEN-ELSE语句语法"><a href="#IF-THEN-ELSIF-THEN-ELSE语句语法" class="headerlink" title="IF THEN ELSIF THEN ELSE语句语法"></a>IF THEN ELSIF THEN ELSE语句语法</h5><blockquote>
<p>IF和IF THEN ELSE语句仅允许您评估一个条件。但是，使用这种形式的IF语句，您可能需要评估多个条件。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IF condition-1 THEN</span><br><span class="line">  <span class="keyword">if</span>-statement;</span><br><span class="line">ELSIF condition-2 THEN</span><br><span class="line">  elsif-statement-2</span><br><span class="line">...</span><br><span class="line">ELSIF condition-n THEN</span><br><span class="line">  elsif-statement-n;</span><br><span class="line">ELSE</span><br><span class="line">  <span class="keyword">else</span>-statement;</span><br><span class="line">END IF:</span><br></pre></td></tr></table></figure>
<blockquote>
<p>条件为true，则执行该分支中的相应语句。例如，如果condition-1，condition-2等为true，则将执行相应的语句：if-statement，elseif-statement-2等。如果满足一个条件，PostgreSQL将停止评估下面的条件。</p>
</blockquote>
<blockquote>
<p>如果所有条件都为false，则执行最后一个ELSE分支中的语句。</p>
</blockquote>
<h5 id="IF-THEN-ELSIF-THEN-ELSE示例"><a href="#IF-THEN-ELSIF-THEN-ELSE示例" class="headerlink" title="IF THEN ELSIF THEN ELSE示例"></a>IF THEN ELSIF THEN ELSE示例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># DO $$</span></span><br><span class="line">DECLARE</span><br><span class="line">   a <span class="built_in">integer</span> := 10;</span><br><span class="line">   b <span class="built_in">integer</span> := 10;</span><br><span class="line">BEGIN</span><br><span class="line">  IF a &gt; b THEN</span><br><span class="line">     RAISE NOTICE <span class="string">'a is greater than b'</span>;</span><br><span class="line">  ELSIF a &lt; b THEN</span><br><span class="line">     RAISE NOTICE <span class="string">'a is less than b'</span>;</span><br><span class="line">  ELSE</span><br><span class="line">     RAISE NOTICE <span class="string">'a is equal to b'</span>;</span><br><span class="line">  END IF;</span><br><span class="line">END $$;</span><br><span class="line">注意:  a is equal to b</span><br><span class="line">DO</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此示例中，因为a等于b，所以将执行ELSE分支中的语句。</p>
</blockquote>
<h3 id="PL-pgSQL-CASE语句"><a href="#PL-pgSQL-CASE语句" class="headerlink" title="PL/pgSQL CASE语句"></a>PL/pgSQL CASE语句</h3><blockquote>
<p>除了IF语句外，PostgreSQL还提供了CASE允许有条件地执行代码块的语句。该CASE语句有两种形式：简单CASE语句和搜索的CASE语句。</p>
</blockquote>
<h4 id="简单的CASE语句"><a href="#简单的CASE语句" class="headerlink" title="简单的CASE语句"></a>简单的CASE语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CASE search-expression</span><br><span class="line">   WHEN expression_1 [, expression_2, ...] THEN</span><br><span class="line">      when-statements</span><br><span class="line">  [ ... ]</span><br><span class="line">  [ELSE</span><br><span class="line">      <span class="keyword">else</span>-statements ]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>search-expression是一个表达式，它将使用相等操作数（=）与每个WHEN分支中的表达式求值。如果找到匹配项，则执行相应的WHEN分支中的when语句。下面的后续表达式将不被评估。</p>
</blockquote>
<blockquote>
<p>如果找不到匹配项，则执行ELSE分支中的else语句。ELSE分支是可选的。如果找不到匹配项，并且没有ELSE分支，则PostgreSQL将引发CASE_NOT_FOUND异常。</p>
</blockquote>
<h4 id="简单CASE语句的示例"><a href="#简单CASE语句的示例" class="headerlink" title="简单CASE语句的示例"></a>简单CASE语句的示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE FUNCTION get_price_segment(p_film_id integer)</span></span><br><span class="line">   RETURNS VARCHAR(50) AS $$</span><br><span class="line">DECLARE</span><br><span class="line">   rate   NUMERIC;</span><br><span class="line">   price_segment VARCHAR(50);</span><br><span class="line">BEGIN</span><br><span class="line">     -- get the rate based on film_id</span><br><span class="line">    SELECT INTO rate rental_rate</span><br><span class="line">    FROM film</span><br><span class="line">    WHERE film_id = p_film_id;</span><br><span class="line">      </span><br><span class="line">     CASE rate</span><br><span class="line">   WHEN 0.99 THEN</span><br><span class="line">            price_segment = <span class="string">'Mass'</span>;</span><br><span class="line">   WHEN 2.99 THEN</span><br><span class="line">            price_segment = <span class="string">'Mainstream'</span>;</span><br><span class="line">   WHEN 4.99 THEN</span><br><span class="line">            price_segment = <span class="string">'High End'</span>;</span><br><span class="line">   ELSE</span><br><span class="line">       price_segment = <span class="string">'Unspecified'</span>;</span><br><span class="line">   END CASE;</span><br><span class="line">   </span><br><span class="line">   RETURN price_segment;</span><br><span class="line">END; $$</span><br><span class="line">LANGUAGE plpgsql;</span><br><span class="line">CREATE FUNCTION</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT get_price_segment(123) AS "Price Segment";</span></span><br><span class="line"> Price Segment</span><br><span class="line">---------------</span><br><span class="line"> High End</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此示例中，我们创建了一个名为get_price_segment的新函数，该函数接受p_film_id作为参数。根据电影的租金，它返回价格段：大众，主流，高端。如果价格不是0.99、2.99或4.99，则该函数返回未指定的价格。</p>
</blockquote>
<h4 id="搜索的CASE语句"><a href="#搜索的CASE语句" class="headerlink" title="搜索的CASE语句"></a>搜索的CASE语句</h4><blockquote>
<p>以下语法说明了搜索到的CASE语句</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CASE</span><br><span class="line">    WHEN boolean-expression-1 THEN</span><br><span class="line">      statements</span><br><span class="line">  [ WHEN boolean-expression-2 THEN</span><br><span class="line">      statements</span><br><span class="line">    ... ]</span><br><span class="line">  [ ELSE</span><br><span class="line">      statements ]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>搜索的CASE语句基于每个WHEN子句中布尔表达式的结果执行语句。PostgreSQL从上到下依次评估布尔表达式，直到一个表达式为真。然后评估停止并执行相应的语句。控件在END CASE之后传递到下一个语句。</p>
</blockquote>
<blockquote>
<p>如果找不到正确的结果，则执行ELSE子句中的语句。ELSE子句是可选的。如果省略ELSE子句，但没有真实结果，则PostgreSQL将引发CASE_NOT_FOUND异常。</p>
</blockquote>
<h4 id="搜索的CASE语句示例"><a href="#搜索的CASE语句示例" class="headerlink" title="搜索的CASE语句示例"></a>搜索的CASE语句示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE FUNCTION get_customer_service (p_customer_id INTEGER)</span></span><br><span class="line">   RETURNS VARCHAR (25) AS $$</span><br><span class="line">DECLARE</span><br><span class="line">    total_payment NUMERIC ;</span><br><span class="line">    service_level VARCHAR (25) ;</span><br><span class="line">BEGIN</span><br><span class="line">   -- get the rate based on film_id</span><br><span class="line">     SELECT</span><br><span class="line">   INTO total_payment SUM (amount)</span><br><span class="line">     FROM</span><br><span class="line">   payment</span><br><span class="line">     WHERE</span><br><span class="line">   customer_id = p_customer_id ;</span><br><span class="line">  </span><br><span class="line">   CASE</span><br><span class="line">      WHEN total_payment &gt; 200 THEN</span><br><span class="line">         service_level = <span class="string">'Platinum'</span> ;</span><br><span class="line">      WHEN total_payment &gt; 100 THEN</span><br><span class="line">    service_level = <span class="string">'Gold'</span> ;</span><br><span class="line">      ELSE</span><br><span class="line">         service_level = <span class="string">'Silver'</span> ;</span><br><span class="line">   END CASE ;</span><br><span class="line"> </span><br><span class="line">   RETURN service_level ;</span><br><span class="line">END ; $$</span><br><span class="line">LANGUAGE plpgsql;</span><br><span class="line">CREATE FUNCTION</span><br></pre></td></tr></table></figure>
<blockquote>
<p>get_customer_service函数接受p_customer_id作为参数。它首先从付款表中获得客户支付的总付款。然后，基于总付款，该函数使用搜索到的CASE语句返回服务级别白金，黄金和白银。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   148 AS customer,</span><br><span class="line">   get_customer_service (148)</span><br><span class="line">UNION</span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">   178 AS customer,</span><br><span class="line">   get_customer_service (178)</span><br><span class="line">UNION</span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">   81 AS customer,</span><br><span class="line">   get_customer_service (81);</span><br><span class="line"> customer | get_customer_service</span><br><span class="line">----------+----------------------</span><br><span class="line">      178 | Gold</span><br><span class="line">       81 | Silver</span><br><span class="line">      148 | Platinum</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，搜索到的case语句类似于IF ELSIF ELSE语句。</p>
</blockquote>
<h3 id="PL-pgSQL循环语句"><a href="#PL-pgSQL循环语句" class="headerlink" title="PL/pgSQL循环语句"></a>PL/pgSQL循环语句</h3><blockquote>
<p>PostgreSQL提供了三个循环语句：LOOP，WHILE循环和FOR循环。</p>
</blockquote>
<h4 id="LOOP语句"><a href="#LOOP语句" class="headerlink" title="LOOP语句"></a>LOOP语句</h4><h4 id="LOOP语句的语法"><a href="#LOOP语句的语法" class="headerlink" title="LOOP语句的语法"></a>LOOP语句的语法</h4><blockquote>
<p>有时，您需要重复执行一个语句块，直到条件变为真为止。为此，可以使用PL/pgSQL LOOP语句。下面说明了LOOP语句的语法：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;label&gt;&gt;</span><br><span class="line">LOOP</span><br><span class="line">   Statements;</span><br><span class="line">   EXIT [&lt;&lt;label&gt;&gt;] WHEN condition;</span><br><span class="line">END LOOP;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>LOOP语句也称为无条件循环语句，因为它执行该语句直到EXIT语句中的条件计算为true。请注意，在EXIT语句中的WHEN关键字之后指定的条件是布尔表达式，其结果为true或false。</p>
</blockquote>
<blockquote>
<p>循环语句可以嵌套。一个LOOP语句放置在另一个LOOP语句中，这称为嵌套循环。在这种情况下，需要为循环标签指定要在EXIT语句中终止的循环。</p>
</blockquote>
<h4 id="PL-pgSQL-LOOP示例"><a href="#PL-pgSQL-LOOP示例" class="headerlink" title="PL/pgSQL LOOP示例"></a>PL/pgSQL LOOP示例</h4><blockquote>
<p>使用LOOP语句开发返回第n个斐波纳契序列号的函数。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE FUNCTION fibonacci (n INTEGER)</span></span><br><span class="line">   RETURNS INTEGER AS $$</span><br><span class="line">DECLARE</span><br><span class="line">   counter INTEGER := 0 ;</span><br><span class="line">   i INTEGER := 0 ;</span><br><span class="line">   j INTEGER := 1 ;</span><br><span class="line">BEGIN</span><br><span class="line"> </span><br><span class="line">   IF (n &lt; 1) THEN</span><br><span class="line">      RETURN 0 ;</span><br><span class="line">   END IF;</span><br><span class="line">   </span><br><span class="line">   LOOP</span><br><span class="line">      EXIT WHEN counter = n ;</span><br><span class="line">      counter := counter + 1 ;</span><br><span class="line">      SELECT j, i + j INTO i,   j ;</span><br><span class="line">   END LOOP ;</span><br><span class="line">   </span><br><span class="line">   RETURN i ;</span><br><span class="line">END ;</span><br><span class="line">$$ LANGUAGE plpgsql;</span><br><span class="line">CREATE FUNCTION</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Fibonacci函数接受一个整数并返回第n个斐波那契数。根据定义，斐波那契数是以0和1开头的整数序列，每个后继数字是前两个数的和，例如1、1、2（1 + 1），3（2 + 1）， 5（3 +2），8（5 + 3），……</p>
</blockquote>
<blockquote>
<p>在声明部分，将计数器变量初始化为零(0)。在循环内部，当计数器等于n时，循环退出。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT j, i + j INTO i,   j ;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在不使用临时变量的情况下，同时交换i和j。</p>
</blockquote>
<h3 id="WHILE循环"><a href="#WHILE循环" class="headerlink" title="WHILE循环"></a>WHILE循环</h3><blockquote>
<p>WHILE循环语句执行一个语句块，直到条件评估为false。在WHILE循环语句中，PostgreSQL在执行语句块之前先评估条件。如果条件为true，则执行语句块，直到评估为false。</p>
</blockquote>
<h4 id="WHILE循环语法"><a href="#WHILE循环语法" class="headerlink" title="WHILE循环语法"></a>WHILE循环语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ &lt;&lt;label&gt;&gt; ]</span><br><span class="line">WHILE condition LOOP</span><br><span class="line">   statements;</span><br><span class="line">END LOOP;</span><br></pre></td></tr></table></figure>
<h4 id="WHILE循环示例"><a href="#WHILE循环示例" class="headerlink" title="WHILE循环示例"></a>WHILE循环示例</h4><blockquote>
<p>使用loop语句重写Fibonacci函数，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE FUNCTION fibonacci (n INTEGER)</span></span><br><span class="line">   RETURNS INTEGER AS $$</span><br><span class="line">DECLARE</span><br><span class="line">   counter INTEGER := 0 ;</span><br><span class="line">   i INTEGER := 0 ;</span><br><span class="line">   j INTEGER := 1 ;</span><br><span class="line">BEGIN</span><br><span class="line"> </span><br><span class="line">   IF (n &lt; 1) THEN</span><br><span class="line">      RETURN 0 ;</span><br><span class="line">   END IF;</span><br><span class="line">   </span><br><span class="line">   WHILE counter &lt;= n LOOP</span><br><span class="line">      counter := counter + 1 ;</span><br><span class="line">      SELECT j, i + j INTO i,   j ;</span><br><span class="line">   END LOOP ;</span><br><span class="line">   </span><br><span class="line">   RETURN i ;</span><br><span class="line">END ;</span><br><span class="line">$$ LANGUAGE plpgsql;</span><br><span class="line">CREATE FUNCTION</span><br></pre></td></tr></table></figure>
<h3 id="FOR循环语句"><a href="#FOR循环语句" class="headerlink" title="FOR循环语句"></a>FOR循环语句</h3><blockquote>
<p>FOR循环语句是PostgreSQL中最复杂的循环语句。</p>
</blockquote>
<h4 id="用于遍历整数范围"><a href="#用于遍历整数范围" class="headerlink" title="用于遍历整数范围"></a>用于遍历整数范围</h4><blockquote>
<p>FOR循环遍历整数范围的loop语句的语法:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ &lt;&lt;label&gt;&gt; ]</span><br><span class="line">FOR loop_counter IN [ REVERSE ] from.. to [ BY expression ] LOOP</span><br><span class="line">    statements</span><br><span class="line">END LOOP [ label ];</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，PostgreSQL创建一个仅在循环内部存在的整数变量loop_counter。默认情况下，循环计数器是在每次迭代之后添加的。如果使用REVERSE关键字，PostgreSQL将减去循环计数器。</li>
</ul>
<ul>
<li>其次，from和to是指定范围下限和上限的表达式。PostgreSQL在进入循环之前先对这些表达式求值。</li>
</ul>
<ul>
<li>第三，BY子句后面的表达式指定迭代步骤。如果省略此选项，则默认步骤为1。PostgreSQL在循环条目中也对该表达式求值一次。</li>
</ul>
<h4 id="FOR循环语句示例1"><a href="#FOR循环语句示例1" class="headerlink" title="FOR循环语句示例1"></a>FOR循环语句示例1</h4><blockquote>
<p>循环遍历1到5，并在每次迭代中打印出一条消息。计数器需要1、2、3、4、5。在每次循环迭代中，PostgreSQL将1加到计数器上。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DO $$</span><br><span class="line">BEGIN</span><br><span class="line">   FOR counter IN 1..5 LOOP</span><br><span class="line">   RAISE NOTICE <span class="string">'Counter: %'</span>, counter;</span><br><span class="line">   END LOOP;</span><br><span class="line">END; $$</span><br></pre></td></tr></table></figure>
<h4 id="FOR循环语句示例2"><a href="#FOR循环语句示例2" class="headerlink" title="FOR循环语句示例2"></a>FOR循环语句示例2</h4><blockquote>
<p>从5循环到1，并在每次迭代中打印一条消息。计数器取5、4、3、2、1。在每次迭代中，PostgreSQL从计数器中减去1。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DO $$</span><br><span class="line">BEGIN</span><br><span class="line">   FOR counter IN REVERSE 5..1 LOOP</span><br><span class="line">      RAISE NOTICE <span class="string">'Counter: %'</span>, counter;</span><br><span class="line">   END LOOP;</span><br><span class="line">END; $$</span><br></pre></td></tr></table></figure>
<h4 id="FOR循环语句示例3"><a href="#FOR循环语句示例3" class="headerlink" title="FOR循环语句示例3"></a>FOR循环语句示例3</h4><blockquote>
<p>在1到6之间循环，并在每次循环迭代中打印出计数器。计数器取1、3、5。在每次迭代中，PostgreSQL将2加到计数器上。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DO $$</span><br><span class="line">BEGIN</span><br><span class="line">  FOR counter IN 1..6 BY 2 LOOP</span><br><span class="line">    RAISE NOTICE <span class="string">'Counter: %'</span>, counter;</span><br><span class="line">  END LOOP;</span><br><span class="line">END; $$</span><br></pre></td></tr></table></figure>
<h3 id="FOR循环遍历查询结果"><a href="#FOR循环遍历查询结果" class="headerlink" title="FOR循环遍历查询结果"></a>FOR循环遍历查询结果</h3><h4 id="遍历查询结果的语法"><a href="#遍历查询结果的语法" class="headerlink" title="遍历查询结果的语法"></a>遍历查询结果的语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ &lt;&lt;label&gt;&gt; ]</span><br><span class="line">FOR target IN query LOOP</span><br><span class="line">    statements</span><br><span class="line">END LOOP [ label ];</span><br></pre></td></tr></table></figure>
<h4 id="遍历查询结果示例"><a href="#遍历查询结果示例" class="headerlink" title="遍历查询结果示例"></a>遍历查询结果示例</h4><blockquote>
<p>以下函数接受一个整数，该整数指定要从示例数据库的film表中查询的行数。FOR循环语句循环遍历查询返回的行，并打印出电影标题。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE FUNCTION for_loop_through_query(</span></span><br><span class="line">   n INTEGER DEFAULT 10</span><br><span class="line">)</span><br><span class="line">RETURNS VOID AS $$</span><br><span class="line">DECLARE</span><br><span class="line">    rec RECORD;</span><br><span class="line">BEGIN</span><br><span class="line">    FOR rec IN SELECT title</span><br><span class="line">          FROM film</span><br><span class="line">          ORDER BY title</span><br><span class="line">          LIMIT n</span><br><span class="line">    LOOP</span><br><span class="line">   RAISE NOTICE <span class="string">'%'</span>, rec.title;</span><br><span class="line">    END LOOP;</span><br><span class="line">END;</span><br><span class="line">$$ LANGUAGE plpgsql;</span><br><span class="line">CREATE FUNCTION</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT for_loop_through_query(5);</span></span><br><span class="line"> for_loop_through_query</span><br><span class="line">------------------------</span><br><span class="line"></span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">注意:  Academy Dinosaur</span><br><span class="line">注意:  Ace Goldfinger</span><br><span class="line">注意:  Adaptation Holes</span><br><span class="line">注意:  Affair Prejudice</span><br><span class="line">注意:  African Egg</span><br></pre></td></tr></table></figure>
<h3 id="用于遍历动态查询的查询结果"><a href="#用于遍历动态查询的查询结果" class="headerlink" title="用于遍历动态查询的查询结果"></a>用于遍历动态查询的查询结果</h3><h4 id="遍历动态查询的语法"><a href="#遍历动态查询的语法" class="headerlink" title="遍历动态查询的语法"></a>遍历动态查询的语法</h4><blockquote>
<p>有时，您想在PL/pgSQL函数中构造一个动态查询并遍历其结果。为此，可以使用FOR循环语句的语法：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ &lt;&lt;label&gt;&gt; ]</span><br><span class="line">FOR row IN EXECUTE string_expression [ USING query_param [, ... ] ]</span><br><span class="line">LOOP</span><br><span class="line">    statements</span><br><span class="line">END LOOP [ label ];</span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用字符串表达式（它是文本格式的SQL语句）代替SQL语句。这使您可以动态构造查询。</li>
</ul>
<ul>
<li>如果查询具有参数，则可以使用USING语句将参数传递给查询。</li>
</ul>
<h4 id="遍历动态查询示例"><a href="#遍历动态查询示例" class="headerlink" title="遍历动态查询示例"></a>遍历动态查询示例</h4><blockquote>
<p>下面的函数演示了如何使用FOR循环语句在动态查询中循环。它接受两个参数：</p>
<ul>
<li>sort_type：1表示按标题对查询结果进行排序，2表示按发行年份对结果进行排序。</li>
</ul>
<ul>
<li>n：要从电影表中查询的行数。注意，它将在USING子句中使用。</li>
</ul>
</blockquote>
<blockquote>
<p>首先，我们基于输入参数构建查询，然后在FOR循环函数中执行查询。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE FUNCTION for_loop_through_dyn_query(</span></span><br><span class="line">   sort_type INTEGER,</span><br><span class="line">   n INTEGER</span><br><span class="line">)</span><br><span class="line">RETURNS VOID AS $$</span><br><span class="line">DECLARE</span><br><span class="line">    rec RECORD;</span><br><span class="line">    query text;</span><br><span class="line">BEGIN</span><br><span class="line">      </span><br><span class="line">   query := <span class="string">'SELECT title, release_year FROM film '</span>;</span><br><span class="line">   IF sort_type = 1 THEN</span><br><span class="line">      query := query || <span class="string">'ORDER BY title'</span>;</span><br><span class="line">   ELSIF sort_type = 2 THEN</span><br><span class="line">     query := query || <span class="string">'ORDER BY release_year'</span>;</span><br><span class="line">   ELSE</span><br><span class="line">      RAISE EXCEPTION <span class="string">'Invalid sort type %s'</span>, sort_type;</span><br><span class="line">   END IF;</span><br><span class="line"> </span><br><span class="line">   query := query || <span class="string">' LIMIT $1'</span>;</span><br><span class="line"> </span><br><span class="line">   FOR rec IN EXECUTE query USING n</span><br><span class="line">        LOOP</span><br><span class="line">      RAISE NOTICE <span class="string">'% - %'</span>, rec.release_year, rec.title;</span><br><span class="line">   END LOOP;</span><br><span class="line">  </span><br><span class="line">END;</span><br><span class="line">$$ LANGUAGE plpgsql;</span><br><span class="line">CREATE FUNCTION</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用for_loop_through_dyn_query()获取5部电影并按标题排序:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT for_loop_through_dyn_query(1,5);</span></span><br><span class="line"> for_loop_through_dyn_query</span><br><span class="line">----------------------------</span><br><span class="line"></span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">注意:  2006 - Academy Dinosaur</span><br><span class="line">注意:  2006 - Ace Goldfinger</span><br><span class="line">注意:  2006 - Adaptation Holes</span><br><span class="line">注意:  2006 - Affair Prejudice</span><br><span class="line">注意:  2006 - African Egg</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用for_loop_through_dyn_query()获取5部电影并按发行年份排序:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT for_loop_through_dyn_query(2,5);</span></span><br><span class="line"> for_loop_through_dyn_query</span><br><span class="line">----------------------------</span><br><span class="line"></span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">注意:  2006 - Grosse Wonderful</span><br><span class="line">注意:  2006 - Airport Pollock</span><br><span class="line">注意:  2006 - Bright Encounters</span><br><span class="line">注意:  2006 - Academy Dinosaur</span><br><span class="line">注意:  2006 - Chamber Italian</span><br></pre></td></tr></table></figure>
<h3 id="PL-pgSQL游标"><a href="#PL-pgSQL游标" class="headerlink" title="PL/pgSQL游标"></a>PL/pgSQL游标</h3><blockquote>
<p>PL/pgSQL游标允许我们封装查询并一次处理每个单独的行。当我们想要将大型结果集划分为多个部分并分别处理每个部分时，我们使用游标。如果我们立即处理它，则可能会出现内存溢出错误。</p>
</blockquote>
<blockquote>
<p>另外，我们可以开发一个返回对游标的引用的函数。这是从函数返回大结果集的有效方法。函数的调用者可以基于游标引用来处理结果集。</p>
</blockquote>
<blockquote>
<p>使用游标的步骤:</p>
<ul>
<li>首先，声明一个游标。</li>
</ul>
<ul>
<li>接下来，打开光标。</li>
</ul>
<ul>
<li>然后，将结果集中的行提取到目标中。</li>
</ul>
<ul>
<li>之后，检查是否还有剩余的行要提取。是，执行步骤3，否则执行步骤5。</li>
</ul>
<ul>
<li>最后，关闭光标。</li>
</ul>
</blockquote>
<h4 id="声明游标"><a href="#声明游标" class="headerlink" title="声明游标"></a>声明游标</h4><blockquote>
<p>要访问游标，需要在块的声明部分声明一个游标变量。PostgreSQL为我们提供了一种称为REFCURSOR的特殊类型来声明游标变量:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">   my_cursor REFCURSOR;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>声明与查询绑定的游标的另一种方法是使用以下语法:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cursor_name [ [NO] SCROLL ] CURSOR [( name datatype, name data <span class="built_in">type</span>, ...)] FOR query;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，为游标指定一个变量名。</li>
</ul>
<ul>
<li>接下来，指定是否可以使用SCROLL向后滚动光标。如果使用NO SCROLL，则不能向后滚动光标。</li>
</ul>
<ul>
<li>然后，放置CURSOR关键字，后跟一个逗号分隔的参数列表（名称数据类型），这些参数定义了查询的参数。 打开游标时，这些参数将被值替换。</li>
</ul>
<ul>
<li>之后，可以在FOR关键字之后指定一个查询。可以在此处使用任何有效的SELECT语句。</li>
</ul>
<blockquote>
<p>声明游标示例</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">    cur_films  CURSOR FOR SELECT * FROM film;</span><br><span class="line">    cur_films2 CURSOR (year <span class="built_in">integer</span>) FOR SELECT * FROM film WHERE release_year = year;</span><br></pre></td></tr></table></figure>
<ul>
<li>cur_films是一个游标，它封装了film表中的所有行。</li>
</ul>
<ul>
<li>cur_films2是一个游标，用于将具有特定发行年份的电影封装在film表中。</li>
</ul>
<h4 id="打开游标"><a href="#打开游标" class="headerlink" title="打开游标"></a>打开游标</h4><blockquote>
<p>必须先打开游标才能将其用于查询行。PostgreSQL提供了打开未绑定和绑定的游标的语法。</p>
</blockquote>
<h5 id="打开未绑定的游标"><a href="#打开未绑定的游标" class="headerlink" title="打开未绑定的游标"></a>打开未绑定的游标</h5><blockquote>
<p>使用以下语法打开未绑定的游标：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPEN unbound_cursor_variable [ [ NO ] SCROLL ] FOR query;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为声明时未绑定的游标变量未绑定到任何查询，所以在打开它时必须指定查询:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPEN my_cursor FOR SELECT * FROM city WHERE counter = p_country;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PostgreSQL允许我们打开游标并将其绑定到动态查询。语法如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OPEN unbound_cursor_variable[ [ NO ] SCROLL ]</span><br><span class="line">FOR EXECUTE query_string [USING expression [, ... ] ];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在以下示例中，我们构建了一个动态查询，该查询基于sort_field参数对行进行排序，并打开执行该动态查询的游标:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query := <span class="string">'SELECT * FROM city ORDER BY $1'</span>;</span><br><span class="line"> </span><br><span class="line">OPEN cur_city FOR EXECUTE query USING sort_field;</span><br></pre></td></tr></table></figure>
<h5 id="打开绑定的游标"><a href="#打开绑定的游标" class="headerlink" title="打开绑定的游标"></a>打开绑定的游标</h5><blockquote>
<p>因为声明时绑定的游标已经绑定到查询，所以当我们打开它时，只需要在必要时将参数传递给查询:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPEN cursor_variable[ (name:=value,name:=value,...)];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在以下示例中，我们打开了上面声明的绑定游标cur_films和cur_films2：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OPEN cur_films;</span><br><span class="line">OPEN cur_films2(year:=2005);</span><br></pre></td></tr></table></figure>
<h5 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h5><blockquote>
<p>打开游标后，我们可以使用FETCH，MOVE，UPDATE或DELETE语句对其进行操作。</p>
</blockquote>
<h4 id="获取下一行"><a href="#获取下一行" class="headerlink" title="获取下一行"></a>获取下一行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FETCH [ direction &#123; FROM | IN &#125; ] cursor_variable INTO target_variable;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>FETCH语句从游标中获取下一行，并为其分配一个target_variable，该target_variable可以是记录，行变量或逗号分隔的变量列表。如果找不到更多行，则将target_variable设置为NULL。</p>
</blockquote>
<blockquote>
<p>默认情况下，如果您未明确指定方向，则光标会移至下一行。以下内容对游标有效：</p>
<ul>
<li>NEXT</li>
</ul>
<ul>
<li>LAST</li>
</ul>
<ul>
<li>PRIOR</li>
</ul>
<ul>
<li>FIRST</li>
</ul>
<ul>
<li>ABSOLUTE count</li>
</ul>
<ul>
<li>RELATIVE count</li>
</ul>
<ul>
<li>FORWARD</li>
</ul>
<ul>
<li>BACKWARD</li>
</ul>
</blockquote>
<blockquote>
<p>请注意，FORWARD和BACKWARD方向仅适用于使用SCROLL选项声明的游标。</p>
</blockquote>
<blockquote>
<p>获取游标的示例:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FETCH cur_films INTO row_film;</span><br><span class="line">FETCH LAST FROM row_film INTO title, release_year;</span><br></pre></td></tr></table></figure>
<h4 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOVE [ direction &#123; FROM | IN &#125; ] cursor_variable;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果只想移动光标而不检索任何行，则可以使用MOVE语句。该方向接受与FETCH语句相同的值。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOVE cur_films2;</span><br><span class="line">MOVE LAST FROM cur_films;</span><br><span class="line">MOVE RELATIVE -1 FROM cur_films;</span><br><span class="line">MOVE FORWARD 3 FROM cur_films;</span><br></pre></td></tr></table></figure>
<h4 id="删除或更新行"><a href="#删除或更新行" class="headerlink" title="删除或更新行"></a>删除或更新行</h4><blockquote>
<p>定位游标后，可以使用DELETE WHERE CURRENT OF或UPDATE WHERE CURRENT OF语句删除或更新游标标识的行，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line">SET column = value, ...</span><br><span class="line">WHERE CURRENT OF cursor_variable;</span><br><span class="line"> </span><br><span class="line">DELETE FROM table_name</span><br><span class="line">WHERE CURRENT OF cursor_variable;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参见以下示例:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE film SET release_year = p_year</span><br><span class="line">WHERE CURRENT OF cur_films;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要关闭打开的游标，使用CLOSE语句，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLOSE cursor_variable;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CLOSE语句释放资源，或者释放了游标变量，使其能够再次使用OPEN语句打开。</p>
</blockquote>
<h4 id="PL-pgSQL游标–全部组合在一起"><a href="#PL-pgSQL游标–全部组合在一起" class="headerlink" title="PL/pgSQL游标–全部组合在一起"></a>PL/pgSQL游标–全部组合在一起</h4><blockquote>
<p>以下get_film_titles（integer）函数接受一个表示电影发行年份的参数。在函数内部，查询所有发行年份等于传递给该函数的发行年份的电影。使用光标在各行之间循环，并连接标题和电影的发行年份，该电影的标题包含ful 。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE FUNCTION get_film_titles(p_year INTEGER)</span></span><br><span class="line">   RETURNS text AS $$</span><br><span class="line">DECLARE</span><br><span class="line">    titles TEXT DEFAULT <span class="string">''</span>;</span><br><span class="line">    rec_film   RECORD;</span><br><span class="line">    cur_films CURSOR(p_year INTEGER)</span><br><span class="line">       FOR SELECT title, release_year</span><br><span class="line">       FROM film</span><br><span class="line">       WHERE release_year = p_year;</span><br><span class="line">BEGIN</span><br><span class="line">   -- Open the cursor</span><br><span class="line">   OPEN cur_films(p_year);</span><br><span class="line">   </span><br><span class="line">   LOOP</span><br><span class="line">    -- fetch row into the film</span><br><span class="line">      FETCH cur_films INTO rec_film;</span><br><span class="line">    -- <span class="built_in">exit</span> when no more row to fetch</span><br><span class="line">      EXIT WHEN NOT FOUND;</span><br><span class="line"> </span><br><span class="line">    -- build the output</span><br><span class="line">      IF rec_film.title LIKE <span class="string">'%ful%'</span> THEN</span><br><span class="line">         titles := titles || <span class="string">','</span> || rec_film.title || <span class="string">':'</span> || rec_film.release_year;</span><br><span class="line">      END IF;</span><br><span class="line">   END LOOP;</span><br><span class="line">  </span><br><span class="line">   -- Close the cursor</span><br><span class="line">   CLOSE cur_films;</span><br><span class="line"> </span><br><span class="line">   RETURN titles;</span><br><span class="line">END; $$</span><br><span class="line"> </span><br><span class="line">LANGUAGE plpgsql;</span><br><span class="line">CREATE FUNCTION</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT get_film_titles(2006);</span></span><br><span class="line">                                             get_film_titles</span><br><span class="line">----------------------------------------------------------------------------------------------------------</span><br><span class="line"> ,Grosse Wonderful:2006,Day Unfaithful:2006,Reap Unfaithful:2006,Unfaithful Kill:2006,Wonderful Drop:2006</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h3 id="PostgreSQL创建过程"><a href="#PostgreSQL创建过程" class="headerlink" title="PostgreSQL创建过程"></a>PostgreSQL创建过程</h3><h4 id="CREATE-PROCEDURE语句语法"><a href="#CREATE-PROCEDURE语句语法" class="headerlink" title="CREATE PROCEDURE语句语法"></a>CREATE PROCEDURE语句语法</h4><blockquote>
<p>要创建新的存储过程，请使用CREATE PROCEDURE语句。下面显示了CREATE PROCEDURE语句的简化语法：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE [OR REPLACE] PROCEDURE procedure_name(parameter_list)</span><br><span class="line">LANGUAGE language_name</span><br><span class="line">AS $$</span><br><span class="line">    stored_procedure_body;</span><br><span class="line">$$;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，在CREATE PROCEDURE子句之后指定存储过程的名称。</li>
</ul>
<ul>
<li>接下来，定义一个类似于用户定义功能的参数列表的参数列表。</li>
</ul>
<ul>
<li>然后，为存储过程指定编程语言，例如PLpgSQL和SQL。</li>
</ul>
<ul>
<li>之后，将代码放在该存储过程主体的AS关键字之后。</li>
</ul>
<ul>
<li>最后，使用双元（$$）结束存储过程。</li>
</ul>
<blockquote>
<p>与用户定义的函数不同，存储过程没有返回值。如果要更早地结束过程，可以使用不带任何表达式的RETURN语句，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RETURN;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要从存储过程返回值，则可以使用输出参数。输出参数的最终值将返回给调用方。</p>
</blockquote>
<h4 id="创建存储过程示例"><a href="#创建存储过程示例" class="headerlink" title="创建存储过程示例"></a>创建存储过程示例</h4><blockquote>
<p>使用以下accounts表进行演示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE accounts (</span></span><br><span class="line">    id INT GENERATED BY DEFAULT AS IDENTITY,</span><br><span class="line">    name VARCHAR(100) NOT NULL,</span><br><span class="line">    balance DEC(15,2) NOT NULL,</span><br><span class="line">    PRIMARY KEY(id)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">INSERT INTO accounts(name,balance)</span><br><span class="line">VALUES(<span class="string">'Bob'</span>,10000);</span><br><span class="line"> </span><br><span class="line">INSERT INTO accounts(name,balance)</span><br><span class="line">VALUES(<span class="string">'Alice'</span>,10000);</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下是accounts表中的数据：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT * FROM accounts;</span></span><br><span class="line"> id | name  | balance</span><br><span class="line">----+-------+----------</span><br><span class="line">  1 | Bob   | 10000.00</span><br><span class="line">  2 | Alice | 10000.00</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建一个名为transfer的存储过程，该过程将指定的金额从一个帐户转移到另一个帐户:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE PROCEDURE transfer(INT, INT, DEC)</span></span><br><span class="line">LANGUAGE plpgsql    </span><br><span class="line">AS $$</span><br><span class="line">BEGIN</span><br><span class="line">    -- subtracting the amount from the sender<span class="string">'s account</span></span><br><span class="line"><span class="string">    UPDATE accounts</span></span><br><span class="line"><span class="string">    SET balance = balance - $3</span></span><br><span class="line"><span class="string">    WHERE id = $1;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    -- adding the amount to the receiver'</span>s account</span><br><span class="line">    UPDATE accounts</span><br><span class="line">    SET balance = balance + <span class="variable">$3</span></span><br><span class="line">    WHERE id = <span class="variable">$2</span>;</span><br><span class="line"> </span><br><span class="line">    COMMIT;</span><br><span class="line">END;</span><br><span class="line">$$;</span><br><span class="line">CREATE PROCEDURE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要调用存储过程，请使用CALL语句，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL stored_procedure_name(parameter_list);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用存储过程并验证:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CALL transfer(1,2,1000);</span></span><br><span class="line">CALL</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT * FROM accounts;</span></span><br><span class="line"> id | name  | balance</span><br><span class="line">----+-------+----------</span><br><span class="line">  1 | Bob   |  9000.00</span><br><span class="line">  2 | Alice | 11000.00</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    
    
    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="ZhiJian">
            
              <p class="site-author-name" itemprop="name">ZhiJian</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">43</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">26</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/zhijiansd" title="GitHub &rarr; https://github.com/zhijiansd" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:wangzhijiansd@qq.com" title="E-Mail &rarr; mailto:wangzhijiansd@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/zhitalk" title="weixin &rarr; zhitalk"><i class="fa fa-fw fa-weixin"></i>weixin</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="http://blog.51cto.com/wangzhijian" title="51blog &rarr; http://blog.51cto.com/wangzhijian" rel="noopener" target="_blank"><i class="fa fa-fw fa-pied-piper"></i>51blog</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhiJian</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">732k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">20:20</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.5.0</div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      本站总访问量<span class="busuanzi-value" id="busuanzi_value_site_uv"></span>人次
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      本站总访问量<span class="busuanzi-value" id="busuanzi_value_site_pv"></span>次
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
      
  
  <script type="text/javascript" color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  








  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  
  
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'YDspHswalVwn03xuqlx5EKQF-gzGzoHsz',
        appKey: 'pA3bP9yhf50EIhapICs6ohRC',
        placeholder: '欢迎评论',
        avatar:'mm',
        meta:guest,
        pageSize:'10' || 10,
        visitor: false
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  
  

  

  

  

  

  

  


  
     <script type="text/javascript" color="255,48,48" opacity="0.7" zindex="-2" count="150" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  

</body>
</html>
