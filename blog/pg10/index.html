<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="数据库约束主键 主键是一列或一组列，用于在表中唯一地标识一行。可以通过主键约束定义主键。从技术上讲，主键约束是非空约束和UNIQUE约束的组合。   一个表只能有一个主键。   将主键添加到每个表是一个好习惯。当您向表中添加主键时，PostgreSQL在用于定义主键的列或一组列上创建唯一的B-tree索引。  创建表时定义主键 通常，使用CREATE TABLE语句定义表的结构时，我们会将主键添加">
<meta name="keywords" content="pg">
<meta property="og:type" content="article">
<meta property="og:title" content="PostgreSQL之数据库约束和数据库类型">
<meta property="og:url" content="zhijiansd.github.io/blog/pg10/index.html">
<meta property="og:site_name" content="ZhiJian">
<meta property="og:description" content="数据库约束主键 主键是一列或一组列，用于在表中唯一地标识一行。可以通过主键约束定义主键。从技术上讲，主键约束是非空约束和UNIQUE约束的组合。   一个表只能有一个主键。   将主键添加到每个表是一个好习惯。当您向表中添加主键时，PostgreSQL在用于定义主键的列或一组列上创建唯一的B-tree索引。  创建表时定义主键 通常，使用CREATE TABLE语句定义表的结构时，我们会将主键添加">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-05-20T05:00:22.037Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PostgreSQL之数据库约束和数据库类型">
<meta name="twitter:description" content="数据库约束主键 主键是一列或一组列，用于在表中唯一地标识一行。可以通过主键约束定义主键。从技术上讲，主键约束是非空约束和UNIQUE约束的组合。   一个表只能有一个主键。   将主键添加到每个表是一个好习惯。当您向表中添加主键时，PostgreSQL在用于定义主键的列或一组列上创建唯一的B-tree索引。  创建表时定义主键 通常，使用CREATE TABLE语句定义表的结构时，我们会将主键添加">






  <link rel="canonical" href="zhijiansd.github.io/blog/pg10/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>PostgreSQL之数据库约束和数据库类型 | ZhiJian</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZhiJian</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="zhijiansd.github.io/blog/pg10/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhiJian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhiJian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">PostgreSQL之数据库约束和数据库类型
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-20 12:58:45 / 修改时间：13:00:22" itemprop="dateCreated datePublished" datetime="2020-05-20T12:58:45+08:00">2020-05-20</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/postresql/" itemprop="url" rel="index"><span itemprop="name">postresql</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/pg10/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/pg10/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">52k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1:27</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="数据库约束"><a href="#数据库约束" class="headerlink" title="数据库约束"></a>数据库约束</h2><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><blockquote>
<p>主键是一列或一组列，用于在表中唯一地标识一行。可以通过主键约束定义主键。从技术上讲，主键约束是非空约束和UNIQUE约束的组合。</p>
</blockquote>
<blockquote>
<p>一个表只能有一个主键。</p>
</blockquote>
<blockquote>
<p>将主键添加到每个表是一个好习惯。当您向表中添加主键时，PostgreSQL在用于定义主键的列或一组列上创建唯一的B-tree索引。</p>
</blockquote>
<h4 id="创建表时定义主键"><a href="#创建表时定义主键" class="headerlink" title="创建表时定义主键"></a>创建表时定义主键</h4><blockquote>
<p>通常，使用CREATE TABLE语句定义表的结构时，我们会将主键添加到表中。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE TABLE (</span><br><span class="line">   column_1 data_type PRIMARY KEY,</span><br><span class="line">   column_2 data_type,</span><br><span class="line">   …</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下语句创建一个名为po_headers的采购订单（PO）标题表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE po_headers (</span></span><br><span class="line">   po_no INTEGER PRIMARY KEY,</span><br><span class="line">   vendor_no INTEGER,</span><br><span class="line">   description TEXT,</span><br><span class="line">   shipping_address TEXT</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<ul>
<li>po_no是po_headers表的主键，它唯一地标识po_headers表中的采购订单。</li>
</ul>
<blockquote>
<p>如果主键包含两列或更多列，则可以按以下方式定义主键约束：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE TABLE (</span><br><span class="line">   column_1 data_type,</span><br><span class="line">   column_2 data_type,</span><br><span class="line">   …</span><br><span class="line">        PRIMARY KEY (column_1, column_2)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如，以下语句创建采购订单目表，该表的主键是采购订单号(po_no)和行项目号(item_no)的组合:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE po_items (</span></span><br><span class="line">   po_no INTEGER,</span><br><span class="line">   item_no INTEGER,</span><br><span class="line">   product_no INTEGER,</span><br><span class="line">   qty INTEGER,</span><br><span class="line">   net_price NUMERIC,</span><br><span class="line">   PRIMARY KEY (po_no, item_no)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果未明确指定主键约束的名称，则PostgreSQL将为主键约束分配一个默认名称。默认情况下，PostgreSQL使用table-name_pkey作为主键约束的默认名称。在此示例中，PostgreSQL使用po_items表的名称po_items_pkey创建了主键约束。</p>
</blockquote>
<blockquote>
<p>如果要指定主键约束的名称，请使用CONSTRAINT子句，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONSTRAINT constraint_name PRIMARY KEY(column_1, column_2,...);</span><br></pre></td></tr></table></figure>
<h4 id="更改现有表结构时定义主键"><a href="#更改现有表结构时定义主键" class="headerlink" title="更改现有表结构时定义主键"></a>更改现有表结构时定义主键</h4><blockquote>
<p>很少为现有表定义主键。如果必须这样做，则可以使用ALTER TABLE语句添加主键约束。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD PRIMARY KEY (column_1, column_2);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建一个名为product的表，而未定义任何主键。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE products (</span></span><br><span class="line">   product_no INTEGER,</span><br><span class="line">   description TEXT,</span><br><span class="line">   product_cost NUMERIC</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>假设要向products表添加主键约束，可以执行以下语句:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE products</span></span><br><span class="line">ADD PRIMARY KEY (product_no);</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<h4 id="向现有表添加自动递增的主键"><a href="#向现有表添加自动递增的主键" class="headerlink" title="向现有表添加自动递增的主键"></a>向现有表添加自动递增的主键</h4><blockquote>
<p>假设我们有一个没有任何主键的表vendors。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE vendors (name VARCHAR(255));</span></span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后，使用INSERT语句向vendors表中添加几行:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO vendors (NAME)</span></span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'Microsoft'</span>),</span><br><span class="line">   (<span class="string">'IBM'</span>),</span><br><span class="line">   (<span class="string">'Apple'</span>),</span><br><span class="line">   (<span class="string">'Samsung'</span>);</span><br><span class="line">INSERT 0 4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查询数据</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   vendors;</span><br><span class="line">   name</span><br><span class="line">-----------</span><br><span class="line"> Microsoft</span><br><span class="line"> IBM</span><br><span class="line"> Apple</span><br><span class="line"> Samsung</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在，如果我们想在vendors表中添加一个名为id的主键，并且id字段会自动递增一个，我们可以使用以下语句:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE vendors ADD COLUMN ID SERIAL PRIMARY KEY;</span></span><br><span class="line">ALTER TABLE</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   id,name</span><br><span class="line">FROM</span><br><span class="line">   vendors;</span><br><span class="line"> id |   name</span><br><span class="line">----+-----------</span><br><span class="line">  1 | Microsoft</span><br><span class="line">  2 | IBM</span><br><span class="line">  3 | Apple</span><br><span class="line">  4 | Samsung</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<h4 id="删除主键"><a href="#删除主键" class="headerlink" title="删除主键"></a>删除主键</h4><blockquote>
<p>要删除现有的主键约束，可以使用具有以下语法的ALTER TABLE语句:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name DROP CONSTRAINT primary_key_constraint;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如，要删除products表的主键约束，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE products</span></span><br><span class="line">DROP CONSTRAINT products_pkey;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><blockquote>
<p>外键是表中的一个字段或一组字段，用于唯一标识另一个表中的行。换句话说，在引用另一个表的主键的表中定义了外键。</p>
</blockquote>
<blockquote>
<p>包含外键的表称为引用表或子表。外键引用的表称为引用表或父表。</p>
</blockquote>
<blockquote>
<p>一个表可以具有多个外键，这取决于它与其他表的关系。</p>
</blockquote>
<blockquote>
<p>在PostgreSQL中，您可以通过外键约束定义外键。外键约束指示子表中的一列或一组列中的值与父表的一列或一组列中的值匹配。我们说外键约束保持了子表和父表之间的参照完整性。</p>
</blockquote>
<h4 id="定义简单的外键约束"><a href="#定义简单的外键约束" class="headerlink" title="定义简单的外键约束"></a>定义简单的外键约束</h4><blockquote>
<p>假设我们有一个名为so_headers的表用于存储销售订单标题信息，例如销售订单ID，客户ID和运送地址：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE so_headers (</span></span><br><span class="line">   id SERIAL PRIMARY KEY,</span><br><span class="line">   customer_id INTEGER,</span><br><span class="line">   ship_to VARCHAR (255)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>销售订单的行存储在另一个表销售订单行（so_items）中：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE so_items (</span></span><br><span class="line">  item_id INTEGER NOT NULL,   </span><br><span class="line">  so_id INTEGER,</span><br><span class="line">  product_id INTEGER,</span><br><span class="line">  qty INTEGER,</span><br><span class="line">  net_price NUMERIC,</span><br><span class="line">  PRIMARY KEY (item_id,so_id)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>假设销售订单行表（so_items）包含存在的销售订单数据。为此，我们在so_items表中定义一个外键约束，该约束引用CREATE TABLE语句so_headers中的表，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; DROP TABLE so_items;</span><br><span class="line">DROP TABLE</span><br><span class="line"><span class="built_in">test</span>=&gt; CREATE TABLE so_items (</span><br><span class="line">  item_id INTEGER NOT NULL,   </span><br><span class="line">  so_id INTEGER REFERENCES so_headers(id),</span><br><span class="line">  product_id INTEGER,</span><br><span class="line">  qty INTEGER,</span><br><span class="line">  net_price NUMERIC,</span><br><span class="line">  PRIMARY KEY (item_id,so_id)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，我们使用REFERENCES子句为so_items表定义外键约束。这意味着so_items表中的so_id列引用了so_headers表的id列。</p>
</blockquote>
<blockquote>
<p>定义外键约束的另一种方法是使用表约束，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE so_items (</span><br><span class="line">   item_id INTEGER NOT NULL,</span><br><span class="line">   so_id INTEGER,</span><br><span class="line">   product_id INTEGER,</span><br><span class="line">   qty INTEGER,</span><br><span class="line">   net_price NUMERIC,</span><br><span class="line">   PRIMARY KEY (item_id, so_id),</span><br><span class="line">   FOREIGN KEY (so_id) REFERENCES so_headers (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>因为我们没有为外键约束明确指定名称，所以PostgreSQL使用以下模式分配了名称：table_column_fkey。在我们的示例中，PostgreSQL创建一个外键约束为so_items_so_id_fkey。</li>
</ul>
<ul>
<li>销售订单的每个订单项必须属于一个特定的销售订单。 每个销售订单可以有一个或多个订单项。 这就是所谓的一对多关系。 如果不参考so_items表中的有效so_id，则无法在so_items中插入行。</li>
</ul>
<ul>
<li>如果删除so_headers中的行，那么so_items表中的行会怎样？PostgreSQL为我们提供了以下主要选项：DELETE RESTRICT，DELETE CASCADE和NO ACTION。</li>
</ul>
<blockquote>
<p>PostgreSQL不会删除so_headers表中的行，直到so_items中的所有引用行都被删除。为了实现这一点，当我们定义外键约束时，我们使用ON DELETE RESTRICT表达式:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># drop table so_items;</span></span><br><span class="line">DROP TABLE</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE so_items (</span></span><br><span class="line">  item_id INTEGER NOT NULL,   </span><br><span class="line">  so_id int4 REFERENCES so_headers(id) ON DELETE RESTRICT,</span><br><span class="line">  product_id INTEGER,</span><br><span class="line">  qty INTEGER,</span><br><span class="line">  net_price numeric,</span><br><span class="line">  PRIMARY KEY (item_id,so_id)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PostgreSQL将删除so_items表中所有引用到so_headers表中要删除的行的行。为了指示PostgreSQL执行此操作，我们使用ON DELETE CASCADE如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># drop table so_items;</span></span><br><span class="line">DROP TABLE</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE so_items (</span></span><br><span class="line">  item_id int4 NOT NULL,   </span><br><span class="line">  so_id int4 REFERENCES so_headers(id) ON DELETE CASCADE,</span><br><span class="line">  product_id int4,</span><br><span class="line">  qty int4,</span><br><span class="line">  net_price numeric,</span><br><span class="line">  PRIMARY KEY (item_id,so_id)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果我们未指定RESTRICT或DELETE操作，则PostgreSQL默认将使用NO ACTION。如果使用NO ACTION，则在检查约束时如果引用行仍然存在，则PostgreSQL将引发错误。</p>
</blockquote>
<blockquote>
<p>请注意，删除操作也适用于更新。这意味着您可以具有“ ON UPDATE RESTRICT”，“ ON UPDATE CASCADE”和“ ON UPDATE NO ACTION”。</p>
</blockquote>
<h4 id="将一组列定义为外键"><a href="#将一组列定义为外键" class="headerlink" title="将一组列定义为外键"></a>将一组列定义为外键</h4><blockquote>
<p>如果外键是一组列，则使用以下语法定义外键约束：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE child_table(</span><br><span class="line">  c1 INTEGER PRIMARY KEY,</span><br><span class="line">  c2 INTEGER,</span><br><span class="line">  c3 INTEGER,</span><br><span class="line">  FOREIGN KEY (c2, c3) REFERENCES parent_table (p1, p2)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="将外键约束添加到现有表"><a href="#将外键约束添加到现有表" class="headerlink" title="将外键约束添加到现有表"></a>将外键约束添加到现有表</h4><blockquote>
<p>要将外键约束添加到现有表，请使用ALTER TABLE语句，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE child_table</span><br><span class="line">ADD CONSTRAINT constraint_name FOREIGN KEY (c1) REFERENCES parent_table (p1);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后一点，当您要将带有ON DELETE CASCADE的外键约束添加到现有表时，需要执行以下步骤：</p>
<ul>
<li>删除现有的外键约束。</li>
</ul>
<ul>
<li>使用ON DELETE CASCADE操作添加新的外键约束。</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE child_table</span><br><span class="line">ADD CONSTRAINT constraint_fk</span><br><span class="line">FOREIGN KEY (c1)</span><br><span class="line">REFERENCES parent_table(p1)</span><br><span class="line">ON DELETE CASCADE;</span><br></pre></td></tr></table></figure>
<h3 id="CHECK约束"><a href="#CHECK约束" class="headerlink" title="CHECK约束"></a>CHECK约束</h3><blockquote>
<p>CHECK约束是一种约束，它允许您指定列中的值是否必须满足特定要求。CHECK约束使用布尔表达式在插入或更新到列之前评估值。如果这些值通过检查，则PostgreSQL将在列中插入或更新这些值。</p>
</blockquote>
<h4 id="为新表定义CHECK约束"><a href="#为新表定义CHECK约束" class="headerlink" title="为新表定义CHECK约束"></a>为新表定义CHECK约束</h4><blockquote>
<p>通常，在使用CREATE TABLE语句创建表时会使用CHECK约束。如下定义一个名为test8的表:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE test8 (</span></span><br><span class="line">   id serial PRIMARY KEY,</span><br><span class="line">   first_name VARCHAR (50),</span><br><span class="line">   last_name VARCHAR (50),</span><br><span class="line">   birth_date DATE CHECK (birth_date &gt; <span class="string">'1900-01-01'</span>),</span><br><span class="line">   joined_date DATE CHECK (joined_date &gt; birth_date),</span><br><span class="line">   salary numeric CHECK(salary &gt; 0)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该表具有三个CHECK约束：</p>
<ul>
<li>首先，员工的出生日期（birth_date）必须大于1900-01-01。如果您尝试在1900年1月1日之前插入出生日期，则会收到错误消息。</li>
</ul>
<ul>
<li>其次，加入日期（joined_date）必须大于出生日期（birth_date）。此检查将防止根据其语义更新无效日期。</li>
</ul>
<ul>
<li>第三，工资必须大于零，这很明显。</li>
</ul>
</blockquote>
<blockquote>
<p>尝试向表中插入新行，该语句试图在薪水列中插入负薪水。但是，PostgreSQL返回以下错误消息:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test8 (</span></span><br><span class="line">   first_name,</span><br><span class="line">   last_name,</span><br><span class="line">   birth_date,</span><br><span class="line">   joined_date,</span><br><span class="line">   salary</span><br><span class="line">)</span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'John'</span>,</span><br><span class="line">      <span class="string">'Doe'</span>,</span><br><span class="line">      <span class="string">'1991-01-01'</span>,</span><br><span class="line">      <span class="string">'2012-12-12'</span>,</span><br><span class="line">      - 100000</span><br><span class="line">   );</span><br><span class="line">错误:  关系 <span class="string">"test8"</span> 的新列违反了检查约束 <span class="string">"test8_salary_check"</span></span><br><span class="line">DETAIL:  失败, 行包含(1, John, Doe, 1991-01-01, 2012-12-12, -100000).</span><br></pre></td></tr></table></figure>
<ul>
<li>插入失败，因为在salary列上的CHECK约束仅接受正值。</li>
</ul>
<blockquote>
<p>默认情况下，PostgreSQL使用以下模式为CHECK约束命名：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;table&#125;_&#123;column&#125;_check</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如，salary列上的约束具有以下约束名称：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test8_salary_check</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是，如果要为CHECK约束分配特定名称，则可以在CONSTRAINT表达式后指定它，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column_name data_type CONSTRAINT constraint_name CHECK(...)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请参见以下示例：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">salary numeric CONSTRAINT positive_salary CHECK(salary &gt; 0)</span><br></pre></td></tr></table></figure>
<h4 id="为现有表定义CHECK约束"><a href="#为现有表定义CHECK约束" class="headerlink" title="为现有表定义CHECK约束"></a>为现有表定义CHECK约束</h4><blockquote>
<p>要将CHECK约束添加到现有表，请使用以下ALTER TABLE语句。假设数据库中已有一个名为 prices_list的表。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE prices_list (</span></span><br><span class="line">   id serial PRIMARY KEY,</span><br><span class="line">   product_id INT NOT NULL,</span><br><span class="line">   price NUMERIC NOT NULL,</span><br><span class="line">   discount NUMERIC NOT NULL,</span><br><span class="line">   valid_from DATE NOT NULL,</span><br><span class="line">   valid_to DATE NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在，使用ALTER TABLE语句将CHECK约束添加到prices_list表中。价格和折扣必须大于零，且折扣小于价格。注意，我们使用包含AND运算符的布尔表达式:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE prices_list ADD CONSTRAINT price_discount_check CHECK (</span></span><br><span class="line">   price &gt; 0</span><br><span class="line">   AND discount &gt;= 0</span><br><span class="line">   AND price &gt; discount</span><br><span class="line">);</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有效日期(valid_to)必须大于或等于有效日期(valid_from)。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE prices_list</span></span><br><span class="line">ADD CONSTRAINT valid_range_check CHECK (valid_to &gt;= valid_from);</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CHECK约束对于放置附加逻辑来限制列可以在数据库层接受的值非常有用。通过使用CHECK约束，可以确保将数据正确更新到数据库。</p>
</blockquote>
<h3 id="UNIQUE约束"><a href="#UNIQUE约束" class="headerlink" title="UNIQUE约束"></a>UNIQUE约束</h3><blockquote>
<p>UNIQUE约束确保存储在一个或一组列中的值在整个表中是唯一的。</p>
</blockquote>
<blockquote>
<p>使用UNIQUE约束，每次您插入新行时，PostgreSQL都会检查该值是否已在表中。如果发现新值已经存在，则拒绝更改并发出错误。进行相同的过程以更新现有数据。</p>
</blockquote>
<blockquote>
<p>当您向一列或一组列添加UNIQUE约束时，PostgreSQL将在相应的列或一组列上自动创建唯一索引。</p>
</blockquote>
<h4 id="UNIQUE约束示例"><a href="#UNIQUE约束示例" class="headerlink" title="UNIQUE约束示例"></a>UNIQUE约束示例</h4><blockquote>
<p>以下语句创建一个名为person的新表，该表对email列具有UNIQUE约束:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE person (</span></span><br><span class="line">   id serial PRIMARY KEY,</span><br><span class="line">   name VARCHAR (50),</span><br><span class="line">   email VARCHAR (50) UNIQUE</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，上面的UNIQUE约束可以重写为表约束，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># drop table person;</span></span><br><span class="line">DROP TABLE</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE person (</span></span><br><span class="line">   id SERIAL  PRIMARY KEY,</span><br><span class="line">   name VARCHAR (50),</span><br><span class="line">   email      VARCHAR (50),</span><br><span class="line">   UNIQUE(email)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先，我们使用INSERT语句在person表中插入新行：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO person(name,email)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'zhi'</span>,</span><br><span class="line">      <span class="string">'zhi@pg.com'</span></span><br><span class="line">   );</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其次，我们在另一行插入重复的电子邮件，PostgreSQL发出了错误消息:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO person(name,email)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'zhian'</span>,</span><br><span class="line">      <span class="string">'zhi@pg.com'</span></span><br><span class="line">   );</span><br><span class="line">错误:  重复键违反唯一约束<span class="string">"person_email_key"</span></span><br><span class="line">DETAIL:  键值<span class="string">"(email)=(zhi@pg.com)"</span> 已经存在</span><br></pre></td></tr></table></figure>
<h4 id="在多列上创建约束"><a href="#在多列上创建约束" class="headerlink" title="在多列上创建约束"></a>在多列上创建约束</h4><blockquote>
<p>使用以下语法为一组列创建UNIQUE约束：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table (</span><br><span class="line">    c1 data_type,</span><br><span class="line">    c2 data_type,</span><br><span class="line">    c3 data_type,</span><br><span class="line">    UNIQUE (c2, c3)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>在整个表中，列c2和c3中值的组合将是唯一的。列c2或c3的值不必唯一。</li>
</ul>
<h4 id="使用唯一索引添加唯一约束"><a href="#使用唯一索引添加唯一约束" class="headerlink" title="使用唯一索引添加唯一约束"></a>使用唯一索引添加唯一约束</h4><blockquote>
<p>向现有列或一组列添加唯一约束。</p>
</blockquote>
<blockquote>
<p>首先，假设有一个名为equipment的表：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE equipment (</span></span><br><span class="line">   id serial PRIMARY KEY,</span><br><span class="line">   name VARCHAR (50) NOT NULL,</span><br><span class="line">   equip_id VARCHAR (16) NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其次，基于equip_id列创建唯一索引。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE UNIQUE INDEX CONCURRENTLY equipment_equip_id</span></span><br><span class="line">ON equipment (equip_id);</span><br><span class="line">CREATE INDEX</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三，使用equipment_equip_id索引向设备表添加唯一约束。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE equipment</span></span><br><span class="line">ADD CONSTRAINT unique_equip_id</span><br><span class="line">UNIQUE USING INDEX equipment_equip_id;</span><br><span class="line">注意:  ALTER TABLE / ADD CONSTRAINT USING INDEX 会把索引 <span class="string">"equipment_equip_id"</span> 重命名为 <span class="string">"unique_equip_id"</span></span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，ALTER TABLE语句获取表的排他锁。如果有任何待处理的事务，它将在更改表之前等待所有事务完成。因此，应该使用以下查询检查pg_stat_activity表以查看当前正在进行的未决事务：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   datid,</span><br><span class="line">   datname,</span><br><span class="line">        usename,</span><br><span class="line">   state</span><br><span class="line">FROM</span><br><span class="line">   pg_stat_activity;</span><br><span class="line"> datid | datname | usename  | state</span><br><span class="line">-------+---------+----------+--------</span><br><span class="line">       |         |          |</span><br><span class="line">       |         | postgres |</span><br><span class="line"> 17043 | <span class="built_in">test</span>    | <span class="built_in">test</span>     | active</span><br><span class="line">       |         |          |</span><br><span class="line">       |         |          |</span><br><span class="line">       |         |          |</span><br><span class="line">(6 rows)</span><br></pre></td></tr></table></figure>
<h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><blockquote>
<p>在数据库理论中，NULL是未知或丢失的信息。NULL值不同于空字符串或数字零。</p>
</blockquote>
<blockquote>
<p>NULL值非常特殊。例如，NULL甚至不等于NULL。要检查值是否为NULL，请使用布尔运算符IS NULL或IS NOT NULL。该表达式NULL = NULL返回NULL。</p>
</blockquote>
<blockquote>
<p>PostgreSQL提供了非空约束来强制列不能接受NULL值。这意味着无论何时插入或更新数据，都必须指定一个与NULL值不同的值。</p>
</blockquote>
<h4 id="创建新表时将非空约束添加到列"><a href="#创建新表时将非空约束添加到列" class="headerlink" title="创建新表时将非空约束添加到列"></a>创建新表时将非空约束添加到列</h4><blockquote>
<p>CREATE TABLE语句创建一个具有非空约束的新表名invoice:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE invoice(</span></span><br><span class="line">  id serial PRIMARY KEY,</span><br><span class="line">  product_id int NOT NULL,</span><br><span class="line">  qty numeric NOT NULL CHECK(qty &gt; 0),</span><br><span class="line">  net_price numeric CHECK(net_price &gt; 0)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<ul>
<li>这里使用了NOT NULL，后跟该列的数据类型来声明not-null约束。在这种情况下，它是列约束。</li>
</ul>
<blockquote>
<p>请注意，一列可以具有多个约束，例如，not-null、check、unique、foreign key彼此相邻出现。顺序并不重要，因此PostgreSQL可以按任何顺序检查列表中的任何空约束。</p>
</blockquote>
<blockquote>
<p>如果使用NULL而不是NOT NULL，则该列将同时接受null和非null值。如果不同时使用NOT NULL和NULL，则PostgreSQL默认使用NULL。</p>
</blockquote>
<h4 id="将非空约束添加到现有表的列中"><a href="#将非空约束添加到现有表的列中" class="headerlink" title="将非空约束添加到现有表的列中"></a>将非空约束添加到现有表的列中</h4><blockquote>
<p>要将非空约束添加到现有表的列，请使用ALTER TABLE语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER  TABLE table_name</span><br><span class="line">ALTER COLUMN column_name SET NOT NULL;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要将非空约束添加到现有表的多个列，请使用以下语法：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER  TABLE table_name</span><br><span class="line">ALTER COLUMN column_name_1 SET NOT NULL,</span><br><span class="line">ALTER COLUMN column_name_2 SET NOT NULL;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先，创建一个名为production_orders的新表：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE production_orders (</span></span><br><span class="line">   ID serial PRIMARY KEY,</span><br><span class="line">   description VARCHAR (40) NOT NULL,</span><br><span class="line">   material_id VARCHAR (16),</span><br><span class="line">   qty NUMERIC,</span><br><span class="line">   start_date DATE,</span><br><span class="line">   finish_date DATE</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接下来，在production_orders表中插入新行：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO production_orders (description)</span></span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'fly'</span>);</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后，如果要确保qty字段不为null，以便将not-null约束添加到qty列。但是，该表中已经有数据。如果尝试添加非空约束，则PostgreSQL将发出错误消息:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE production_orders ALTER COLUMN qty</span></span><br><span class="line">SET NOT NULL;</span><br><span class="line">错误:  字段 <span class="string">"qty"</span> 包含空值</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因此，需要在添加非空约束之前先更新数据。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE production_orders</span></span><br><span class="line">SET qty = 1;</span><br><span class="line">UPDATE 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在就可以添加非空约束了。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE production_orders ALTER COLUMN qty</span></span><br><span class="line">SET NOT NULL;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>之后，可以更新material_id，start_date和finish_date列的非空约束：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE production_orders</span></span><br><span class="line">SET material_id = <span class="string">'ABC'</span>,</span><br><span class="line">    start_date = <span class="string">'2018-08-08'</span>,</span><br><span class="line">    finish_date = <span class="string">'2019-09-09'</span>;</span><br><span class="line">UPDATE 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>向多个列添加非空约束：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE production_orders</span></span><br><span class="line">ALTER COLUMN material_id SET NOT NULL,</span><br><span class="line">ALTER COLUMN start_date SET NOT NULL,</span><br><span class="line">ALTER COLUMN finish_date SET NOT NULL;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后，尝试打破非空约束，PostgreSQL发出错误消息：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE production_orders</span></span><br><span class="line">SET qty = NULL;</span><br><span class="line">错误:  在字段 <span class="string">"qty"</span> 中空值违反了非空约束</span><br><span class="line">DETAIL:  失败, 行包含(1, fly, ABC, null, 2018-08-08, 2019-09-09).</span><br></pre></td></tr></table></figure>
<h4 id="非空约束的特殊情况"><a href="#非空约束的特殊情况" class="headerlink" title="非空约束的特殊情况"></a>非空约束的特殊情况</h4><blockquote>
<p>使用检查约束来表示非空约束。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NOT NULL</span><br></pre></td></tr></table></figure>
<blockquote>
<p>相当于</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHECK(column IS NOT NULL)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这很有用，有时您可能希望a列或b列都不为空，但不能同时包含两者。例如，在users表中，您希望username或email列不为null或为空，则可以使用检查约束，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE users (</span></span><br><span class="line">ID serial PRIMARY KEY,</span><br><span class="line">username VARCHAR (50),</span><br><span class="line">PASSWORD VARCHAR (50),</span><br><span class="line">email VARCHAR (50),</span><br><span class="line">CONSTRAINT username_email_notnull CHECK (</span><br><span class="line">   NOT (</span><br><span class="line">     ( username IS NULL  OR  username = <span class="string">''</span> )</span><br><span class="line">     AND</span><br><span class="line">     ( email IS NULL  OR  email = <span class="string">''</span> )</span><br><span class="line">   )</span><br><span class="line">)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下插入语句有效:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO users (username, email)</span></span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'user1'</span>, NULL),</span><br><span class="line">   (NULL, <span class="string">'email1@example.com'</span>),</span><br><span class="line">   (<span class="string">'user2'</span>, <span class="string">'email2@example.com'</span>),</span><br><span class="line">   (<span class="string">'user3'</span>, <span class="string">''</span>);</span><br><span class="line">INSERT 0 4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是，如下由于违反了NOT NULL约束，因此此方法将不起作用：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO users (username, email)</span></span><br><span class="line">VALUES</span><br><span class="line">   (NULL, NULL),</span><br><span class="line">   (NULL, <span class="string">''</span>),</span><br><span class="line">   (<span class="string">''</span>, NULL),</span><br><span class="line">   (<span class="string">''</span>, <span class="string">''</span>);</span><br><span class="line">错误:  关系 <span class="string">"users"</span> 的新列违反了检查约束 <span class="string">"username_email_notnull"</span></span><br><span class="line">DETAIL:  失败, 行包含(5, null, null, null).</span><br></pre></td></tr></table></figure>
<h2 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h2><h3 id="布尔数据类型"><a href="#布尔数据类型" class="headerlink" title="布尔数据类型"></a>布尔数据类型</h3><blockquote>
<p>PostgreSQL支持单个布尔数据类型：BOOLEAN，它可以具有三种状态：TRUE，FALSE和NULL。 PostgreSQL使用一个字节在数据库中存储一个布尔值。BOOLEAN可以缩写为BOOL。</p>
</blockquote>
<blockquote>
<p>在标准SQL中，布尔值可以为TRUE，FALSE或NULL。但是，PostgreSQL在处理TRUE和FALSE值时非常灵活。下表显示了PostgreSQL中TRUE和FALSE的有效文字值:</p>
</blockquote>
<table>
<thead>
<tr>
<th>True</th>
<th>False</th>
</tr>
</thead>
<tbody>
<tr>
<td>  true</td>
<td>false</td>
</tr>
<tr>
<td>  ‘t’</td>
<td>‘f’</td>
</tr>
<tr>
<td> ‘true’</td>
<td>‘false’</td>
</tr>
<tr>
<td>  ‘y’</td>
<td>‘n’</td>
</tr>
<tr>
<td>  ‘yes’</td>
<td>‘no’</td>
</tr>
<tr>
<td>  ‘1’</td>
<td>‘0’</td>
</tr>
</tbody>
</table>
<blockquote>
<p>请注意，前导或尾随空格并不重要，除true和false以外的所有常量值都必须用单引号引起来。</p>
</blockquote>
<h4 id="布尔示例"><a href="#布尔示例" class="headerlink" title="布尔示例"></a>布尔示例</h4><blockquote>
<p>创建一个新表test9以记录哪些产品可用:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE test9 (</span></span><br><span class="line">   product_id INT NOT NULL PRIMARY KEY,</span><br><span class="line">   available BOOLEAN NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将一些数据插入到表中。我们将各种文字值用作布尔值。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test9 (product_id, available)</span></span><br><span class="line">VALUES</span><br><span class="line">   (100, TRUE),</span><br><span class="line">   (200, FALSE),</span><br><span class="line">   (300, <span class="string">'t'</span>),</span><br><span class="line">   (400, <span class="string">'1'</span>),</span><br><span class="line">   (500, <span class="string">'y'</span>),</span><br><span class="line">   (600, <span class="string">'yes'</span>),</span><br><span class="line">   (700, <span class="string">'no'</span>),</span><br><span class="line">   (800, <span class="string">'0'</span>);</span><br><span class="line">INSERT 0 8</span><br></pre></td></tr></table></figure>
<blockquote>
<p>进行检查</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   test9</span><br><span class="line">WHERE</span><br><span class="line">   available = <span class="string">'yes'</span>;</span><br><span class="line"> product_id | available</span><br><span class="line">------------+-----------</span><br><span class="line">        100 | t</span><br><span class="line">        300 | t</span><br><span class="line">        400 | t</span><br><span class="line">        500 | t</span><br><span class="line">        600 | t</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以使用不带任何运算符的布尔值列来隐含真值</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   test9</span><br><span class="line">WHERE</span><br><span class="line">   available;</span><br><span class="line"> product_id | available</span><br><span class="line">------------+-----------</span><br><span class="line">        100 | t</span><br><span class="line">        300 | t</span><br><span class="line">        400 | t</span><br><span class="line">        500 | t</span><br><span class="line">        600 | t</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同样，如果要查找错误的值，可以将布尔列的值与任何有效的布尔常量进行比较</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   test9</span><br><span class="line">WHERE</span><br><span class="line">   available = <span class="string">'no'</span>;</span><br><span class="line"> product_id | available</span><br><span class="line">------------+-----------</span><br><span class="line">        200 | f</span><br><span class="line">        700 | f</span><br><span class="line">        800 | f</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者，可以使用NOT运算符来检查Boolean列中的值是否为false</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   test9</span><br><span class="line">WHERE</span><br><span class="line">   NOT available;</span><br><span class="line"> product_id | available</span><br><span class="line">------------+-----------</span><br><span class="line">        200 | f</span><br><span class="line">        700 | f</span><br><span class="line">        800 | f</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<h4 id="设置布尔值列的默认值"><a href="#设置布尔值列的默认值" class="headerlink" title="设置布尔值列的默认值"></a>设置布尔值列的默认值</h4><blockquote>
<p>要为现有的布尔列设置默认值，请在ALTER TABLE语句中使用SET DEFAULT子句。</p>
</blockquote>
<blockquote>
<p>例如，以下ALTER TABLE语句为test9表中的可用列设置默认值：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># ALTER TABLE test9 ALTER COLUMN available</span></span><br><span class="line">SET DEFAULT FALSE;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果在未指定可用列的值的情况下插入行，则PostgreSQL默认使用FALSE值。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test9 (product_id)</span></span><br><span class="line">VALUES</span><br><span class="line">   (900);</span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   test9</span><br><span class="line">WHERE</span><br><span class="line">   product_id = 900;</span><br><span class="line"> product_id | available</span><br><span class="line">------------+-----------</span><br><span class="line">        900 | f</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同样，如果要在创建表时为布尔列设置默认值，则可以在列定义中使用DEFAULT子句，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE boolean_demo(</span><br><span class="line">   ...</span><br><span class="line">   is_ok BOOL DEFAULT <span class="string">'t'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="CHAR，VARCHAR和TEXT字符类型"><a href="#CHAR，VARCHAR和TEXT字符类型" class="headerlink" title="CHAR，VARCHAR和TEXT字符类型"></a>CHAR，VARCHAR和TEXT字符类型</h3><blockquote>
<p>PostgreSQL提供三种主要的字符类型:character(n)或char(n), character varying(n)或varchar(n), 以及text，其中n是一个正整数。</p>
</blockquote>
<table>
<thead>
<tr>
<th>角色类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>character varying(n), varchar(n)</td>
<td>有限制的可变长度</td>
</tr>
<tr>
<td>character(n), char(n)</td>
<td>定长，空白填充</td>
</tr>
<tr>
<td>text, varchar</td>
<td>可变的无限长度</td>
</tr>
</tbody>
</table>
<blockquote>
<p>char(n)和varchar(n)最多可以存储n个字符。如果尝试将更长的字符串存储在char(n)或varchar(n)列中，则PostgreSQL将发出错误消息。</p>
</blockquote>
<blockquote>
<p>但是，一个例外是，如果多余的字符都是空格，则PostgreSQL会将空格截断为最大长度并存储字符串。</p>
</blockquote>
<blockquote>
<p>如果字符串明确地转换为char(n)或varchar(n)，则PostgresQL将在插入表之前将字符串截断为n个字符。</p>
</blockquote>
<blockquote>
<p>文本数据类型可以存储长度不受限制的字符串。</p>
</blockquote>
<blockquote>
<p>如果未为varchar数据类型指定n整数，则其行为类似于text数据类型。varchar(无n)和文本的性能相同。</p>
</blockquote>
<blockquote>
<p>为varchar数据类型指定长度说明符的唯一好处是，如果尝试在varchar(n)列中插入更长的字符串，PostgreSQL将检查并发出错误。</p>
</blockquote>
<blockquote>
<p>与varchar不同，没有长度说明符的字符或char与character(1)或char(1)相同。</p>
</blockquote>
<blockquote>
<p>与其他数据库系统不同，在PostgreSQL中，三种字符类型之间没有性能差异。在大多数情况下，如果希望PostgreSQL检查长度限制，则应使用text或varchar和varchar(n)。</p>
</blockquote>
<h4 id="字符类型示例"><a href="#字符类型示例" class="headerlink" title="字符类型示例"></a>字符类型示例</h4><blockquote>
<p>创建列表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE test10 (</span></span><br><span class="line">   id serial PRIMARY KEY,</span><br><span class="line">   x CHAR (1),</span><br><span class="line">   y VARCHAR (10),</span><br><span class="line">   z TEXT</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在表中插入新行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test10 (x, y, z)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'Yes'</span>,</span><br><span class="line">      <span class="string">'This is a test for varchar'</span>,</span><br><span class="line">      <span class="string">'This is a very long text for the PostgreSQL text column'</span></span><br><span class="line">   );</span><br><span class="line">错误:  对于字符类型来说这个值太长了(1)</span><br></pre></td></tr></table></figure>
<ul>
<li>这是因为x列的数据类型为char(1)，我们试图在此列中插入一个包含三个字符的字符串。</li>
</ul>
<blockquote>
<p>修复该列</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test10 (x, y, z)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'Y'</span>,</span><br><span class="line">      <span class="string">'This is a test for varchar'</span>,</span><br><span class="line">      <span class="string">'This is a very long text for the PostgreSQL text column'</span></span><br><span class="line">   );</span><br><span class="line">错误:  对于可变字符类型来说，值太长了(10)</span><br></pre></td></tr></table></figure>
<ul>
<li>这里我们试图在y列中插入长度超过10个字符的字符串但是数据类型为VARCHAR (10)。</li>
</ul>
<blockquote>
<p>修复该行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test10 (x, y, z)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'Y'</span>,</span><br><span class="line">      <span class="string">'varchar'</span>,</span><br><span class="line">      <span class="string">'This is a very long text for the PostgreSQL text column'</span></span><br><span class="line">   );</span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT * FROM test10;</span></span><br><span class="line"> id | x |    y    |                            z</span><br><span class="line">----+---+---------+---------------------------------------------------------</span><br><span class="line">  1 | Y | varchar | This is a very long text <span class="keyword">for</span> the PostgreSQL text column</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>大多数时候，应该选择不带长度说明符的text或varchar类型。</p>
</blockquote>
<h3 id="NUMERIC数据类型"><a href="#NUMERIC数据类型" class="headerlink" title="NUMERIC数据类型"></a>NUMERIC数据类型</h3><blockquote>
<p>NUMERIC类型可以存储许多位数的数字。通常，对于需要精确度的货币或其他金额，请使用NUMERIC类型。</p>
</blockquote>
<h4 id="NUMERIC语法"><a href="#NUMERIC语法" class="headerlink" title="NUMERIC语法"></a>NUMERIC语法</h4><blockquote>
<p>要声明NUMERIC类型的列，请使用以下语法：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NUMERIC(precision, scale)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>精度是位数的总和，小数位数是小数部分的位数。例如，数字1234.567的精度为7，小数位数为3。</p>
</blockquote>
<blockquote>
<p>NUMERIC值最多可在小数点前131072位，在小数点后16383位。</p>
</blockquote>
<blockquote>
<p>NUMERIC类型的小数位数可以为零或正，以下语法定义了小数位数为零的NUMERIC列：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NUMERIC(precision)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果同时忽略精度和小数位数，则可以存储任何精度和小数位数，直到达到上述精度和小数位数的极限。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NUMERIC</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在PostgreSQL中，NUMERIC和DECIMAL类型是等效的，并且它们也是SQL标准的一部分。</p>
</blockquote>
<blockquote>
<p>如果不需要精度，则不应使用该NUMERIC类型，因为对NUMERIC值的计算要比integers，float和double precision 慢。</p>
</blockquote>
<h4 id="NUMERIC示例"><a href="#NUMERIC示例" class="headerlink" title="NUMERIC示例"></a>NUMERIC示例</h4><blockquote>
<p>如果存储的小数位数大于声明的NUMERIC列的小数位数，PostgreSQL将把该值四舍五入到指定的小数位数。</p>
</blockquote>
<blockquote>
<p>创建一个新表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE IF NOT EXISTS test11 (</span></span><br><span class="line">    id serial PRIMARY KEY,</span><br><span class="line">    name VARCHAR NOT NULL,</span><br><span class="line">    price NUMERIC (5, 2)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>插入价格超出price列中声明的价格范围的某些产品</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test11 (NAME, price)</span></span><br><span class="line">VALUES</span><br><span class="line">    (<span class="string">'Phone'</span>,500.215),</span><br><span class="line">    (<span class="string">'Tablet'</span>,500.214);</span><br><span class="line">INSERT 0 2</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    test11;</span><br><span class="line"> id |  name  | price</span><br><span class="line">----+--------+--------</span><br><span class="line">  1 | Phone  | 500.22</span><br><span class="line">  2 | Tablet | 500.21</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为该price列的小数位数为2，所以PostgreSQL将值四舍五入500.215到500.22，四舍五入500.214到500.21</p>
</blockquote>
<blockquote>
<p>如果存储的值的精度超过声明的精度，则PostgreSQL将引发错误，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test11 (name, price)</span></span><br><span class="line">VALUES</span><br><span class="line">    (<span class="string">'Phone'</span>,123456.21);</span><br><span class="line">错误:  数字字段溢出</span><br><span class="line">DETAIL:  精度为5,范围是2的字段必须四舍五入到小于10^3的绝对值.</span><br></pre></td></tr></table></figure>
<h4 id="NUMERIC和NaN"><a href="#NUMERIC和NaN" class="headerlink" title="NUMERIC和NaN"></a>NUMERIC和NaN</h4><blockquote>
<p>除了存储数值外，该NUMERIC列还可以存储称为not-a-number或NaN的特殊值。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE test11</span></span><br><span class="line">SET price = <span class="string">'NaN'</span></span><br><span class="line">WHERE</span><br><span class="line">    id = 1;</span><br><span class="line">UPDATE 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此示例中，我们将id为1的产品的价格更新为NaN。请注意，您必须使用引号将NaN括起来。</p>
</blockquote>
<blockquote>
<p>通常，NaN不等于任何数字，包括自身。这意味着表达式NaN = NaN返回false。但是，PostgreSQL将NaN值视为相等并且NaN大于任何非NaN值。此实现允许PostgreSQL对NUMERIC值进行排序并在基于树的索引中使用它们。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    test11</span><br><span class="line">ORDER BY</span><br><span class="line">    price DESC;</span><br><span class="line"> id |  name  | price</span><br><span class="line">----+--------+--------</span><br><span class="line">  1 | Phone  |    NaN</span><br><span class="line">  2 | Tablet | 500.21</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如上，NaN大于500.21。</p>
</blockquote>
<h3 id="整数数据类型"><a href="#整数数据类型" class="headerlink" title="整数数据类型"></a>整数数据类型</h3><blockquote>
<p>要存储PostgreSQL的全数字，使用以下的整数类型之一：SMALLINT，INTEGER，和BIGINT。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">名字</th>
<th style="text-align:center">储存空间</th>
<th style="text-align:center">Min</th>
<th style="text-align:right">Max</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SMALLINT</td>
<td style="text-align:center">2 bytes</td>
<td style="text-align:center">-32,768</td>
<td style="text-align:right">+32,767</td>
</tr>
<tr>
<td style="text-align:left">INTEGER</td>
<td style="text-align:center">4 bytes</td>
<td style="text-align:center">-2,147,483,648</td>
<td style="text-align:right">+2,147,483,647</td>
</tr>
<tr>
<td style="text-align:left">BIGINT</td>
<td style="text-align:center">8 bytes</td>
<td style="text-align:center">-9,223,372,036,854,775,808</td>
<td style="text-align:right">+9,223,372,036,854,775,807</td>
</tr>
</tbody>
</table>
<blockquote>
<p>如果存储超出允许范围的值，PostgreSQL将发出错误。</p>
</blockquote>
<blockquote>
<p>与MySQL integer不同，PostgreSQL不提供无符号整数类型。</p>
</blockquote>
<h4 id="SMALLINT"><a href="#SMALLINT" class="headerlink" title="SMALLINT"></a>SMALLINT</h4><blockquote>
<p>SMALLINT需要2字节的存储大小，可以存储（-32,767，32,767）范围内的任何整数。可以使用SMALLINT类型存储诸如人们的年龄，一本书的页数等之类的信息。</p>
</blockquote>
<blockquote>
<p>以下语句创建一个名为book的表:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE book (</span></span><br><span class="line">    book_id SERIAL PRIMARY KEY,</span><br><span class="line">    title VARCHAR (255) NOT NULL,</span><br><span class="line">    pages SMALLINT NOT NULL CHECK (pages &gt; 0)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此示例中，该pages列是SMALLINT列。因为一本书的页数必须为正，所以我们添加了一个CHECK约束来强制执行此规则。</p>
</blockquote>
<h4 id="INTEGER"><a href="#INTEGER" class="headerlink" title="INTEGER"></a>INTEGER</h4><blockquote>
<p>INTEGER是整数类型之间最常见的选择，因为它在存储大小，范围和性能之间提供了最佳的平衡。</p>
</blockquote>
<blockquote>
<p>INTEGER类型需要4个字节的存储大小，可以存储（-2,147,483,648，2,147,483,647）范围内的数字。</p>
</blockquote>
<blockquote>
<p>可以将INTEGER类型用于存储相当大的整数（例如城市或国家/地区的人口）的列，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE cities (</span></span><br><span class="line">    city_id serial PRIMARY KEY,</span><br><span class="line">    city_name VARCHAR (255) NOT NULL,</span><br><span class="line">    population INT NOT NULL CHECK (population &gt;= 0)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，INT是INTEGER的同义词。</p>
</blockquote>
<h4 id="BIGINT"><a href="#BIGINT" class="headerlink" title="BIGINT"></a>BIGINT</h4><blockquote>
<p>如果要存储超出INTEGER类型范围的整数，则可以使用BIGINT类型。</p>
</blockquote>
<blockquote>
<p>BIGINT类型需要8个字节的存储大小，该大小可以存储（-9,223,372,036,854,775,808，+ 9,223,372,036,854,775,807）范围内的任何数字。</p>
</blockquote>
<blockquote>
<p>使用BIGINT类型不仅会占用大量存储空间，而且还会降低数据库的性能，因此，您应该有充分的理由再使用它。</p>
</blockquote>
<h3 id="DATE数据类型"><a href="#DATE数据类型" class="headerlink" title="DATE数据类型"></a>DATE数据类型</h3><blockquote>
<p>要存储日期值，请使用PostgreSQL DATE数据类型。PostgreSQL使用4个字节来存储日期值。 DATE数据类型的最低和最高值为4713 BC和5874897 AD。</p>
</blockquote>
<blockquote>
<p>在存储日期值时，PostgreSQL使用yyyy-mm-dd格式，例如2012-12-12。它还使用此格式将数据插入日期列。</p>
</blockquote>
<blockquote>
<p>如果创建的表具有DATE列，并且希望将当前日期用作该列的默认值，则可以在DEFAULT关键字后使用CURRENT_DATE。</p>
</blockquote>
<blockquote>
<p>例如，以下语句创建documents表，该表posting_date列具有DATE数据类型。posting_date列接受当前日期作为默认值:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE cities (</span></span><br><span class="line">    city_id serial PRIMARY KEY,</span><br><span class="line">    city_name VARCHAR (255) NOT NULL,</span><br><span class="line">    population INT NOT NULL CHECK (population &gt;= 0)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE documents (</span></span><br><span class="line">   document_id serial PRIMARY KEY,</span><br><span class="line">   header_text VARCHAR (255) NOT NULL,</span><br><span class="line">   posting_date DATE NOT NULL DEFAULT CURRENT_DATE</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">INSERT INTO documents (header_text)</span><br><span class="line">VALUES</span><br><span class="line">   (<span class="string">'Billing to customer XYZ'</span>);</span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   documents;</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line"> document_id |       header_text       | posting_date</span><br><span class="line">-------------+-------------------------+--------------</span><br><span class="line">           1 | Billing to customer XYZ | 2019-11-30</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="DATE函数"><a href="#DATE函数" class="headerlink" title="DATE函数"></a>DATE函数</h4><blockquote>
<p>创建一个名为的test12表，该表由test_id，name，birth_date和hire_date列组成，其中birate_date和hire_date列的数据类型为DATE。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE test12 (</span></span><br><span class="line">   test_id serial PRIMARY KEY,</span><br><span class="line">   name VARCHAR (355),</span><br><span class="line">   birth_date DATE NOT NULL,</span><br><span class="line">   hire_date DATE NOT NULL</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">INSERT INTO test12 (name, birth_date, hire_date)</span><br><span class="line">VALUES (<span class="string">'Shannon'</span>,<span class="string">'2001-01-01'</span>,<span class="string">'2012-12-12'</span>),</span><br><span class="line">      (<span class="string">'Sheila'</span>,<span class="string">'1988-08-08'</span>,<span class="string">'2008-08-08'</span>),</span><br><span class="line">      (<span class="string">'Ethel'</span>,<span class="string">'1995-05-05'</span>,<span class="string">'2005-05-05'</span>);</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line">INSERT 0 3</span><br></pre></td></tr></table></figure>
<h4 id="获取当前日期"><a href="#获取当前日期" class="headerlink" title="获取当前日期"></a>获取当前日期</h4><blockquote>
<p>要获取当前日期和时间，请使用内置NOW()功能。但是，仅获取日期部分(不包括时间部分)，可以使用双冒号(::)将DATETIME值转换为DATE值。</p>
</blockquote>
<blockquote>
<p>获取数据库服务器的当前日期</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT NOW()::date;</span></span><br><span class="line">    now</span><br><span class="line">------------</span><br><span class="line"> 2019-11-30</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用CURRENT_DATE获取当前日期</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT CURRENT_DATE;</span></span><br><span class="line"> current_date</span><br><span class="line">--------------</span><br><span class="line"> 2019-11-30</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="以特定格式输出日期值"><a href="#以特定格式输出日期值" class="headerlink" title="以特定格式输出日期值"></a>以特定格式输出日期值</h4><blockquote>
<p>要以特定格式输出日期值，请使用TO_CHAR()功能。TO_CHAR()函数接受两个参数。第一个参数是要设置格式的值，第二个参数是定义输出格式的模板。</p>
</blockquote>
<blockquote>
<p>以dd/mm/yyyy格式显示当前日期:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT TO_CHAR(NOW() :: DATE, 'dd/mm/yyyy');</span></span><br><span class="line">  to_char</span><br><span class="line">------------</span><br><span class="line"> 30/11/2019</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或以类似于Dec 12,2012的格式显示日期</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT TO_CHAR(NOW() :: DATE, 'Mon dd, yyyy');</span></span><br><span class="line">   to_char</span><br><span class="line">--------------</span><br><span class="line"> Nov 30, 2019</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="获取两个日期之间的间隔"><a href="#获取两个日期之间的间隔" class="headerlink" title="获取两个日期之间的间隔"></a>获取两个日期之间的间隔</h4><blockquote>
<p>要获取两个日期之间的间隔，请使用减号（-）运算符。 </p>
</blockquote>
<blockquote>
<p>例如，要获取员工的工作天数，可以使用当前时间减去hire_date列中的值进行查询：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   name,</span><br><span class="line">   now() - hire_date as diff</span><br><span class="line">FROM</span><br><span class="line">   test12;</span><br><span class="line">  name   |           diff</span><br><span class="line">---------+---------------------------</span><br><span class="line"> Shannon | 2545 days 00:02:49.320311</span><br><span class="line"> Sheila  | 4132 days 00:02:49.320311</span><br><span class="line"> Ethel   | 5323 days 00:02:49.320311</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<h4 id="计算年、月和日的年龄"><a href="#计算年、月和日的年龄" class="headerlink" title="计算年、月和日的年龄"></a>计算年、月和日的年龄</h4><blockquote>
<p>要使用年、月和日来计算当前日期的年龄，请使用该AGE()函数。以下语句使用AGE()函数计算test12表中员工的年龄:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   test_id,</span><br><span class="line">   name,</span><br><span class="line">   AGE(birth_date)</span><br><span class="line">FROM</span><br><span class="line">   test12;</span><br><span class="line"> test_id |  name   |           age</span><br><span class="line">---------+---------+-------------------------</span><br><span class="line">       1 | Shannon | 18 years 11 mons</span><br><span class="line">       2 | Sheila  | 31 years 3 mons 24 days</span><br><span class="line">       3 | Ethel   | 24 years 6 mons 27 days</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果将日期值传递给AGE()函数，它将从当前日期中减去该日期值。如果将两个参数传递给AGE()函数，它将从第一个参数中减去第二个参数。</p>
</blockquote>
<blockquote>
<p>例如，要获取2012年12月12日的员工年龄，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   test_id,</span><br><span class="line">   name,</span><br><span class="line">   AGE(<span class="string">'2012-12-12'</span>,birth_date)</span><br><span class="line">FROM</span><br><span class="line">   test12;</span><br><span class="line"> test_id |  name   |           age</span><br><span class="line">---------+---------+--------------------------</span><br><span class="line">       1 | Shannon | 11 years 11 mons 11 days</span><br><span class="line">       2 | Sheila  | 24 years 4 mons 4 days</span><br><span class="line">       3 | Ethel   | 17 years 7 mons 7 days</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<h4 id="从日期值中提取年、季度、月、周、日"><a href="#从日期值中提取年、季度、月、周、日" class="headerlink" title="从日期值中提取年、季度、月、周、日"></a>从日期值中提取年、季度、月、周、日</h4><blockquote>
<p>要从日期值中获取日期值中的年，季度，月，周，日，请使用此EXTRACT()函数。以下语句将雇员的出生日期提取为年，月和日：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   test_id,</span><br><span class="line">   name,   </span><br><span class="line">   EXTRACT (YEAR FROM birth_date) AS YEAR,</span><br><span class="line">   EXTRACT (MONTH FROM birth_date) AS MONTH,</span><br><span class="line">   EXTRACT (DAY FROM birth_date) AS DAY</span><br><span class="line">FROM</span><br><span class="line">   test12;</span><br><span class="line"> test_id |  name   | year | month | day</span><br><span class="line">---------+---------+------+-------+-----</span><br><span class="line">       1 | Shannon | 2001 |     1 |   1</span><br><span class="line">       2 | Sheila  | 1988 |     8 |   8</span><br><span class="line">       3 | Ethel   | 1995 |     5 |   5</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<h3 id="时间戳数据类型"><a href="#时间戳数据类型" class="headerlink" title="时间戳数据类型"></a>时间戳数据类型</h3><blockquote>
<p>PostgreSQL提供了两种用于处理时间戳的时间数据类型，一种不带时区（timestamp），一种带时区（timestamptz）。</p>
</blockquote>
<blockquote>
<p>时间戳数据类型允许您存储日期和时间。但是，它没有任何时区数据。这意味着，当您更改数据库服务器的时区时，存储在数据库中的时间戳记值不会更改。</p>
</blockquote>
<blockquote>
<p>timestamptz数据是带有时区的时间戳。时间戳是可识别时区的日期和时间数据类型。PostgreSQL以UTC值存储时间戳。当您在timestamptz列中插入值时，PostgreSQL会将timestamptz值转换为UTC值并将UTC值存储在表中。</p>
</blockquote>
<blockquote>
<p>当您从数据库中查询timestamptz时，PostgreSQL将UTC值转换回数据库服务器，用户或当前数据库连接设置的时区的时间值。</p>
</blockquote>
<blockquote>
<p>请注意，timestamp和timestamptz都使用8个字节来存储时间戳值，如以下查询所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">      typname,</span><br><span class="line">      typlen</span><br><span class="line">FROM</span><br><span class="line">      pg_type</span><br><span class="line">WHERE</span><br><span class="line">      typname ~ <span class="string">'^timestamp'</span>;</span><br><span class="line">   typname   | typlen</span><br><span class="line">-------------+--------</span><br><span class="line"> timestamp   |      8</span><br><span class="line"> timestamptz |      8</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请务必注意，timestamptz值存储为UTC值。PostgreSQL不使用timestamptz值存储任何时区数据。</p>
</blockquote>
<h4 id="时间戳示例"><a href="#时间戳示例" class="headerlink" title="时间戳示例"></a>时间戳示例</h4><blockquote>
<p>创建由timestamp和timestamptz列组成的表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE timestamp_demo (ts TIMESTAMP, tstz TIMESTAMPTZ);</span></span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将数据库服务器的时区设置为Asia/Shanghai</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SET timezone = 'Asia/Shanghai';</span></span><br><span class="line">SET</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看当前时区</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SHOW TIMEZONE;</span></span><br><span class="line">   TimeZone</span><br><span class="line">---------------</span><br><span class="line"> Asia/Shanghai</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>插入新行timstamp_demo</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO timestamp_demo (ts, tstz)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'2018-08-08 20:20:20-07'</span>,</span><br><span class="line">      <span class="string">'2018-08-08 20:20:20-07'</span></span><br><span class="line">   );</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>进行查看</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   *</span><br><span class="line">FROM</span><br><span class="line">   timestamp_demo;</span><br><span class="line">         ts          |          tstz</span><br><span class="line">---------------------+------------------------</span><br><span class="line"> 2018-08-08 20:20:20 | 2018-08-09 11:20:20+08</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常，最佳实践是使用timestamptz数据类型存储时间戳数据。</p>
</blockquote>
<h4 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT NOW();</span></span><br><span class="line">             now</span><br><span class="line">------------------------------</span><br><span class="line"> 2019-12-01 01:02:38.40504+08</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT CURRENT_TIMESTAMP;</span></span><br><span class="line">       current_timestamp</span><br><span class="line">-------------------------------</span><br><span class="line"> 2019-12-01 01:03:10.767703+08</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>获取没有日期的当前时间</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT CURRENT_TIME;</span></span><br><span class="line">    current_time</span><br><span class="line">--------------------</span><br><span class="line"> 01:05:31.757504+08</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，CURRENT_TIMESTAMP和CURRENT_TIME都返回带有时区的当前时间。</p>
</blockquote>
<blockquote>
<p>要使用字符串格式获取一天中的时间，请使用timeofday()函数:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT TIMEOFDAY();</span></span><br><span class="line">              timeofday</span><br><span class="line">-------------------------------------</span><br><span class="line"> Sun Dec 01 01:08:34.266333 2019 CST</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="在时区之间转换"><a href="#在时区之间转换" class="headerlink" title="在时区之间转换"></a>在时区之间转换</h4><blockquote>
<p>要将时间戳转换为另一个时区，可以使用timezone(zone, timestamp) 函数。如下，转换具体时间到Asia/chongqing时区:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SHOW TIMEZONE;</span></span><br><span class="line">   TimeZone</span><br><span class="line">---------------</span><br><span class="line"> Asia/Shanghai</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT timezone('Asia/chongqing','2019-12-01 00:00');</span></span><br><span class="line">      timezone</span><br><span class="line">---------------------</span><br><span class="line"> 2019-12-01 00:00:00</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，我们将时间戳记作为字符串传递给timezone()函数，PostgreSQL将其隐式转换为时间戳记。最好将时间戳值显式转换为timestamptz数据类型，如以下语句所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT timezone(<span class="string">'Asia/chongqing'</span>,<span class="string">'2019-12-01 00:00'</span>::timestamptz);</span><br></pre></td></tr></table></figure>
<h3 id="间隔数据类型"><a href="#间隔数据类型" class="headerlink" title="间隔数据类型"></a>间隔数据类型</h3><blockquote>
<p>时间间隔数据类型使您可以存储和操纵以年，月，日，小时，分钟，秒等为单位的时间段。以下说明了时间间隔类型：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ interval [ fields ] [ (p) ]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个间隔值需要16个字节的存储大小，可以存储一个范围为-178,000,000年至178,000,000年的周期。此外，间隔值可以具有可选的精度值p，其允许范围为0到6。精度p是保留在第二个字段中的小数位数。at符号（@）是可选的，可以忽略。</p>
</blockquote>
<blockquote>
<p>以下示例显示了一些时间间隔值:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interval <span class="string">'2 months ago'</span>;</span><br><span class="line">interval <span class="string">'3 hours 20 minutes'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在内部，PostgreSQL将间隔值存储为月，天和秒。月和日的值是整数，而秒可以字段可以是分数。</p>
</blockquote>
<blockquote>
<p>在进行日期或时间算术时，间隔值非常有用。例如，如果您想知道去年当前时间3小时30分钟前的时间，则可以使用以下语句:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   now(),</span><br><span class="line">   now() - INTERVAL <span class="string">'1 year 3 hours 30 minutes'</span></span><br><span class="line">             AS <span class="string">"3 hours 30 minutes ago of last year"</span>;</span><br><span class="line">              now              | 3 hours 30 minutes ago of last year</span><br><span class="line">-------------------------------+-------------------------------------</span><br><span class="line"> 2019-12-01 01:29:21.353013+08 | 2018-11-30 21:59:21.353013+08</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="PostgreSQL间隔输入格式"><a href="#PostgreSQL间隔输入格式" class="headerlink" title="PostgreSQL间隔输入格式"></a>PostgreSQL间隔输入格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quantity unit [quantity unit...] [direction]</span><br></pre></td></tr></table></figure>
<ul>
<li>quantity是数字，也可以使用符号+或-</li>
</ul>
<ul>
<li>unit可以是千年，世纪，十年，年，月，周，日，小时，分钟，秒，毫秒，微秒或缩写（y，m，d等）中的任何一种，也可以是复数形式（月，日，等等）。</li>
</ul>
<ul>
<li>direction可以是ago或为空字符串’’<blockquote>
<p>此格式称为postgres_verbose，也用于间隔输出格式。 </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>以下示例说明了一些使用详细语法的时间间隔值:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INTERVAL <span class="string">'1 year 2 months 3 days'</span>;</span><br><span class="line">INTERVAL <span class="string">'2 weeks ago'</span>;</span><br></pre></td></tr></table></figure>
<h4 id="ISO-8601间隔格式"><a href="#ISO-8601间隔格式" class="headerlink" title="ISO 8601间隔格式"></a>ISO 8601间隔格式</h4><blockquote>
<p>除了上述冗长的语法外，PostgreSQL还允许您使用ISO 8601时间间隔以两种方式写入间隔值:带指示符的格式和替代格式。</p>
</blockquote>
<blockquote>
<p>ISO 8601带有指示符的格式如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P quantity unit [ quantity unit ...] [ T [ quantity unit ...]]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这种格式下，间隔值必须以字母开头P。字母T用于确定时间单位。</p>
</blockquote>
<blockquote>
<p>ISO 8601间隔单位的缩写:<br> 缩写 |    描述<br>——|——<br>  Y      | 年份<br>  M      |月（在日期部分）<br>  W      | 周数<br>  D      |  天<br>  H      | 小时<br>  M      |分钟（在时间部分）<br>  S      |  秒</p>
</blockquote>
<blockquote>
<p>请注意，M可以是几个月或几分钟，具体取决于它出现在字母T之前还是之后。</p>
</blockquote>
<blockquote>
<p>例如，可以使用ISO 8601指示符格式将6年5个月4天3小时2分1秒的时间间隔编写为： </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P6Y5M4DT3H2M1S</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ISO 8601的替代形式是：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P [ years-months-days ] [ T hours:minutes:seconds ]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>它还必须以字母P开头，字母T分隔间隔值的日期和时间部分。例如，间隔6年5个月4天3小时2分1秒可以用ISO 8601替代格式编写为：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P0006-05-04T03:02:01</span><br></pre></td></tr></table></figure>
<h4 id="PostgreSQL间隔输出格式"><a href="#PostgreSQL间隔输出格式" class="headerlink" title="PostgreSQL间隔输出格式"></a>PostgreSQL间隔输出格式</h4><blockquote>
<p>间隔值的输出样式是使用SET intervalstyle命令设置的，例如：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET intervalstyle = <span class="string">'sql_standard'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PostgreSQL提供了四种输出格式：sql标准，postgres，postgresverbose和iso_8601。默认情况下，PostgresQL使用postgres样式来格式化间隔值。</p>
</blockquote>
<blockquote>
<p>以下代表四种样式中6年5个月4天3小时2分钟1秒的间隔：</p>
</blockquote>
<ul>
<li>sql标准    </li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SET intervalstyle = 'sql_standard';</span></span><br><span class="line">SET</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   INTERVAL <span class="string">'6 years 5 months 4 days 3 hours 2 minutes 1 second'</span>;</span><br><span class="line">     interval</span><br><span class="line">------------------</span><br><span class="line"> +6-5 +4 +3:02:01</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<ul>
<li>Postgres</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SET intervalstyle = 'postgres';</span></span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">   INTERVAL <span class="string">'6 years 5 months 4 days 3 hours 2 minutes 1 second'</span>;</span><br><span class="line">SET</span><br><span class="line"></span><br><span class="line">            interval</span><br><span class="line">--------------------------------</span><br><span class="line"> 6 years 5 mons 4 days 03:02:01</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<ul>
<li>Postgres详细    </li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SET intervalstyle = 'postgres_verbose';</span></span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">   INTERVAL <span class="string">'6 years 5 months 4 days 3 hours 2 minutes 1 second'</span>;</span><br><span class="line">SET</span><br><span class="line"></span><br><span class="line">                   interval</span><br><span class="line">----------------------------------------------</span><br><span class="line"> @ 6 years 5 mons 4 days 3 hours 2 mins 1 sec</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<ul>
<li>iso_8601<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SET intervalstyle = 'iso_8601';</span></span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">   INTERVAL <span class="string">'6 years 5 months 4 days 3 hours 2 minutes 1 second'</span>;</span><br><span class="line">SET</span><br><span class="line"></span><br><span class="line">    interval</span><br><span class="line">----------------</span><br><span class="line"> P6Y5M4DT3H2M1S</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="PostgreSQL间隔相关的运算符和函数"><a href="#PostgreSQL间隔相关的运算符和函数" class="headerlink" title="PostgreSQL间隔相关的运算符和函数"></a>PostgreSQL间隔相关的运算符和函数</h4><h5 id="间隔运算符"><a href="#间隔运算符" class="headerlink" title="间隔运算符"></a>间隔运算符</h5><blockquote>
<p>将算术运算符（+，-，*等）应用于间隔值，例如：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">INTERVAL <span class="string">'2h 50m'</span> + INTERVAL <span class="string">'10m'</span>; -- 03:00:00</span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">INTERVAL <span class="string">'2h 50m'</span> - INTERVAL <span class="string">'50m'</span>; -- 02:00:00</span><br><span class="line"> </span><br><span class="line">SELECT</span><br><span class="line">600 * INTERVAL <span class="string">'1 minute'</span>; -- 10:00:00</span><br></pre></td></tr></table></figure>
<h5 id="将PostgreSQL间隔转换为字符串"><a href="#将PostgreSQL间隔转换为字符串" class="headerlink" title="将PostgreSQL间隔转换为字符串"></a>将PostgreSQL间隔转换为字符串</h5><blockquote>
<p>要将间隔值转换为字符串，请使用TO_CHAR()函数。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TO_CHAR(interval,format)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>TO_CHAR()函数将第一个参数用作间隔值，将第二个参数用作格式，并返回表示指定格式的间隔的字符串。参见以下示例：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    TO_CHAR(</span><br><span class="line">        INTERVAL <span class="string">'17h 20m 05s'</span>,</span><br><span class="line">        <span class="string">'HH24:MI:SS'</span></span><br><span class="line">    );</span><br><span class="line"> to_char</span><br><span class="line">----------</span><br><span class="line"> 17:20:05</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="从PostgreSQL间隔中提取数据"><a href="#从PostgreSQL间隔中提取数据" class="headerlink" title="从PostgreSQL间隔中提取数据"></a>从PostgreSQL间隔中提取数据</h4><blockquote>
<p>要从间隔中提取年，月，日等字段，请使用EXTRACT()功能。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXTRACT(field FROM interval)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该字段可以是您要从时间间隔中提取的年，月，日，时，分等。提取函数返回双精度类型的值。以下示例从间隔中提取分钟:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    EXTRACT (</span><br><span class="line">        MINUTE</span><br><span class="line">        FROM</span><br><span class="line">            INTERVAL <span class="string">'5 hours 21 minutes'</span></span><br><span class="line">    );</span><br><span class="line"> date_part</span><br><span class="line">-----------</span><br><span class="line">        21</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h5 id="调整间隔值"><a href="#调整间隔值" class="headerlink" title="调整间隔值"></a>调整间隔值</h5><blockquote>
<p>PostgreSQL提供两个功能justifydays和justifyhours，您可以将30天的间隔调整为一个月，将24小时的间隔调整为一日：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    justify_days(INTERVAL <span class="string">'30 days'</span>),</span><br><span class="line">    justify_hours(INTERVAL <span class="string">'24 hours'</span>);</span><br><span class="line"> justify_days | justify_hours</span><br><span class="line">--------------+---------------</span><br><span class="line"> P1M          | P1D</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另外，justify_interval函数使用justifydays和justifyhours来调整间隔，并进行其他符号调整：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    justify_interval(interval <span class="string">'1 year -1 hour'</span>);</span><br><span class="line"> justify_interval</span><br><span class="line">------------------</span><br><span class="line"> P11M29DT23H</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h3 id="TIME数据类型"><a href="#TIME数据类型" class="headerlink" title="TIME数据类型"></a>TIME数据类型</h3><h4 id="TIME数据类型语法"><a href="#TIME数据类型语法" class="headerlink" title="TIME数据类型语法"></a>TIME数据类型语法</h4><blockquote>
<p>PostgreSQL提供了TIME数据类型，它允许您存储一天中的时间值。以下语句说明了如何声明具有TIME数据类型的列：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column_name TIME(precision);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间值的精度最高为6位数字。精度指定放置在第二个字段中的小数位数。</p>
</blockquote>
<blockquote>
<p>TIME数据类型需要8个字节，其允许范围为00:00:00至24:00:00。TIME值的常见格式：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HH:MM  </span><br><span class="line">HH:MM:SS</span><br><span class="line">HHMMSS</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">01:02</span><br><span class="line">01:02:03</span><br><span class="line">010203</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要使用精度，可以使用以下格式：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MM:SS.pppppp    </span><br><span class="line">HH:MM:SS.pppppp</span><br><span class="line">HHMMSS.pppppp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以这种形式，p就是精度。例如：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">04:59.999999</span><br><span class="line">04:05:06.777777</span><br><span class="line">040506.777777</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PostgreSQL实际上接受几乎任何合理的TIME格式，包括SQL兼容、ISO 8601等。</p>
</blockquote>
<h4 id="TIME示例"><a href="#TIME示例" class="headerlink" title="TIME示例"></a>TIME示例</h4><blockquote>
<p>我们通常将TIME数据类型用于仅存储一天中时间的列，例如事件或班次的时间。</p>
</blockquote>
<blockquote>
<p>使用CREATE TABLE语句创建一个名为shifts的新表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE shifts (</span></span><br><span class="line">    id serial PRIMARY KEY,</span><br><span class="line">    shift_name VARCHAR NOT NULL,</span><br><span class="line">    start_at TIME NOT NULL,</span><br><span class="line">    end_at TIME NOT NULL</span><br><span class="line">);  </span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在表中插入一些行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO shifts(shift_name, start_at, end_at)</span></span><br><span class="line">VALUES(<span class="string">'Morning'</span>, <span class="string">'08:00:00'</span>, <span class="string">'12:00:00'</span>),</span><br><span class="line">      (<span class="string">'Afternoon'</span>, <span class="string">'13:00:00'</span>, <span class="string">'17:00:00'</span>),</span><br><span class="line">      (<span class="string">'Night'</span>, <span class="string">'18:00:00'</span>, <span class="string">'22:00:00'</span>);</span><br><span class="line">INSERT 0 3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看数据</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    shifts;</span><br><span class="line"> id | shift_name | start_at |  end_at</span><br><span class="line">----+------------+----------+----------</span><br><span class="line">  1 | Morning    | 08:00:00 | 12:00:00</span><br><span class="line">  2 | Afternoon  | 13:00:00 | 17:00:00</span><br><span class="line">  3 | Night      | 18:00:00 | 22:00:00</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<h4 id="时区类型的PostgreSQL-TIME"><a href="#时区类型的PostgreSQL-TIME" class="headerlink" title="时区类型的PostgreSQL TIME"></a>时区类型的PostgreSQL TIME</h4><blockquote>
<p>除TIME数据类型外，PostgreSQL还为TIME提供了带时区的数据类型，使您可以存储和操作带时区的一天中的时间。</p>
</blockquote>
<blockquote>
<p>以下语句说明了如何声明具有时区的数据类型为TIME的列:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column TIME with time zone</span><br></pre></td></tr></table></figure>
<blockquote>
<p>带有时区数据类型的TIME的存储大小为12个字节，可以存储时区范围从00:00:00+1459到24:00:00-1459的时间值。</p>
</blockquote>
<blockquote>
<p>下面说明了带有时区值的TIME：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">04:05:06 PST    </span><br><span class="line">04:05:06.789-8</span><br></pre></td></tr></table></figure>
<h4 id="处理PostgreSQL-TIME值"><a href="#处理PostgreSQL-TIME值" class="headerlink" title="处理PostgreSQL TIME值"></a>处理PostgreSQL TIME值</h4><h5 id="获取当前时间-1"><a href="#获取当前时间-1" class="headerlink" title="获取当前时间"></a>获取当前时间</h5><blockquote>
<p>要获取具有时区的当前时间，请使用CURRENT_TIME函数，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT CURRENT_TIME;</span></span><br><span class="line">    current_time</span><br><span class="line">--------------------</span><br><span class="line"> 14:47:11.435945+08</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要以特定的精度获取当前时间，请使用CURRENT_TIME(precision)函数:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT CURRENT_TIME(5);</span></span><br><span class="line">   current_time</span><br><span class="line">-------------------</span><br><span class="line"> 14:49:53.25791+08</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，在未指定精度的情况下，CURRENT_TIME函数将返回具有完整可用精度的时间值。</p>
</blockquote>
<blockquote>
<p>要获取当地时间，请使用LOCALTIME函数：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT LOCALTIME;</span></span><br><span class="line">    localtime</span><br><span class="line">-----------------</span><br><span class="line"> 14:51:09.619903</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同样，要获取具有特定精度的本地时间，请使用LOCALTIME(precision)函数:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT LOCALTIME(0);</span></span><br><span class="line"> localtime</span><br><span class="line">-----------</span><br><span class="line"> 14:51:40</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h5 id="将时间转换为其他时区"><a href="#将时间转换为其他时区" class="headerlink" title="将时间转换为其他时区"></a>将时间转换为其他时区</h5><blockquote>
<p>要将时间转换为其他时区，请使用以下格式：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[TIME with time zone] AT TIME ZONE time_zone</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如，要将本地时间转换为UTC-8时区的时间，请使用以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT LOCALTIME AT TIME ZONE 'UTC-8';</span></span><br><span class="line">     timezone</span><br><span class="line">-------------------</span><br><span class="line"> 14:57:19.23764+08</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h5 id="从时间值中提取小时、分钟、秒"><a href="#从时间值中提取小时、分钟、秒" class="headerlink" title="从时间值中提取小时、分钟、秒"></a>从时间值中提取小时、分钟、秒</h5><blockquote>
<p>要从时间值中提取小时、分钟、秒，请使用EXTRACT功能：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXTRACT(field FROM time_value);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该字段可以是小时、分钟、秒、毫秒，如以下示例所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    LOCALTIME,</span><br><span class="line">    EXTRACT (HOUR FROM LOCALTIME) as hour,</span><br><span class="line">    EXTRACT (MINUTE FROM LOCALTIME) as minute,</span><br><span class="line">    EXTRACT (SECOND FROM LOCALTIME) as second,</span><br><span class="line">    EXTRACT (milliseconds FROM LOCALTIME) as milliseconds;</span><br><span class="line">    localtime    | hour | minute |  second   | milliseconds</span><br><span class="line">-----------------+------+--------+-----------+--------------</span><br><span class="line"> 15:06:19.365592 |   15 |      6 | 19.365592 |    19365.592</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h5 id="时间值的算术运算"><a href="#时间值的算术运算" class="headerlink" title="时间值的算术运算"></a>时间值的算术运算</h5><blockquote>
<p>PostgreSQL允许您对时间值以及时间和间隔值之间应用算术运算符，例如+，-和* 。</p>
</blockquote>
<blockquote>
<p>以下语句返回两个时间值之间的间隔：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT time '10:00' - time '02:00';</span></span><br><span class="line"> ?column?</span><br><span class="line">----------</span><br><span class="line"> PT8H</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下语句将本地时间增加了2个小时：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT LOCALTIME + interval '2 hours';</span></span><br><span class="line">    ?column?</span><br><span class="line">-----------------</span><br><span class="line"> 17:13:24.405449</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h3 id="UUID数据类型"><a href="#UUID数据类型" class="headerlink" title="UUID数据类型"></a>UUID数据类型</h3><blockquote>
<p>UUID代表由RFC 4122和其他相关标准定义的通用唯一标识符。UUID值是一种算法生成的128位数量，使用相同的算法在已知的Universe中使其唯一。下面显示了一些UUID值示例:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">40e6215d-b5c6-4896-987c-f30f3678f608</span><br><span class="line">6ecd8c99-4036-403d-bf84-cf8400f67836</span><br><span class="line">3f333df6-90a4-4fda-8dd3-9485d27cee36</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如您所见，UUID是由连字符分隔的组表示的32位十六进制数字的序列。</p>
</blockquote>
<blockquote>
<p>由于其唯一性功能，可以经常在分布式系统中找到UUID，因为它可以保证比SERIAL数据类型更好的唯一性，而SERIAL数据类型仅在单个数据库中生成唯一值。</p>
</blockquote>
<blockquote>
<p>要将UUID值存储在PostgreSQL数据库中，请使用UUID数据类型。</p>
</blockquote>
<h4 id="生成UUID值"><a href="#生成UUID值" class="headerlink" title="生成UUID值"></a>生成UUID值</h4><blockquote>
<p>PostgreSQL允许您存储和比较UUID值，但它不包含用于在其核心中生成UUID值的函数。相反，它依赖于提供特定算法以生成UUID的第三方模块。</p>
</blockquote>
<blockquote>
<p>例如，uuid-ossp模块提供了一些方便的功能，这些功能实现了用于生成UUID的标准算法。要安装uuid-ossp模块，请使用CREATE EXTENSION语句，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum -y install postgresql12-contrib</span></span><br><span class="line"><span class="comment"># psql -h 192.168.100.133 -U postgres</span></span><br><span class="line">用户 postgres 的口令：</span><br><span class="line">psql (12.1)</span><br><span class="line">输入 <span class="string">"help"</span> 来获取帮助信息.</span><br><span class="line"></span><br><span class="line">postgres=<span class="comment"># CREATE EXTENSION IF NOT EXISTS "uuid-ossp";</span></span><br><span class="line">CREATE EXTENSION</span><br></pre></td></tr></table></figure>
<ul>
<li>IF NOT EXISTS子句允许您避免重新安装模块。</li>
</ul>
<blockquote>
<p>要基于计算机的MAC地址、当前时间戳和随机值的组合生成UUID值，请使用uuid_generate_v1()函数：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT uuid_generate_v1();</span></span><br><span class="line">           uuid_generate_v1</span><br><span class="line">--------------------------------------</span><br><span class="line"> 3db0aed4-1420-11ea-85a4-000c2975eafe</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要仅基于随机数生成UUID值，则可以使用该uuid_generate_v4()函数:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT uuid_generate_v4();</span></span><br><span class="line">           uuid_generate_v4</span><br><span class="line">--------------------------------------</span><br><span class="line"> f5263124-b29c-4cab-85f9-d046d44e2405</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="使用UUID列创建表"><a href="#使用UUID列创建表" class="headerlink" title="使用UUID列创建表"></a>使用UUID列创建表</h4><ul>
<li>contact_id列的数据类型为UUID，其具有uuid_generate_v4()函数提供的默认值。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE TABLE contacts (</span></span><br><span class="line">    contact_id uuid DEFAULT uuid_generate_v4 (),</span><br><span class="line">    first_name VARCHAR NOT NULL,</span><br><span class="line">    last_name VARCHAR NOT NULL,</span><br><span class="line">    email VARCHAR NOT NULL,</span><br><span class="line">    phone VARCHAR,</span><br><span class="line">    PRIMARY KEY (contact_id)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<ul>
<li>插入数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># INSERT INTO contacts (</span></span><br><span class="line">    first_name,</span><br><span class="line">    last_name,</span><br><span class="line">    email,</span><br><span class="line">    phone</span><br><span class="line">)</span><br><span class="line">VALUES</span><br><span class="line">    (</span><br><span class="line">        <span class="string">'John'</span>,</span><br><span class="line">        <span class="string">'Smith'</span>,</span><br><span class="line">        <span class="string">'john@example.com'</span>,</span><br><span class="line">        <span class="string">'4082-2345'</span></span><br><span class="line">    ),</span><br><span class="line">    (</span><br><span class="line">        <span class="string">'Jane'</span>,</span><br><span class="line">        <span class="string">'Smith'</span>,</span><br><span class="line">        <span class="string">'jane@example.com'</span>,</span><br><span class="line">        <span class="string">'4082-2344'</span></span><br><span class="line">    ),</span><br><span class="line">    (</span><br><span class="line">        <span class="string">'Alex'</span>,</span><br><span class="line">        <span class="string">'Smith'</span>,</span><br><span class="line">        <span class="string">'alex@example.com'</span>,</span><br><span class="line">        <span class="string">'4037-2343'</span></span><br><span class="line">    );</span><br><span class="line">INSERT 0 3</span><br></pre></td></tr></table></figure>
<ul>
<li>进行查看</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    contacts;</span><br><span class="line">              contact_id              | first_name | last_name |      email       |   phone</span><br><span class="line">--------------------------------------+------------+-----------+------------------+-----------</span><br><span class="line"> 3fc6f6a9-2fb3-4c65-9465-576cf3bdb776 | John       | Smith     | john@example.com | 4082-2345</span><br><span class="line"> ec307779-360b-4ac3-a1b8-3ae9800cfae1 | Jane       | Smith     | jane@example.com | 4082-2344</span><br><span class="line"> be6cb08a-f185-4ac0-b900-0cea07c5b71b | Alex       | Smith     | alex@example.com | 4037-2343</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<h3 id="JSON数据类型"><a href="#JSON数据类型" class="headerlink" title="JSON数据类型"></a>JSON数据类型</h3><blockquote>
<p>JSON代表JavaScript对象符号。JSON是一种开放标准格式，由键值对组成。JSON的主要用途是在服务器和Web应用程序之间传输数据。</p>
</blockquote>
<blockquote>
<p>首先，创建一个用于练习JSON数据类型的新表。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE orders (</span></span><br><span class="line">   ID serial NOT NULL PRIMARY KEY,</span><br><span class="line">   info json NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该orders表由两列组成：</p>
<ul>
<li>id 列是标识订单的主键列。</li>
</ul>
<ul>
<li>info列以JSON形式存储数据。</li>
</ul>
</blockquote>
<h4 id="插入JSON数据"><a href="#插入JSON数据" class="headerlink" title="插入JSON数据"></a>插入JSON数据</h4><blockquote>
<p>要将数据插入JSON列，必须确保数据采用有效的JSON格式。以下INSERT语句在orders表中插入新行:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO orders (info)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'&#123; "customer": "Tom", "items": &#123;"product": "Beer","qty": 6&#125;&#125;'</span></span><br><span class="line">   );</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同时插入多行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO orders (info)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'&#123; "customer": "Lily", "items": &#123;"product": "TV","qty": 1&#125;&#125;'</span></span><br><span class="line">   ),</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'&#123; "customer": "William", "items": &#123;"product": "Toy Car","qty": 2&#125;&#125;'</span></span><br><span class="line">   ),</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'&#123; "customer": "Mary", "items": &#123;"product": "Toy Train","qty": 3&#125;&#125;'</span></span><br><span class="line">   );</span><br><span class="line">INSERT 0 3</span><br></pre></td></tr></table></figure>
<h4 id="查询JSON数据"><a href="#查询JSON数据" class="headerlink" title="查询JSON数据"></a>查询JSON数据</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   info</span><br><span class="line">FROM</span><br><span class="line">   orders;</span><br><span class="line">                                info</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line"> &#123; <span class="string">"customer"</span>: <span class="string">"Tom"</span>, <span class="string">"items"</span>: &#123;<span class="string">"product"</span>: <span class="string">"Beer"</span>,<span class="string">"qty"</span>: 6&#125;&#125;</span><br><span class="line"> &#123; <span class="string">"customer"</span>: <span class="string">"Lily"</span>, <span class="string">"items"</span>: &#123;<span class="string">"product"</span>: <span class="string">"TV"</span>,<span class="string">"qty"</span>: 1&#125;&#125;</span><br><span class="line"> &#123; <span class="string">"customer"</span>: <span class="string">"William"</span>, <span class="string">"items"</span>: &#123;<span class="string">"product"</span>: <span class="string">"Toy Car"</span>,<span class="string">"qty"</span>: 2&#125;&#125;</span><br><span class="line"> &#123; <span class="string">"customer"</span>: <span class="string">"Mary"</span>, <span class="string">"items"</span>: &#123;<span class="string">"product"</span>: <span class="string">"Toy Train"</span>,<span class="string">"qty"</span>: 3&#125;&#125;</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PostgreSQL以JSON的形式返回结果集。</p>
</blockquote>
<blockquote>
<p>PostgreSQL提供了两个本机运算符-&gt;和-&gt;&gt;来帮助您查询JSON数据:</p>
<ul>
<li>运算符-&gt;按键返回JSON对象字段。</li>
</ul>
<ul>
<li>运算符-&gt;&gt;按文本返回JSON对象字段。</li>
</ul>
</blockquote>
<blockquote>
<p>以下查询使用运算符-&gt;以JSON形式获取所有客户:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   info -&gt; <span class="string">'customer'</span> AS customer</span><br><span class="line">FROM</span><br><span class="line">   orders;</span><br><span class="line"> customer</span><br><span class="line">-----------</span><br><span class="line"> <span class="string">"Tom"</span></span><br><span class="line"> <span class="string">"Lily"</span></span><br><span class="line"> <span class="string">"William"</span></span><br><span class="line"> <span class="string">"Mary"</span></span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下查询使用运算符-&gt;&gt;以文本形式获取所有客户:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   info -&gt;&gt; <span class="string">'customer'</span> AS customer</span><br><span class="line">FROM</span><br><span class="line">   orders;</span><br><span class="line"> customer</span><br><span class="line">----------</span><br><span class="line"> Tom</span><br><span class="line"> Lily</span><br><span class="line"> William</span><br><span class="line"> Mary</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于-&gt;运算符返回JSON对象，因此可以将其与运算符-&gt;&gt;链接以检索特定节点。例如，以下语句返回所有出售的产品：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   info -&gt; <span class="string">'items'</span> -&gt;&gt; <span class="string">'product'</span> as product</span><br><span class="line">FROM</span><br><span class="line">   orders</span><br><span class="line">ORDER BY</span><br><span class="line">   product;</span><br><span class="line">  product</span><br><span class="line">-----------</span><br><span class="line"> Beer</span><br><span class="line"> Toy Car</span><br><span class="line"> Toy Train</span><br><span class="line"> TV</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个信息-&gt;’items’将项目作为JSON对象返回。然后info-&gt;’items’-&gt;&gt;’product’以文本形式返回所有产品。</li>
</ul>
<h4 id="在WHERE子句中使用JSON运算符"><a href="#在WHERE子句中使用JSON运算符" class="headerlink" title="在WHERE子句中使用JSON运算符"></a>在WHERE子句中使用JSON运算符</h4><blockquote>
<p>可以在WHERE子句中使用JSON运算符来过滤返回的行。例如，要查找谁购买了TV，我们使用以下查询:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   info -&gt;&gt; <span class="string">'customer'</span> AS customer</span><br><span class="line">FROM</span><br><span class="line">   orders</span><br><span class="line">WHERE</span><br><span class="line">   info -&gt; <span class="string">'items'</span> -&gt;&gt; <span class="string">'product'</span> = <span class="string">'TV'</span>;</span><br><span class="line"> customer</span><br><span class="line">----------</span><br><span class="line"> Lily</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了找出谁一次购买了两种产品，使用以下查询：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   info -&gt;&gt; <span class="string">'customer'</span> AS customer,</span><br><span class="line">   info -&gt; <span class="string">'items'</span> -&gt;&gt; <span class="string">'product'</span> AS product</span><br><span class="line">FROM</span><br><span class="line">   orders</span><br><span class="line">WHERE</span><br><span class="line">   CAST (</span><br><span class="line">      info -&gt; <span class="string">'items'</span> -&gt;&gt; <span class="string">'qty'</span> AS INTEGER</span><br><span class="line">   ) = 2;</span><br><span class="line"> customer | product</span><br><span class="line">----------+---------</span><br><span class="line"> William  | Toy Car</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，我们使用类型转换将qty字段转换为INTEGER类型并将其与两个进行比较。</p>
</blockquote>
<h4 id="将聚合函数应用于JSON数据"><a href="#将聚合函数应用于JSON数据" class="headerlink" title="将聚合函数应用于JSON数据"></a>将聚合函数应用于JSON数据</h4><blockquote>
<p>将聚合函数（例如MIN，MAX，AVERAGE，SUM等）应用于JSON数据。例如，以下语句返回最小数量，最大数量，平均数量和所售产品的总数量。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   MIN (</span><br><span class="line">      CAST (</span><br><span class="line">         info -&gt; <span class="string">'items'</span> -&gt;&gt; <span class="string">'qty'</span> AS INTEGER</span><br><span class="line">      )</span><br><span class="line">   ),</span><br><span class="line">   MAX (</span><br><span class="line">      CAST (</span><br><span class="line">         info -&gt; <span class="string">'items'</span> -&gt;&gt; <span class="string">'qty'</span> AS INTEGER</span><br><span class="line">      )</span><br><span class="line">   ),</span><br><span class="line">   SUM (</span><br><span class="line">      CAST (</span><br><span class="line">         info -&gt; <span class="string">'items'</span> -&gt;&gt; <span class="string">'qty'</span> AS INTEGER</span><br><span class="line">      )</span><br><span class="line">   ),</span><br><span class="line">   AVG (</span><br><span class="line">      CAST (</span><br><span class="line">         info -&gt; <span class="string">'items'</span> -&gt;&gt; <span class="string">'qty'</span> AS INTEGER</span><br><span class="line">      )</span><br><span class="line">   )</span><br><span class="line"> </span><br><span class="line">FROM</span><br><span class="line">   orders;</span><br><span class="line"> min | max | sum |        avg</span><br><span class="line">-----+-----+-----+--------------------</span><br><span class="line">   1 |   6 |  12 | 3.0000000000000000</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="JSON函数"><a href="#JSON函数" class="headerlink" title="JSON函数"></a>JSON函数</h4><h5 id="json-each函数"><a href="#json-each函数" class="headerlink" title="json_each函数"></a>json_each函数</h5><blockquote>
<p>json_each()函数允许我们将最外面的JSON对象扩展为一组键值对。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   json_each (info)</span><br><span class="line">FROM</span><br><span class="line">   orders;</span><br><span class="line">                     json_each</span><br><span class="line">---------------------------------------------------</span><br><span class="line"> (customer,<span class="string">""</span><span class="string">"Tom"</span><span class="string">""</span>)</span><br><span class="line"> (items,<span class="string">"&#123;"</span><span class="string">"product"</span><span class="string">": "</span><span class="string">"Beer"</span><span class="string">","</span><span class="string">"qty"</span><span class="string">": 6&#125;"</span>)</span><br><span class="line"> (customer,<span class="string">""</span><span class="string">"Lily"</span><span class="string">""</span>)</span><br><span class="line"> (items,<span class="string">"&#123;"</span><span class="string">"product"</span><span class="string">": "</span><span class="string">"TV"</span><span class="string">","</span><span class="string">"qty"</span><span class="string">": 1&#125;"</span>)</span><br><span class="line"> (customer,<span class="string">""</span><span class="string">"William"</span><span class="string">""</span>)</span><br><span class="line"> (items,<span class="string">"&#123;"</span><span class="string">"product"</span><span class="string">": "</span><span class="string">"Toy Car"</span><span class="string">","</span><span class="string">"qty"</span><span class="string">": 2&#125;"</span>)</span><br><span class="line"> (customer,<span class="string">""</span><span class="string">"Mary"</span><span class="string">""</span>)</span><br><span class="line"> (items,<span class="string">"&#123;"</span><span class="string">"product"</span><span class="string">": "</span><span class="string">"Toy Train"</span><span class="string">","</span><span class="string">"qty"</span><span class="string">": 3&#125;"</span>)</span><br><span class="line">(8 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要获取一组键值对作为文本，请改用json_each_text()函数。</p>
</blockquote>
<h5 id="json-object-keys函数"><a href="#json-object-keys函数" class="headerlink" title="json_object_keys函数"></a>json_object_keys函数</h5><blockquote>
<p>要在最外层JSON对象中获取一组键，请使用json_object_keys()函数。以下查询返回列中嵌套items对象的所有键info:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   json_object_keys (info-&gt;<span class="string">'items'</span>)</span><br><span class="line">FROM</span><br><span class="line">   orders;</span><br><span class="line"> json_object_keys</span><br><span class="line">------------------</span><br><span class="line"> product</span><br><span class="line"> qty</span><br><span class="line"> product</span><br><span class="line"> qty</span><br><span class="line"> product</span><br><span class="line"> qty</span><br><span class="line"> product</span><br><span class="line"> qty</span><br><span class="line">(8 rows)</span><br></pre></td></tr></table></figure>
<h5 id="json-typeof函数"><a href="#json-typeof函数" class="headerlink" title="json_typeof函数"></a>json_typeof函数</h5><blockquote>
<p>json_typeof()函数以字符串形式返回最外面的JSON值的类型。可以是number，boolean，null，object，array和string。</p>
</blockquote>
<blockquote>
<p>以下查询返回项目的数据类型：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   json_typeof (info-&gt;<span class="string">'items'</span>)</span><br><span class="line">FROM</span><br><span class="line">   orders;</span><br><span class="line"> json_typeof</span><br><span class="line">-------------</span><br><span class="line"> object</span><br><span class="line"> object</span><br><span class="line"> object</span><br><span class="line"> object</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下查询返回嵌套项目JSON对象的qty字段的数据类型:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   json_typeof (info-&gt;<span class="string">'items'</span>-&gt;<span class="string">'qty'</span>)</span><br><span class="line">FROM</span><br><span class="line">   orders;</span><br><span class="line"> json_typeof</span><br><span class="line">-------------</span><br><span class="line"> number</span><br><span class="line"> number</span><br><span class="line"> number</span><br><span class="line"> number</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>
<h3 id="hstore数据类型"><a href="#hstore数据类型" class="headerlink" title="hstore数据类型"></a>hstore数据类型</h3><blockquote>
<p>hstore模块实现了用于将键值对存储为单个值的hstore数据类型。hstore数据类型在许多情况下非常有用，例如半结构化数据或具有很少查询的许多属性的行。请注意，键和值仅是文本字符串。</p>
</blockquote>
<h4 id="启用hstore扩展"><a href="#启用hstore扩展" class="headerlink" title="启用hstore扩展"></a>启用hstore扩展</h4><blockquote>
<p>在使用hstore数据类型之前，需要启用hstore扩展，以将contrib模块加载到PostgreSQL实例。</p>
</blockquote>
<h4 id="创建具有hstore数据类型的表"><a href="#创建具有hstore数据类型的表" class="headerlink" title="创建具有hstore数据类型的表"></a>创建具有hstore数据类型的表</h4><blockquote>
<p>创建一个表books ，该表具有三列：</p>
<ul>
<li>id 是识别书籍的主键。</li>
</ul>
<ul>
<li>title 是产品的标题</li>
</ul>
<ul>
<li>attr 存储书籍的属性，例如ISBN，重量和平装本。attr列的数据类型为hstore。</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE TABLE books (</span></span><br><span class="line">   id serial primary key,</span><br><span class="line">   title VARCHAR (255),</span><br><span class="line">   attr hstore</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<h4 id="将数据插入hstore列"><a href="#将数据插入hstore列" class="headerlink" title="将数据插入hstore列"></a>将数据插入hstore列</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># INSERT INTO books (title, attr)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'PostgreSQL'</span>,</span><br><span class="line">      <span class="string">'"paperback" =&gt; "243",</span></span><br><span class="line"><span class="string">      "publisher" =&gt; "postgresql.org",</span></span><br><span class="line"><span class="string">      "language"  =&gt; "English",</span></span><br><span class="line"><span class="string">      "ISBN-13"   =&gt; "978-1449370000",</span></span><br><span class="line"><span class="string">       "weight"    =&gt; "11.2 ounces"'</span></span><br><span class="line">   );</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>插入到hstore列中的数据是用逗号分隔的key =&gt; value对的列表。键和值都用双引号（“”）引起来。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># INSERT INTO books (title, attr)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'PostgreSQL'</span>,</span><br><span class="line">      <span class="string">'</span></span><br><span class="line"><span class="string">"paperback" =&gt; "5",</span></span><br><span class="line"><span class="string">"publisher" =&gt; "postgresql.org",</span></span><br><span class="line"><span class="string">"language"  =&gt; "English",</span></span><br><span class="line"><span class="string">"ISBN-13"   =&gt; "978-1449370001",</span></span><br><span class="line"><span class="string">"weight"    =&gt; "1 ounces"'</span></span><br><span class="line">   );</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<h4 id="从hstore列查询数据"><a href="#从hstore列查询数据" class="headerlink" title="从hstore列查询数据"></a>从hstore列查询数据</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   attr</span><br><span class="line">FROM</span><br><span class="line">   books;</span><br><span class="line">                                                              attr</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> <span class="string">"weight"</span>=&gt;<span class="string">"11.2 ounces"</span>, <span class="string">"ISBN-13"</span>=&gt;<span class="string">"978-1449370000"</span>, <span class="string">"language"</span>=&gt;<span class="string">"English"</span>, <span class="string">"paperback"</span>=&gt;<span class="string">"243"</span>, <span class="string">"publisher"</span>=&gt;<span class="string">"postgresql.org"</span></span><br><span class="line"> <span class="string">"weight"</span>=&gt;<span class="string">"1 ounces"</span>, <span class="string">"ISBN-13"</span>=&gt;<span class="string">"978-1449370001"</span>, <span class="string">"language"</span>=&gt;<span class="string">"English"</span>, <span class="string">"paperback"</span>=&gt;<span class="string">"5"</span>, <span class="string">"publisher"</span>=&gt;<span class="string">"postgresql.org"</span></span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h4 id="查询特定键的值"><a href="#查询特定键的值" class="headerlink" title="查询特定键的值"></a>查询特定键的值</h4><blockquote>
<p>PostgreSQL hstore提供了-&gt;运算符，可从hstore列中查询特定键的值。例如，如果我们想知道books表中所有可用书籍的ISBN-13，则可以使用-&gt;运算符，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   attr -&gt; <span class="string">'ISBN-13'</span> AS isbn</span><br><span class="line">FROM</span><br><span class="line">   books;</span><br><span class="line">      isbn</span><br><span class="line">----------------</span><br><span class="line"> 978-1449370000</span><br><span class="line"> 978-1449370001</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h4 id="在WHERE子句中使用值"><a href="#在WHERE子句中使用值" class="headerlink" title="在WHERE子句中使用值"></a>在WHERE子句中使用值</h4><blockquote>
<p>可以在WHERE子句中使用-&gt;运算符来过滤其hstore列的值与输入值匹配的行。例如，查询检索ISBN-13值匹配978-1449370000的书的书名和重量：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   attr -&gt; <span class="string">'weight'</span> AS weight</span><br><span class="line">FROM</span><br><span class="line">   books</span><br><span class="line">WHERE</span><br><span class="line">   attr -&gt; <span class="string">'ISBN-13'</span> = <span class="string">'978-1449370000'</span>;</span><br><span class="line">   weight</span><br><span class="line">-------------</span><br><span class="line"> 11.2 ounces</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="将键值对添加到现有行"><a href="#将键值对添加到现有行" class="headerlink" title="将键值对添加到现有行"></a>将键值对添加到现有行</h4><blockquote>
<p>使用hstore列，可以轻松地将新的键值对添加到现有行。例如，可以将免费送货键添加到books表的attr列，如下所示:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># UPDATE books</span></span><br><span class="line">SET attr = attr || <span class="string">'"freeshipping"=&gt;"yes"'</span> :: hstore;</span><br><span class="line">UPDATE 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在，可以检查“freeshipping” =&gt;“yes”对是否已成功添加:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   title,</span><br><span class="line">        attr -&gt; <span class="string">'freeshipping'</span> AS freeshipping</span><br><span class="line">FROM</span><br><span class="line">   books;</span><br><span class="line">   title    | freeshipping</span><br><span class="line">------------+--------------</span><br><span class="line"> PostgreSQL | yes</span><br><span class="line"> PostgreSQL | yes</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h4 id="更新现有的键值对"><a href="#更新现有的键值对" class="headerlink" title="更新现有的键值对"></a>更新现有的键值对</h4><blockquote>
<p>可以使用UPDATE语句更新现有的键值对。以下语句将“freeshipping”键的值更新为“no”:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># UPDATE books</span></span><br><span class="line">SET attr = attr || <span class="string">'"freeshipping"=&gt;"no"'</span> :: hstore;</span><br><span class="line">UPDATE 2</span><br></pre></td></tr></table></figure>
<h4 id="删除现有的键值对"><a href="#删除现有的键值对" class="headerlink" title="删除现有的键值对"></a>删除现有的键值对</h4><blockquote>
<p>PostgreSQL允许从hstore列中删除现有的键/值对。以下语句删除attr列中的“freeshipping” =&gt;“ no”键值对:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># UPDATE books</span></span><br><span class="line">SET attr = delete(attr, <span class="string">'freeshipping'</span>);</span><br><span class="line">UPDATE 2</span><br></pre></td></tr></table></figure>
<h4 id="检查hstore列中的特定键"><a href="#检查hstore列中的特定键" class="headerlink" title="检查hstore列中的特定键"></a>检查hstore列中的特定键</h4><blockquote>
<p>可以使用？检查hstore列中的特定键，WHERE子句中的运算符。以下语句返回所有包含attr包含密钥发布者的行：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">  title,</span><br><span class="line">  attr-&gt;<span class="string">'publisher'</span> as publisher,</span><br><span class="line">  attr</span><br><span class="line">FROM</span><br><span class="line">   books</span><br><span class="line">WHERE</span><br><span class="line">   attr ? <span class="string">'publisher'</span>;</span><br><span class="line">   title    |   publisher    |                                                              attr</span><br><span class="line">------------+----------------+--------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> PostgreSQL | postgresql.org | <span class="string">"weight"</span>=&gt;<span class="string">"11.2 ounces"</span>, <span class="string">"ISBN-13"</span>=&gt;<span class="string">"978-1449370000"</span>, <span class="string">"language"</span>=&gt;<span class="string">"English"</span>, <span class="string">"paperback"</span>=&gt;<span class="string">"243"</span>, <span class="string">"publisher"</span>=&gt;<span class="string">"postgresql.org"</span></span><br><span class="line"> PostgreSQL | postgresql.org | <span class="string">"weight"</span>=&gt;<span class="string">"1 ounces"</span>, <span class="string">"ISBN-13"</span>=&gt;<span class="string">"978-1449370001"</span>, <span class="string">"language"</span>=&gt;<span class="string">"English"</span>, <span class="string">"paperback"</span>=&gt;<span class="string">"5"</span>, <span class="string">"publisher"</span>=&gt;<span class="string">"postgresql.org"</span></span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h4 id="检查键值对"><a href="#检查键值对" class="headerlink" title="检查键值对"></a>检查键值对</h4><blockquote>
<p>可以使用@&gt;运算符基于hstore键值对进行查询。以下语句检索attr列包含匹配“重量” =&gt;“ 11.2盎司”的键值对的所有行:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   title</span><br><span class="line">FROM</span><br><span class="line">   books</span><br><span class="line">WHERE</span><br><span class="line">   attr @&gt; <span class="string">'"weight"=&gt;"11.2 ounces"'</span> :: hstore;</span><br><span class="line">   title</span><br><span class="line">------------</span><br><span class="line"> PostgreSQL</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="查询包含多个指定键的行"><a href="#查询包含多个指定键的行" class="headerlink" title="查询包含多个指定键的行"></a>查询包含多个指定键的行</h4><blockquote>
<p>可以使用？＆运算符查询其hstore列包含多个键的行。可以在attr列中同时包含语言键和重量键的书籍:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   title</span><br><span class="line">FROM</span><br><span class="line">   books</span><br><span class="line">WHERE</span><br><span class="line">   attr ?&amp; ARRAY [ <span class="string">'language'</span>, <span class="string">'weight'</span> ];</span><br><span class="line">   title</span><br><span class="line">------------</span><br><span class="line"> PostgreSQL</span><br><span class="line"> PostgreSQL</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要检查其hstore列中的行是否包含键列表中的任何键，请使用？|运算符，而不是？＆运算符。</p>
</blockquote>
<h4 id="从hstore列获取所有密钥"><a href="#从hstore列获取所有密钥" class="headerlink" title="从hstore列获取所有密钥"></a>从hstore列获取所有密钥</h4><blockquote>
<p>要从hstore列获取所有密钥，请使用akeys()函数，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   akeys (attr)</span><br><span class="line">FROM</span><br><span class="line">   books;</span><br><span class="line">                     akeys</span><br><span class="line">-----------------------------------------------</span><br><span class="line"> &#123;weight,ISBN-13,language,paperback,publisher&#125;</span><br><span class="line"> &#123;weight,ISBN-13,language,paperback,publisher&#125;</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者，如果希望PostgreSQL将结果作为集合返回，则可以使用skey()函数。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   skeys (attr)</span><br><span class="line">FROM</span><br><span class="line">   books;</span><br><span class="line">   skeys</span><br><span class="line">-----------</span><br><span class="line"> weight</span><br><span class="line"> ISBN-13</span><br><span class="line"> language</span><br><span class="line"> paperback</span><br><span class="line"> publisher</span><br><span class="line"> weight</span><br><span class="line"> ISBN-13</span><br><span class="line"> language</span><br><span class="line"> paperback</span><br><span class="line"> publisher</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>
<h4 id="从hstore列获取所有值"><a href="#从hstore列获取所有值" class="headerlink" title="从hstore列获取所有值"></a>从hstore列获取所有值</h4><blockquote>
<p>像键一样，可以使用avals()函数以数组的形式从hstore列中获取所有值。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   avals (attr)</span><br><span class="line">FROM</span><br><span class="line">   books;</span><br><span class="line">                           avals</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"> &#123;<span class="string">"11.2 ounces"</span>,978-1449370000,English,243,postgresql.org&#125;</span><br><span class="line"> &#123;<span class="string">"1 ounces"</span>,978-1449370001,English,5,postgresql.org&#125;</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者，如果想将结果作为一个集合，则可以使用svals()函数。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   svals (attr)</span><br><span class="line">FROM</span><br><span class="line">   books;</span><br><span class="line">     svals</span><br><span class="line">----------------</span><br><span class="line"> 11.2 ounces</span><br><span class="line"> 978-1449370000</span><br><span class="line"> English</span><br><span class="line"> 243</span><br><span class="line"> postgresql.org</span><br><span class="line"> 1 ounces</span><br><span class="line"> 978-1449370001</span><br><span class="line"> English</span><br><span class="line"> 5</span><br><span class="line"> postgresql.org</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>
<h4 id="将Hstore数据转换为JSON"><a href="#将Hstore数据转换为JSON" class="headerlink" title="将Hstore数据转换为JSON"></a>将Hstore数据转换为JSON</h4><blockquote>
<p>PostgreSQL提供hstore_to_json()函数将hstore数据转换为JSON。请参阅以下语句：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">  title,</span><br><span class="line">  hstore_to_json (attr) json</span><br><span class="line">FROM</span><br><span class="line">  books;</span><br><span class="line">   title    |                                                               json</span><br><span class="line">------------+----------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> PostgreSQL | &#123;<span class="string">"weight"</span>: <span class="string">"11.2 ounces"</span>, <span class="string">"ISBN-13"</span>: <span class="string">"978-1449370000"</span>, <span class="string">"language"</span>: <span class="string">"English"</span>, <span class="string">"paperback"</span>: <span class="string">"243"</span>, <span class="string">"publisher"</span>: <span class="string">"postgresql.org"</span>&#125;</span><br><span class="line"> PostgreSQL | &#123;<span class="string">"weight"</span>: <span class="string">"1 ounces"</span>, <span class="string">"ISBN-13"</span>: <span class="string">"978-1449370001"</span>, <span class="string">"language"</span>: <span class="string">"English"</span>, <span class="string">"paperback"</span>: <span class="string">"5"</span>, <span class="string">"publisher"</span>: <span class="string">"postgresql.org"</span>&#125;</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>
<h4 id="将Hstore数据转换为集合"><a href="#将Hstore数据转换为集合" class="headerlink" title="将Hstore数据转换为集合"></a>将Hstore数据转换为集合</h4><blockquote>
<p>要将hstore数据转换为集合，请使用each()函数，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT</span></span><br><span class="line">   title,</span><br><span class="line">   (EACH(attr) ).*</span><br><span class="line">FROM</span><br><span class="line">   books;</span><br><span class="line">   title    |    key    |     value</span><br><span class="line">------------+-----------+----------------</span><br><span class="line"> PostgreSQL | weight    | 11.2 ounces</span><br><span class="line"> PostgreSQL | ISBN-13   | 978-1449370000</span><br><span class="line"> PostgreSQL | language  | English</span><br><span class="line"> PostgreSQL | paperback | 243</span><br><span class="line"> PostgreSQL | publisher | postgresql.org</span><br><span class="line"> PostgreSQL | weight    | 1 ounces</span><br><span class="line"> PostgreSQL | ISBN-13   | 978-1449370001</span><br><span class="line"> PostgreSQL | language  | English</span><br><span class="line"> PostgreSQL | paperback | 5</span><br><span class="line"> PostgreSQL | publisher | postgresql.org</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>
<h3 id="PostgreSQL数组"><a href="#PostgreSQL数组" class="headerlink" title="PostgreSQL数组"></a>PostgreSQL数组</h3><blockquote>
<p>数组在PostgreSQL中扮演重要角色。每个数据类型都有自己的伴随数组类型，例如integer具有integer []数组类型，character具有character[]数组类型等。如果定义了自己的数据类型，PostgreSQL会在后台为您创建一个对应的数组类型。PostgreSQL允许您将列定义为任何有效数据类型的数组，包括内置类型，用户定义类型或枚举类型。</p>
</blockquote>
<blockquote>
<p>下面的CREATE TABLE语句创建具有phones列的表，该列定义为文本数组:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE test15 (</span></span><br><span class="line">   id serial PRIMARY KEY,</span><br><span class="line">   name VARCHAR (100),</span><br><span class="line">   phones TEXT []</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该phones列是一维数组，其中包含联系人可能拥有的各种电话号码。</p>
</blockquote>
<h4 id="插入PostgreSQL数组值"><a href="#插入PostgreSQL数组值" class="headerlink" title="插入PostgreSQL数组值"></a>插入PostgreSQL数组值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test15 (name, phones)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'John'</span>,</span><br><span class="line">      ARRAY [ <span class="string">'(408)-589-5846'</span>,</span><br><span class="line">      <span class="string">'(408)-589-5555'</span> ]</span><br><span class="line">   );</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用ARRAY构造函数构造一个数组并将其插入表中。还可以如下使用花括号：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO test15 (name, phones)</span></span><br><span class="line">VALUES</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'Lily'</span>,</span><br><span class="line">      <span class="string">'&#123;"(408)-589-5841"&#125;'</span></span><br><span class="line">   ),</span><br><span class="line">   (</span><br><span class="line">      <span class="string">'William'</span>,</span><br><span class="line">      <span class="string">'&#123;"(408)-589-5842","(408)-589-58423"&#125;'</span></span><br><span class="line">   );</span><br><span class="line">INSERT 0 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，当使用花括号时，可以使用单引号’将数组包装，将双引号”包裹文本数组项目。</p>
</blockquote>
<h4 id="查询数组数据"><a href="#查询数组数据" class="headerlink" title="查询数组数据"></a>查询数组数据</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   name,</span><br><span class="line">   phones</span><br><span class="line">FROM</span><br><span class="line">   test15;</span><br><span class="line">   name   |              phones</span><br><span class="line">----------+----------------------------------</span><br><span class="line"> John     | &#123;(408)-589-5846,(408)-589-5555&#125;</span><br><span class="line"> Lily     | &#123;(408)-589-5841&#125;</span><br><span class="line"> William  | &#123;(408)-589-5842,(408)-589-58423&#125;</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们使用方括号[]中的下标访问数组元素。默认情况下，PostgreSQL对数组元素使用基于1的编号。这意味着第一个数组元素以数字1开头。假设要获取联系人的姓名和第一个电话号码，我们使用以下查询：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   name,</span><br><span class="line">   phones [ 1 ]</span><br><span class="line">FROM</span><br><span class="line">   test15;</span><br><span class="line">   name   |     phones</span><br><span class="line">----------+----------------</span><br><span class="line"> John     | (408)-589-5846</span><br><span class="line"> Lily     | (408)-589-5841</span><br><span class="line"> William  | (408)-589-5842</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用WHERE子句中的数组元素作为过滤行的条件。例如，要找出谁拥有该电话号码(408)-589-58423 作为第二电话号码，使用以下查询:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   name</span><br><span class="line">FROM</span><br><span class="line">   test15</span><br><span class="line">WHERE</span><br><span class="line">   phones [ 2 ] = <span class="string">'(408)-589-58423'</span>;</span><br><span class="line">  name</span><br><span class="line">---------</span><br><span class="line"> William</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="修改PostgreSQL数组"><a href="#修改PostgreSQL数组" class="headerlink" title="修改PostgreSQL数组"></a>修改PostgreSQL数组</h4><blockquote>
<p>PostgreSQL允许更新数组的每个元素或整个数组。以下语句更新William的第二个电话号码:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># UPDATE test15</span></span><br><span class="line">SET phones [ 2 ] = <span class="string">'(408)-589-5843'</span></span><br><span class="line">WHERE</span><br><span class="line">   ID = 3;</span><br><span class="line">UPDATE 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   name,</span><br><span class="line">   phones</span><br><span class="line">FROM</span><br><span class="line">   test15</span><br><span class="line">WHERE</span><br><span class="line">   id = 3;</span><br><span class="line">  name   |             phones</span><br><span class="line">---------+---------------------------------</span><br><span class="line"> William | &#123;(408)-589-5842,(408)-589-5843&#125;</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="在PostgreSQL数组中搜索"><a href="#在PostgreSQL数组中搜索" class="headerlink" title="在PostgreSQL数组中搜索"></a>在PostgreSQL数组中搜索</h4><blockquote>
<p>假设我们想知道谁拥有电话号码(408)-589-5555而不管电话号码在phones数组中的位置如何，我们使用ANY()函数:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   name,</span><br><span class="line">   phones</span><br><span class="line">FROM</span><br><span class="line">   test15</span><br><span class="line">WHERE</span><br><span class="line">   <span class="string">'(408)-589-5555'</span> = ANY (phones);</span><br><span class="line">   name   |             phones</span><br><span class="line">----------+---------------------------------</span><br><span class="line"> John     | &#123;(408)-589-5846,(408)-589-5555&#125;</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h3 id="展开阵列"><a href="#展开阵列" class="headerlink" title="展开阵列"></a>展开阵列</h3><blockquote>
<p>PostgreSQL提供了unnest()将数组扩展为行列表的功能。以下查询扩展该phones数组的所有电话号码:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">   name,</span><br><span class="line">   unnest(phones)</span><br><span class="line">FROM</span><br><span class="line">   test15;</span><br><span class="line">   name   |     unnest</span><br><span class="line">----------+----------------</span><br><span class="line"> John     | (408)-589-5846</span><br><span class="line"> John     | (408)-589-5555</span><br><span class="line"> Lily     | (408)-589-5841</span><br><span class="line"> William  | (408)-589-5842</span><br><span class="line"> William  | (408)-589-5843</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure>
<h3 id="用户定义的数据类型"><a href="#用户定义的数据类型" class="headerlink" title="用户定义的数据类型"></a>用户定义的数据类型</h3><blockquote>
<p>除内置数据类型外，PostgreSQL还允许您通过以下语句创建用户定义的数据类型：</p>
<ul>
<li>CREATE DOMAIN创建具有约束的用户定义数据类型，例如NOT NULL，CHECK等。</li>
</ul>
<ul>
<li>CREATE TYPE通常用于创建在存储过程中用作返回数据类型的复合类型。</li>
</ul>
</blockquote>
<h4 id="创建域"><a href="#创建域" class="headerlink" title="创建域"></a>创建域</h4><blockquote>
<p>在PostgreSQL中，域是具有可选约束的数据类型，如NOT NULL，CHECK等。域在模式范围内具有唯一名称。</p>
</blockquote>
<blockquote>
<p>域对于集中管理具有公共约束的字段很有用。例如，某些表可能包含要求CHECK约束以确保值不为null且不包含空格的文本列。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE mail_list (</span></span><br><span class="line">    ID SERIAL PRIMARY KEY,</span><br><span class="line">    first_name VARCHAR NOT NULL,</span><br><span class="line">    last_name VARCHAR NOT NULL,</span><br><span class="line">    email VARCHAR NOT NULL,</span><br><span class="line">    CHECK (</span><br><span class="line">        first_name !~ <span class="string">'\s'</span></span><br><span class="line">        AND last_name !~ <span class="string">'\s'</span></span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>first_name和last_name列都不为null，并且不应包含空格。为了简化管理，contact_name可以按以下方式创建域：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE DOMAIN contact_name AS</span></span><br><span class="line">    VARCHAR NOT NULL CHECK (value !~ <span class="string">'\s'</span>);</span><br><span class="line">CREATE DOMAIN</span><br></pre></td></tr></table></figure>
<blockquote>
<p>并使用contact_name作为first_name和last_name列的数据类型：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># drop table mail_list;</span></span><br><span class="line">DROP TABLE</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TABLE mail_list (</span></span><br><span class="line">    id serial PRIMARY KEY,</span><br><span class="line">    first_name contact_name,</span><br><span class="line">    last_name contact_name,</span><br><span class="line">    email VARCHAR NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在mail_list表中插入新行:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># INSERT INTO mail_list (first_name, last_name, email)</span></span><br><span class="line">VALUES</span><br><span class="line">    (</span><br><span class="line">        <span class="string">'James V'</span>,</span><br><span class="line">        <span class="string">'Harden'</span>,</span><br><span class="line">        <span class="string">'james@example.com'</span></span><br><span class="line">    );</span><br><span class="line">错误:  域 contact_name 的值违反了检查约束 <span class="string">"contact_name_check"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>要更改或删除域，请分别使用ALTER DOMAIN或DROP DOMAIN。要查看当前数据库中的所有域，请使用\dD命令：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">test</span>=&gt; \dD</span><br><span class="line">                                                    共同值域列表</span><br><span class="line"> 架构模式 |     名称     |       类型        | 校对规则 |  可空的  | 预设 |                  检查                   </span><br><span class="line">----------+--------------+-------------------+----------+----------+------+-----------------------------------------</span><br><span class="line"> public   | contact_name | character varying |          | not null |      | CHECK (VALUE::text !~ <span class="string">'\s'</span>::text)</span><br><span class="line"> public   | year         | <span class="built_in">integer</span>           |          |          |      | CHECK (VALUE &gt;= 1901 AND VALUE &lt;= 2155)</span><br><span class="line">(2 行记录)</span><br></pre></td></tr></table></figure>
<h4 id="创建类型"><a href="#创建类型" class="headerlink" title="创建类型"></a>创建类型</h4><blockquote>
<p>CREATE TYPE语句允许您创建一个复合类型，该复合类型可用作函数的返回类型。</p>
</blockquote>
<blockquote>
<p>假设想要一个返回多个值的函数：film_id，title和release_year。 第一步是创建一个类型，例如film_summary，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE TYPE film_summary AS (</span></span><br><span class="line">    film_id INT,</span><br><span class="line">    title VARCHAR,</span><br><span class="line">    release_year YEAR</span><br><span class="line">);</span><br><span class="line">CREATE TYPE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其次，使用film_summary数据类型作为函数的返回类型：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># CREATE OR REPLACE FUNCTION get_film_summary (f_id INT)</span></span><br><span class="line">    RETURNS film_summary AS</span><br><span class="line">$$</span><br><span class="line">SELECT</span><br><span class="line">    film_id,</span><br><span class="line">    title,</span><br><span class="line">    release_year</span><br><span class="line">FROM</span><br><span class="line">    film</span><br><span class="line">WHERE</span><br><span class="line">    film_id = f_id ;</span><br><span class="line">$$</span><br><span class="line">LANGUAGE SQL;</span><br><span class="line">CREATE FUNCTION</span><br></pre></td></tr></table></figure>
<blockquote>
<p>三，调用get_film_summary()函数：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># SELECT</span></span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    get_film_summary (40);</span><br><span class="line"> film_id |      title       | release_year</span><br><span class="line">---------+------------------+--------------</span><br><span class="line">      40 | Army Flintstones |         2006</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要更改类型或删除类型，请分别使用ALTER TYPE或DROP TYPE语句。</p>
</blockquote>
<blockquote>
<p>列出当前数据库中所有用户定义类型的命令是\dT或\dT+：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>=&gt; \dT</span><br><span class="line">          数据类型列表</span><br><span class="line"> 架构模式 |     名称     | 描述 </span><br><span class="line">----------+--------------+------</span><br><span class="line"> public   | contact_name | </span><br><span class="line"> public   | film_summary | </span><br><span class="line"> public   | mpaa_rating  | </span><br><span class="line"> public   | year         | </span><br><span class="line">(4 行记录)</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>=&gt; \dT+</span><br><span class="line">                                    数据类型列表</span><br><span class="line"> 架构模式 |     名称     |   内部名称   | 大小  | 成员  |  拥有者  | 存取权限 | 描述 </span><br><span class="line">----------+--------------+--------------+-------+-------+----------+----------+------</span><br><span class="line"> public   | contact_name | contact_name | var   |       | <span class="built_in">test</span>     |          | </span><br><span class="line"> public   | film_summary | film_summary | tuple |       | <span class="built_in">test</span>     |          | </span><br><span class="line"> public   | mpaa_rating  | mpaa_rating  | 4     | G    +| postgres |          | </span><br><span class="line">          |              |              |       | PG   +|          |          | </span><br><span class="line">          |              |              |       | PG-13+|          |          | </span><br><span class="line">          |              |              |       | R    +|          |          | </span><br><span class="line">          |              |              |       | NC-17 |          |          | </span><br><span class="line"> public   | year         | year         | 4     |       | postgres |          | </span><br><span class="line">(4 行记录)</span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/uploads/weixin.jpg" alt="ZhiJian wechat" style="width: auto; height:250px; max-width: 100%;">
    <div>欢迎您扫一扫上面的二维码，订阅我的微信公众号！</div>
</div>

      </div>
    

    
       
    
    

    
    
    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束,感谢您的阅读-------------</div>
    
</div>

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/pg/" rel="tag"><i class="fa fa-tag"></i> pg</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/pg9/" rel="next" title="PostgreSQL之管理数据库和表">
                <i class="fa fa-chevron-left"></i> PostgreSQL之管理数据库和表
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/pg11/" rel="prev" title="PostgreSQL之数据库架构与条件表达式和运算符">
                PostgreSQL之数据库架构与条件表达式和运算符 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="ZhiJian">
            
              <p class="site-author-name" itemprop="name">ZhiJian</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">43</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">26</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/zhijiansd" title="GitHub &rarr; https://github.com/zhijiansd" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:wangzhijiansd@qq.com" title="E-Mail &rarr; mailto:wangzhijiansd@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/zhitalk" title="weixin &rarr; zhitalk"><i class="fa fa-fw fa-weixin"></i>weixin</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="http://blog.51cto.com/wangzhijian" title="51blog &rarr; http://blog.51cto.com/wangzhijian" rel="noopener" target="_blank"><i class="fa fa-fw fa-pied-piper"></i>51blog</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库约束"><span class="nav-number">1.</span> <span class="nav-text">数据库约束</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#主键"><span class="nav-number">1.1.</span> <span class="nav-text">主键</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建表时定义主键"><span class="nav-number">1.1.1.</span> <span class="nav-text">创建表时定义主键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更改现有表结构时定义主键"><span class="nav-number">1.1.2.</span> <span class="nav-text">更改现有表结构时定义主键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#向现有表添加自动递增的主键"><span class="nav-number">1.1.3.</span> <span class="nav-text">向现有表添加自动递增的主键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除主键"><span class="nav-number">1.1.4.</span> <span class="nav-text">删除主键</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外键"><span class="nav-number">1.2.</span> <span class="nav-text">外键</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义简单的外键约束"><span class="nav-number">1.2.1.</span> <span class="nav-text">定义简单的外键约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将一组列定义为外键"><span class="nav-number">1.2.2.</span> <span class="nav-text">将一组列定义为外键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将外键约束添加到现有表"><span class="nav-number">1.2.3.</span> <span class="nav-text">将外键约束添加到现有表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CHECK约束"><span class="nav-number">1.3.</span> <span class="nav-text">CHECK约束</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为新表定义CHECK约束"><span class="nav-number">1.3.1.</span> <span class="nav-text">为新表定义CHECK约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为现有表定义CHECK约束"><span class="nav-number">1.3.2.</span> <span class="nav-text">为现有表定义CHECK约束</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UNIQUE约束"><span class="nav-number">1.4.</span> <span class="nav-text">UNIQUE约束</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UNIQUE约束示例"><span class="nav-number">1.4.1.</span> <span class="nav-text">UNIQUE约束示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在多列上创建约束"><span class="nav-number">1.4.2.</span> <span class="nav-text">在多列上创建约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用唯一索引添加唯一约束"><span class="nav-number">1.4.3.</span> <span class="nav-text">使用唯一索引添加唯一约束</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非空约束"><span class="nav-number">1.5.</span> <span class="nav-text">非空约束</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建新表时将非空约束添加到列"><span class="nav-number">1.5.1.</span> <span class="nav-text">创建新表时将非空约束添加到列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将非空约束添加到现有表的列中"><span class="nav-number">1.5.2.</span> <span class="nav-text">将非空约束添加到现有表的列中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非空约束的特殊情况"><span class="nav-number">1.5.3.</span> <span class="nav-text">非空约束的特殊情况</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库类型"><span class="nav-number">2.</span> <span class="nav-text">数据库类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#布尔数据类型"><span class="nav-number">2.1.</span> <span class="nav-text">布尔数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#布尔示例"><span class="nav-number">2.1.1.</span> <span class="nav-text">布尔示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设置布尔值列的默认值"><span class="nav-number">2.1.2.</span> <span class="nav-text">设置布尔值列的默认值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CHAR，VARCHAR和TEXT字符类型"><span class="nav-number">2.2.</span> <span class="nav-text">CHAR，VARCHAR和TEXT字符类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字符类型示例"><span class="nav-number">2.2.1.</span> <span class="nav-text">字符类型示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NUMERIC数据类型"><span class="nav-number">2.3.</span> <span class="nav-text">NUMERIC数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NUMERIC语法"><span class="nav-number">2.3.1.</span> <span class="nav-text">NUMERIC语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NUMERIC示例"><span class="nav-number">2.3.2.</span> <span class="nav-text">NUMERIC示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NUMERIC和NaN"><span class="nav-number">2.3.3.</span> <span class="nav-text">NUMERIC和NaN</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#整数数据类型"><span class="nav-number">2.4.</span> <span class="nav-text">整数数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SMALLINT"><span class="nav-number">2.4.1.</span> <span class="nav-text">SMALLINT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#INTEGER"><span class="nav-number">2.4.2.</span> <span class="nav-text">INTEGER</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BIGINT"><span class="nav-number">2.4.3.</span> <span class="nav-text">BIGINT</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DATE数据类型"><span class="nav-number">2.5.</span> <span class="nav-text">DATE数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DATE函数"><span class="nav-number">2.5.1.</span> <span class="nav-text">DATE函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取当前日期"><span class="nav-number">2.5.2.</span> <span class="nav-text">获取当前日期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#以特定格式输出日期值"><span class="nav-number">2.5.3.</span> <span class="nav-text">以特定格式输出日期值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取两个日期之间的间隔"><span class="nav-number">2.5.4.</span> <span class="nav-text">获取两个日期之间的间隔</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算年、月和日的年龄"><span class="nav-number">2.5.5.</span> <span class="nav-text">计算年、月和日的年龄</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#从日期值中提取年、季度、月、周、日"><span class="nav-number">2.5.6.</span> <span class="nav-text">从日期值中提取年、季度、月、周、日</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间戳数据类型"><span class="nav-number">2.6.</span> <span class="nav-text">时间戳数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时间戳示例"><span class="nav-number">2.6.1.</span> <span class="nav-text">时间戳示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取当前时间"><span class="nav-number">2.6.2.</span> <span class="nav-text">获取当前时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在时区之间转换"><span class="nav-number">2.6.3.</span> <span class="nav-text">在时区之间转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#间隔数据类型"><span class="nav-number">2.7.</span> <span class="nav-text">间隔数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PostgreSQL间隔输入格式"><span class="nav-number">2.7.1.</span> <span class="nav-text">PostgreSQL间隔输入格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ISO-8601间隔格式"><span class="nav-number">2.7.2.</span> <span class="nav-text">ISO 8601间隔格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PostgreSQL间隔输出格式"><span class="nav-number">2.7.3.</span> <span class="nav-text">PostgreSQL间隔输出格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PostgreSQL间隔相关的运算符和函数"><span class="nav-number">2.7.4.</span> <span class="nav-text">PostgreSQL间隔相关的运算符和函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#间隔运算符"><span class="nav-number">2.7.4.1.</span> <span class="nav-text">间隔运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#将PostgreSQL间隔转换为字符串"><span class="nav-number">2.7.4.2.</span> <span class="nav-text">将PostgreSQL间隔转换为字符串</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#从PostgreSQL间隔中提取数据"><span class="nav-number">2.7.5.</span> <span class="nav-text">从PostgreSQL间隔中提取数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#调整间隔值"><span class="nav-number">2.7.5.1.</span> <span class="nav-text">调整间隔值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TIME数据类型"><span class="nav-number">2.8.</span> <span class="nav-text">TIME数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TIME数据类型语法"><span class="nav-number">2.8.1.</span> <span class="nav-text">TIME数据类型语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TIME示例"><span class="nav-number">2.8.2.</span> <span class="nav-text">TIME示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时区类型的PostgreSQL-TIME"><span class="nav-number">2.8.3.</span> <span class="nav-text">时区类型的PostgreSQL TIME</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理PostgreSQL-TIME值"><span class="nav-number">2.8.4.</span> <span class="nav-text">处理PostgreSQL TIME值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#获取当前时间-1"><span class="nav-number">2.8.4.1.</span> <span class="nav-text">获取当前时间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#将时间转换为其他时区"><span class="nav-number">2.8.4.2.</span> <span class="nav-text">将时间转换为其他时区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#从时间值中提取小时、分钟、秒"><span class="nav-number">2.8.4.3.</span> <span class="nav-text">从时间值中提取小时、分钟、秒</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#时间值的算术运算"><span class="nav-number">2.8.4.4.</span> <span class="nav-text">时间值的算术运算</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UUID数据类型"><span class="nav-number">2.9.</span> <span class="nav-text">UUID数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生成UUID值"><span class="nav-number">2.9.1.</span> <span class="nav-text">生成UUID值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用UUID列创建表"><span class="nav-number">2.9.2.</span> <span class="nav-text">使用UUID列创建表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON数据类型"><span class="nav-number">2.10.</span> <span class="nav-text">JSON数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#插入JSON数据"><span class="nav-number">2.10.1.</span> <span class="nav-text">插入JSON数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询JSON数据"><span class="nav-number">2.10.2.</span> <span class="nav-text">查询JSON数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在WHERE子句中使用JSON运算符"><span class="nav-number">2.10.3.</span> <span class="nav-text">在WHERE子句中使用JSON运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将聚合函数应用于JSON数据"><span class="nav-number">2.10.4.</span> <span class="nav-text">将聚合函数应用于JSON数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON函数"><span class="nav-number">2.10.5.</span> <span class="nav-text">JSON函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#json-each函数"><span class="nav-number">2.10.5.1.</span> <span class="nav-text">json_each函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#json-object-keys函数"><span class="nav-number">2.10.5.2.</span> <span class="nav-text">json_object_keys函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#json-typeof函数"><span class="nav-number">2.10.5.3.</span> <span class="nav-text">json_typeof函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hstore数据类型"><span class="nav-number">2.11.</span> <span class="nav-text">hstore数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#启用hstore扩展"><span class="nav-number">2.11.1.</span> <span class="nav-text">启用hstore扩展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建具有hstore数据类型的表"><span class="nav-number">2.11.2.</span> <span class="nav-text">创建具有hstore数据类型的表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将数据插入hstore列"><span class="nav-number">2.11.3.</span> <span class="nav-text">将数据插入hstore列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#从hstore列查询数据"><span class="nav-number">2.11.4.</span> <span class="nav-text">从hstore列查询数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询特定键的值"><span class="nav-number">2.11.5.</span> <span class="nav-text">查询特定键的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在WHERE子句中使用值"><span class="nav-number">2.11.6.</span> <span class="nav-text">在WHERE子句中使用值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将键值对添加到现有行"><span class="nav-number">2.11.7.</span> <span class="nav-text">将键值对添加到现有行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更新现有的键值对"><span class="nav-number">2.11.8.</span> <span class="nav-text">更新现有的键值对</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除现有的键值对"><span class="nav-number">2.11.9.</span> <span class="nav-text">删除现有的键值对</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#检查hstore列中的特定键"><span class="nav-number">2.11.10.</span> <span class="nav-text">检查hstore列中的特定键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#检查键值对"><span class="nav-number">2.11.11.</span> <span class="nav-text">检查键值对</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询包含多个指定键的行"><span class="nav-number">2.11.12.</span> <span class="nav-text">查询包含多个指定键的行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#从hstore列获取所有密钥"><span class="nav-number">2.11.13.</span> <span class="nav-text">从hstore列获取所有密钥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#从hstore列获取所有值"><span class="nav-number">2.11.14.</span> <span class="nav-text">从hstore列获取所有值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将Hstore数据转换为JSON"><span class="nav-number">2.11.15.</span> <span class="nav-text">将Hstore数据转换为JSON</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将Hstore数据转换为集合"><span class="nav-number">2.11.16.</span> <span class="nav-text">将Hstore数据转换为集合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PostgreSQL数组"><span class="nav-number">2.12.</span> <span class="nav-text">PostgreSQL数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#插入PostgreSQL数组值"><span class="nav-number">2.12.1.</span> <span class="nav-text">插入PostgreSQL数组值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询数组数据"><span class="nav-number">2.12.2.</span> <span class="nav-text">查询数组数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修改PostgreSQL数组"><span class="nav-number">2.12.3.</span> <span class="nav-text">修改PostgreSQL数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在PostgreSQL数组中搜索"><span class="nav-number">2.12.4.</span> <span class="nav-text">在PostgreSQL数组中搜索</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#展开阵列"><span class="nav-number">2.13.</span> <span class="nav-text">展开阵列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用户定义的数据类型"><span class="nav-number">2.14.</span> <span class="nav-text">用户定义的数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建域"><span class="nav-number">2.14.1.</span> <span class="nav-text">创建域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建类型"><span class="nav-number">2.14.2.</span> <span class="nav-text">创建类型</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhiJian</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">732k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">20:20</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.5.0</div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      本站总访问量<span class="busuanzi-value" id="busuanzi_value_site_uv"></span>人次
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      本站总访问量<span class="busuanzi-value" id="busuanzi_value_site_pv"></span>次
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
      
  
  <script type="text/javascript" color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  








  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  
  
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'YDspHswalVwn03xuqlx5EKQF-gzGzoHsz',
        appKey: 'pA3bP9yhf50EIhapICs6ohRC',
        placeholder: '欢迎评论',
        avatar:'mm',
        meta:guest,
        pageSize:'10' || 10,
        visitor: false
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  
  

  

  

  

  

  

  


  
     <script type="text/javascript" color="255,48,48" opacity="0.7" zindex="-2" count="150" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  

</body>
</html>
